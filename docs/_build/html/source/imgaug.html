

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>imgaug package &mdash; imgaug 0.2.6 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="imgaug" href="modules.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> imgaug
          

          
          </a>

          
            
            
              <div class="version">
                0.2.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_basics.html">Examples: Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_keypoints.html">Examples: Keypoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples_bounding_boxes.html">Examples: Bounding Boxes</a></li>
<li class="toctree-l1"><a class="reference internal" href="parameters.html">Stochastic Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="alpha.html">Blending/Overlaying images</a></li>
<li class="toctree-l1"><a class="reference internal" href="augmenters.html">Overview of Augmenters</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">imgaug</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">imgaug package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.imgaug">imgaug</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.parameters">parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.meta">augmenters.meta</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.arithmetic">augmenters.arithmetic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.blur">augmenters.blur</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.color">augmenters.color</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.convolutional">augmenters.convolutional</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.flip">augmenters.flip</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.geometric">augmenters.geometric</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.overlay">augmenters.overlay</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.segmentation">augmenters.segmentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug.augmenters.size">augmenters.size</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-imgaug">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">imgaug</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">imgaug</a> &raquo;</li>
        
      <li>imgaug package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/source/imgaug.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="imgaug-package">
<h1>imgaug package<a class="headerlink" href="#imgaug-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-imgaug.imgaug">
<span id="imgaug"></span><h2>imgaug<a class="headerlink" href="#module-imgaug.imgaug" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="imgaug.imgaug.BackgroundAugmenter">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">BackgroundAugmenter</code><span class="sig-paren">(</span><em>batch_loader</em>, <em>augseq</em>, <em>queue_size=50</em>, <em>nb_workers='auto'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BackgroundAugmenter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BackgroundAugmenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class to augment batches in the background (while training on the GPU).</p>
<p>This is a wrapper around the multiprocessing module.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>batch_loader</strong> (<em>BatchLoader</em>) – BatchLoader object to load data in the
background.</li>
<li><strong>augseq</strong> (<em>Augmenter</em>) – An augmenter to apply to all loaded images.
This may be e.g. a Sequential to apply multiple augmenters.</li>
<li><strong>queue_size</strong> (<em>int</em>) – Size of the queue that is used to temporarily save the augmentation
results. Larger values offer the background processes more room
to save results when the main process doesn’t load much, i.e. they
can lead to smoother and faster training. For large images, high
values can block a lot of RAM though.</li>
<li><strong>nb_workers</strong> (<em>“auto” or int</em>) – Number of background workers to spawn. If auto, it will be set
to C-1, where C is the number of CPU cores.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.imgaug.BackgroundAugmenter.get_batch">
<code class="descname">get_batch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BackgroundAugmenter.get_batch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BackgroundAugmenter.get_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a batch from the queue of augmented batches.</p>
<p>If workers are still running and there are no batches in the queue,
it will automatically wait for the next batch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – One batch or None if all workers have finished.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">None or ia.Batch</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BackgroundAugmenter.terminate">
<code class="descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BackgroundAugmenter.terminate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BackgroundAugmenter.terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminates all background processes immediately.
This will also free their RAM.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.imgaug.Batch">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">Batch</code><span class="sig-paren">(</span><em>images=None</em>, <em>keypoints=None</em>, <em>data=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#Batch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.Batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class encapsulating a batch before and after augmentation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>images</strong> (<em>None or (N,H,W,C) ndarray or (N,H,W) ndarray or list of (H,W,C) ndarray or list of (H,W) ndarray</em>) – The images to
augment.</li>
<li><strong>keypoints</strong> (<em>None or list of KeypointOnImage</em>) – The keypoints to
augment.</li>
<li><strong>data</strong> (<em>anything</em>) – Additional data that is saved in the batch and may be read out
after augmentation. This could e.g. contain filepaths to each image
in <cite>images</cite>. As this object is usually used for background
augmentation with multiple processes, the augmented Batch objects might
not be returned in the original order, making this information useful.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="imgaug.imgaug.BatchLoader">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">BatchLoader</code><span class="sig-paren">(</span><em>load_batch_func</em>, <em>queue_size=50</em>, <em>nb_workers=1</em>, <em>threaded=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BatchLoader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BatchLoader" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class to load batches in the background.</p>
<p>Loaded batches can be accesses using <cite>BatchLoader.queue</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>load_batch_func</strong> (<em>callable</em>) – Function that yields Batch objects (i.e. expected to be a generator).
Background loading automatically stops when the last batch was yielded.</li>
<li><strong>queue_size</strong> (<em>int, optional(default=50)</em>) – Maximum number of batches to store in the queue. May be set higher
for small images and/or small batches.</li>
<li><strong>nb_workers</strong> (<em>int, optional(default=1)</em>) – Number of workers to run in the background.</li>
<li><strong>threaded</strong> (<em>bool, optional(default=True)</em>) – Whether to run the background processes using threads (true) or
full processes (false).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.imgaug.BatchLoader.all_finished">
<code class="descname">all_finished</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BatchLoader.all_finished"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BatchLoader.all_finished" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine whether the workers have finished the loading process.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if all workers have finished. Else False.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BatchLoader.terminate">
<code class="descname">terminate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BatchLoader.terminate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BatchLoader.terminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop all workers.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.imgaug.BoundingBox">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">BoundingBox</code><span class="sig-paren">(</span><em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em>, <em>label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.area">
<code class="descname">area</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.area" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.center_x">
<code class="descname">center_x</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.center_x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.center_y">
<code class="descname">center_y</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.center_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>x1=None</em>, <em>y1=None</em>, <em>x2=None</em>, <em>y2=None</em>, <em>label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.copy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.cut_out_of_image">
<code class="descname">cut_out_of_image</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.cut_out_of_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.cut_out_of_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><em>x1=None</em>, <em>y1=None</em>, <em>x2=None</em>, <em>y2=None</em>, <em>label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.deepcopy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.draw_on_image">
<code class="descname">draw_on_image</code><span class="sig-paren">(</span><em>image, color=[0, 255, 0], alpha=1.0, thickness=1, copy=True, raise_if_out_of_image=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.draw_on_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.draw_on_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.extend">
<code class="descname">extend</code><span class="sig-paren">(</span><em>all_sides=0</em>, <em>top=0</em>, <em>right=0</em>, <em>bottom=0</em>, <em>left=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.extend"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.extend" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.extract_from_image">
<code class="descname">extract_from_image</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.extract_from_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.extract_from_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.height">
<code class="descname">height</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.intersection">
<code class="descname">intersection</code><span class="sig-paren">(</span><em>other</em>, <em>default=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.intersection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.intersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.iou">
<code class="descname">iou</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.iou"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.iou" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.is_fully_within_image">
<code class="descname">is_fully_within_image</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.is_fully_within_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.is_fully_within_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.is_out_of_image">
<code class="descname">is_out_of_image</code><span class="sig-paren">(</span><em>image</em>, <em>fully=True</em>, <em>partly=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.is_out_of_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.is_out_of_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.is_partly_within_image">
<code class="descname">is_partly_within_image</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.is_partly_within_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.is_partly_within_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>from_shape</em>, <em>to_shape</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the bounding box onto a new position on a new image.</p>
<p>E.g. if the bounding box is on its original image at
x1=(10 of 100 pixels) and y1=(20 of 100 pixels) and is projected onto
a new image with size (width=200, height=200), its new position will
be (x1=20, y1=40). (Analogous for x2/y2.)</p>
<p>This is intended for cases where the original image is resized.
It cannot be used for more complex changes (e.g. padding, cropping).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>from_shape</strong> (<em>tuple</em>) – Shape of the original image. (Before resize.)</li>
<li><strong>to_shape</strong> (<em>tuple</em>) – Shape of the new image. (After resize.)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – BoundingBox object with new coordinates.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.imgaug.BoundingBox" title="imgaug.imgaug.BoundingBox">BoundingBox</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>top=None</em>, <em>right=None</em>, <em>bottom=None</em>, <em>left=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.to_keypoints">
<code class="descname">to_keypoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.to_keypoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.to_keypoints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBox.union">
<code class="descname">union</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBox.union"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBox.union" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.width">
<code class="descname">width</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.x1_int">
<code class="descname">x1_int</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.x1_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.x2_int">
<code class="descname">x2_int</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.x2_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.y1_int">
<code class="descname">y1_int</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.y1_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBox.y2_int">
<code class="descname">y2_int</code><a class="headerlink" href="#imgaug.imgaug.BoundingBox.y2_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.imgaug.BoundingBoxesOnImage">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">BoundingBoxesOnImage</code><span class="sig-paren">(</span><em>bounding_boxes</em>, <em>shape</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBoxesOnImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Object that represents all bounding boxes on a single image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bounding_boxes</strong> (<em>list of BoundingBox</em>) – List of bounding boxes on the image.</li>
<li><strong>shape</strong> (<em>tuple of int</em>) – The shape of the image on which the bounding boxes are placed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bbs</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">BoundingBox</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="mi">30</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">BoundingBox</span><span class="p">(</span><span class="n">x1</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="mi">70</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbs_oi</span> <span class="o">=</span> <span class="n">BoundingBoxesOnImage</span><span class="p">(</span><span class="n">bbs</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBoxesOnImage.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a shallow copy of the BoundingBoxesOnImage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Shallow copy.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.imgaug.BoundingBoxesOnImage" title="imgaug.imgaug.BoundingBoxesOnImage">BoundingBoxesOnImage</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.cut_out_of_image">
<code class="descname">cut_out_of_image</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBoxesOnImage.cut_out_of_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.cut_out_of_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBoxesOnImage.deepcopy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a deep copy of the BoundingBoxesOnImage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Deep copy.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.imgaug.KeypointsOnImage" title="imgaug.imgaug.KeypointsOnImage">KeypointsOnImage</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.draw_on_image">
<code class="descname">draw_on_image</code><span class="sig-paren">(</span><em>image, color=[0, 255, 0], alpha=1.0, thickness=1, copy=True, raise_if_out_of_image=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBoxesOnImage.draw_on_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.draw_on_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw all bounding boxes onto a given image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> (<em>(H,W,3) ndarray</em>) – The image onto which to draw the bounding boxes.
This image should usually have the same shape as
set in BoundingBoxesOnImage.shape.</li>
<li><strong>color</strong> (<em>int or list of ints or tuple of ints or (3,) ndarray, optional(default=[0, 255, 0])</em>) – The RGB color of all bounding boxes. If a single int <cite>C</cite>, then that is
equivalent to (C,C,C).</li>
<li><strong>size</strong> (<em>float, optional(default=1.0)</em>) – Alpha/transparency of the bounding box.</li>
<li><strong>thickness</strong> (<em>int, optional(default=1)</em>) – Thickness in pixels.</li>
<li><strong>copy</strong> (<em>bool, optional(default=True)</em>) – Whether to copy the image before drawing the points.</li>
<li><strong>raise_if_out_of_image</strong> (<em>bool, optional(default=False)</em>) – Whether to raise an exception if any bounding box is outside of the
image.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>image</strong> – Image with drawn bounding boxes.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(H,W,3) ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.height">
<code class="descname">height</code><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.on">
<code class="descname">on</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBoxesOnImage.on"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.on" title="Permalink to this definition">¶</a></dt>
<dd><p>Project bounding boxes from one image to a new one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> (<em>ndarray or tuple</em>) – New image onto which the bounding boxes are to be projected.
May also simply be that new image’s shape tuple.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>keypoints</strong> – Object containing all projected bounding boxes.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.imgaug.BoundingBoxesOnImage" title="imgaug.imgaug.BoundingBoxesOnImage">BoundingBoxesOnImage</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.remove_out_of_image">
<code class="descname">remove_out_of_image</code><span class="sig-paren">(</span><em>fully=True</em>, <em>partly=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBoxesOnImage.remove_out_of_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.remove_out_of_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>top=None</em>, <em>right=None</em>, <em>bottom=None</em>, <em>left=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#BoundingBoxesOnImage.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.shift" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.BoundingBoxesOnImage.width">
<code class="descname">width</code><a class="headerlink" href="#imgaug.imgaug.BoundingBoxesOnImage.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.imgaug.HooksImages">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">HooksImages</code><span class="sig-paren">(</span><em>activator=None</em>, <em>propagator=None</em>, <em>preprocessor=None</em>, <em>postprocessor=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#HooksImages"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.HooksImages" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Class to intervene with image augmentation runs.</p>
<p>This is e.g. useful to dynamically deactivate some augmenters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>activator</strong> (<em>None or callable, optional(default=None)</em>) – A function that gives permission to execute an augmenter.
The expected interface is</p>
<blockquote>
<div><p><cite>f(images, augmenter, parents, default)</cite>,</p>
</div></blockquote>
<p>where <cite>images</cite> are the input images to augment, <cite>augmenter</cite> is the
instance of the augmenter to execute, <cite>parents</cite> are previously
executed augmenters and <cite>default</cite> is an expected default value to be
returned if the activator function does not plan to make a decision
for the given inputs.</p>
</li>
<li><p class="first"><strong>propagator</strong> (<em>None or callable, optional(default=None)</em>) – A function that gives permission to propagate the augmentation further
to the children of an augmenter. This happens after the activator.
In theory, an augmenter may augment images itself (if allowed by the
activator) and then execute child augmenters afterwards (if allowed by
the propagator). If the activator returned False, the propagation step
will never be executed.
The expected interface is</p>
<blockquote>
<div><p><cite>f(images, augmenter, parents, default)</cite>,</p>
</div></blockquote>
<p>with all arguments having identical meaning to the activator.</p>
</li>
<li><p class="first"><strong>preprocessor</strong> (<em>None or callable, optional(default=None)</em>) – A function to call before an augmenter performed any augmentations.
The interface is</p>
<blockquote>
<div><p><cite>f(images, augmenter, parents)</cite>,</p>
</div></blockquote>
<p>with all arguments having identical meaning to the activator.
It is expected to return the input images, optionally modified.</p>
</li>
<li><p class="first"><strong>postprocessor</strong> (<em>None or callable, optional(default=None)</em>) – A function to call after an augmenter performed augmentations.
The interface is the same as for the preprocessor.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;blur&quot;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dropout&quot;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=-</span><span class="mi">5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;affine&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">activator</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">augmenter</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">augmenter</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;blur&quot;</span><span class="p">,</span> <span class="s2">&quot;dropout&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="n">default</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq_det</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">images_aug</span> <span class="o">=</span> <span class="n">seq_det</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">heatmaps_aug</span> <span class="o">=</span> <span class="n">seq_det</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">heatmaps</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">hooks</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">HooksImages</span><span class="p">(</span><span class="n">activator</span><span class="o">=</span><span class="n">activator</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
<p>This augments images and their respective heatmaps in the same way.
The heatmaps however are only modified by Affine, not by GaussianBlur or
Dropout.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.imgaug.HooksImages.is_activated">
<code class="descname">is_activated</code><span class="sig-paren">(</span><em>images</em>, <em>augmenter</em>, <em>parents</em>, <em>default</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#HooksImages.is_activated"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.HooksImages.is_activated" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether an augmenter may be executed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – If True, the augmenter may be executed. If False, it may
not be executed.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.HooksImages.is_propagating">
<code class="descname">is_propagating</code><span class="sig-paren">(</span><em>images</em>, <em>augmenter</em>, <em>parents</em>, <em>default</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#HooksImages.is_propagating"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.HooksImages.is_propagating" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns whether an augmenter may call its children to augment an
image. This is independent of the augmenter itself possible changing
the image, without calling its children. (Most (all?) augmenters with
children currently dont perform any changes themselves.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – If True, the augmenter may be propagate to its children.
If False, it may not.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.HooksImages.postprocess">
<code class="descname">postprocess</code><span class="sig-paren">(</span><em>images</em>, <em>augmenter</em>, <em>parents</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#HooksImages.postprocess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.HooksImages.postprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to be called after the augmentation of images was
performed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – The input images, optionally modified.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(N,H,W,C) ndarray or (N,H,W) ndarray or list of (H,W,C) ndarray or list of (H,W) ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.HooksImages.preprocess">
<code class="descname">preprocess</code><span class="sig-paren">(</span><em>images</em>, <em>augmenter</em>, <em>parents</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#HooksImages.preprocess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.HooksImages.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>A function to be called before the augmentation of images starts (per
augmenter).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – The input images, optionally modified.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(N,H,W,C) ndarray or (N,H,W) ndarray or list of (H,W,C) ndarray or list of (H,W) ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.imgaug.HooksKeypoints">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">HooksKeypoints</code><span class="sig-paren">(</span><em>activator=None</em>, <em>propagator=None</em>, <em>preprocessor=None</em>, <em>postprocessor=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#HooksKeypoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.HooksKeypoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.imgaug.HooksImages" title="imgaug.imgaug.HooksImages"><code class="xref py py-class docutils literal"><span class="pre">imgaug.imgaug.HooksImages</span></code></a></p>
<p>Class to intervene with keypoint augmentation runs.</p>
<p>This is e.g. useful to dynamically deactivate some augmenters.</p>
<p>This class is currently the same as the one for images. This may or may
not change in the future.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.imgaug.Keypoint">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">Keypoint</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#Keypoint"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.Keypoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A single keypoint (aka landmark) on an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> (<em>number</em>) – Coordinate of the keypoint on the x axis.</li>
<li><strong>y</strong> (<em>number</em>) – Coordinate of the keypoint on the y axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.imgaug.Keypoint.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>from_shape</em>, <em>to_shape</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#Keypoint.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.Keypoint.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Project the keypoint onto a new position on a new image.</p>
<p>E.g. if the keypoint is on its original image at x=(10 of 100 pixels)
and y=(20 of 100 pixels) and is projected onto a new image with
size (width=200, height=200), its new position will be (20, 40).</p>
<p>This is intended for cases where the original image is resized.
It cannot be used for more complex changes (e.g. padding, cropping).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>from_shape</strong> (<em>tuple</em>) – Shape of the original image. (Before resize.)</li>
<li><strong>to_shape</strong> (<em>tuple</em>) – Shape of the new image. (After resize.)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – Keypoint object with new coordinates.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.imgaug.Keypoint" title="imgaug.imgaug.Keypoint">Keypoint</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.Keypoint.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>x=0</em>, <em>y=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#Keypoint.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.Keypoint.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the keypoint around on an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>number, optional(default=0)</em>) – Move by this value on the x axis.</li>
<li><strong>y</strong> (<em>number, optional(default=0)</em>) – Move by this value on the y axis.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – Keypoint object with new coordinates.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.imgaug.Keypoint" title="imgaug.imgaug.Keypoint">Keypoint</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.Keypoint.x_int">
<code class="descname">x_int</code><a class="headerlink" href="#imgaug.imgaug.Keypoint.x_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.Keypoint.y_int">
<code class="descname">y_int</code><a class="headerlink" href="#imgaug.imgaug.Keypoint.y_int" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.imgaug.KeypointsOnImage">
<em class="property">class </em><code class="descclassname">imgaug.imgaug.</code><code class="descname">KeypointsOnImage</code><span class="sig-paren">(</span><em>keypoints</em>, <em>shape</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Object that represents all keypoints on a single image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>keypoints</strong> (<em>list of Keypoint</em>) – List of keypoints on the image.</li>
<li><strong>shape</strong> (<em>tuple of int</em>) – The shape of the image on which the keypoints are placed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">kps</span> <span class="o">=</span> <span class="p">[</span><span class="n">Keypoint</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span> <span class="n">Keypoint</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">34</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">60</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kps_oi</span> <span class="o">=</span> <span class="n">KeypointsOnImage</span><span class="p">(</span><span class="n">kps</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Attributes</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.imgaug.KeypointsOnImage.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a shallow copy of the KeypointsOnImage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Shallow copy.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.imgaug.KeypointsOnImage" title="imgaug.imgaug.KeypointsOnImage">KeypointsOnImage</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.KeypointsOnImage.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.deepcopy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a deep copy of the KeypointsOnImage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Deep copy.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.imgaug.KeypointsOnImage" title="imgaug.imgaug.KeypointsOnImage">KeypointsOnImage</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.KeypointsOnImage.draw_on_image">
<code class="descname">draw_on_image</code><span class="sig-paren">(</span><em>image, color=[0, 255, 0], size=3, copy=True, raise_if_out_of_image=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.draw_on_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.draw_on_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw all keypoints onto a given image. Each keypoint is marked by a
square of a chosen color and size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> (<em>(H,W,3) ndarray</em>) – The image onto which to draw the keypoints.
This image should usually have the same shape as
set in KeypointsOnImage.shape.</li>
<li><strong>color</strong> (<em>int or list of ints or tuple of ints or (3,) ndarray, optional(default=[0, 255, 0])</em>) – The RGB color of all keypoints. If a single int <cite>C</cite>, then that is
equivalent to (C,C,C).</li>
<li><strong>size</strong> (<em>int, optional(default=3)</em>) – The size of each point. If set to C, each square will have
size CxC.</li>
<li><strong>copy</strong> (<em>bool, optional(default=True)</em>) – Whether to copy the image before drawing the points.</li>
<li><strong>raise_if_out_of_image</strong> (<em>bool, optional(default=False)</em>) – Whether to raise an exception if any keypoint is outside of the
image.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>image</strong> – Image with drawn keypoints.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(H,W,3) ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="imgaug.imgaug.KeypointsOnImage.from_coords_array">
<em class="property">static </em><code class="descname">from_coords_array</code><span class="sig-paren">(</span><em>coords</em>, <em>shape</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.from_coords_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.from_coords_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an array (N,2) with a given image shape to a KeypointsOnImage
object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>coords</strong> (<em>(N, 2) ndarray</em>) – Coordinates of N keypoints on the original image.
Each first entry (i, 0) is expected to be the x coordinate.
Each second entry (i, 1) is expected to be the y coordinate.</li>
<li><strong>shape</strong> (<em>tuple</em>) – Shape tuple of the image on which the keypoints are placed.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – KeypointsOnImage object that contains all keypoints from the array.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.imgaug.KeypointsOnImage" title="imgaug.imgaug.KeypointsOnImage">KeypointsOnImage</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="imgaug.imgaug.KeypointsOnImage.from_keypoint_image">
<em class="property">static </em><code class="descname">from_keypoint_image</code><span class="sig-paren">(</span><em>image</em>, <em>if_not_found_coords={'x': -1</em>, <em>'y': -1}</em>, <em>threshold=1</em>, <em>nb_channels=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.from_keypoint_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.from_keypoint_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an image generated by <cite>to_keypoint_image()</cite> back to
an KeypointsOnImage object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> (<em>(H,W,N) ndarray</em>) – The keypoints image. N is the number of
keypoints.</li>
<li><strong>if_not_found_coords</strong> (<em>tuple or list or dict or None</em>) – Coordinates to use for keypoints that cannot be found in <cite>image</cite>.
If this is a list/tuple, it must have two integer values. If it
is a dictionary, it must have the keys “x” and “y”. If this
is None, then the keypoint will not be added to the final
KeypointsOnImage object.</li>
<li><strong>threshold</strong> (<em>int</em>) – The search for keypoints works by searching for the argmax in
each channel. This parameters contains the minimum value that
the max must have in order to be viewed as a keypoint.</li>
<li><strong>nb_channels</strong> (<em>None or int</em>) – Number of channels of the image on which the keypoints are placed.
Some keypoint augmenters require that information.
If set to None, the keypoint’s shape will be set
to <cite>(height, width)</cite>, otherwise <cite>(height, width, nb_channels)</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The extracted keypoints.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.imgaug.KeypointsOnImage" title="imgaug.imgaug.KeypointsOnImage">KeypointsOnImage</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.KeypointsOnImage.get_coords_array">
<code class="descname">get_coords_array</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.get_coords_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.get_coords_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the coordinates of all keypoints in this object to
an array of shape (N,2).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>result</strong> – Where N is the number of keypoints. Each first value is the
x coordinate, each second value is the y coordinate.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">(N, 2) ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.KeypointsOnImage.height">
<code class="descname">height</code><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.height" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.KeypointsOnImage.on">
<code class="descname">on</code><span class="sig-paren">(</span><em>image</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.on"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.on" title="Permalink to this definition">¶</a></dt>
<dd><p>Project keypoints from one image to a new one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>image</strong> (<em>ndarray or tuple</em>) – New image onto which the keypoints are to be projected.
May also simply be that new image’s shape tuple.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>keypoints</strong> – Object containing all projected keypoints.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.imgaug.KeypointsOnImage" title="imgaug.imgaug.KeypointsOnImage">KeypointsOnImage</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.KeypointsOnImage.shift">
<code class="descname">shift</code><span class="sig-paren">(</span><em>x=0</em>, <em>y=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Move the keypoints around on an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>number, optional(default=0)</em>) – Move each keypoint by this value on the x axis.</li>
<li><strong>y</strong> (<em>number, optional(default=0)</em>) – Move each keypoint by this value on the y axis.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – Keypoints after moving them.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.imgaug.KeypointsOnImage" title="imgaug.imgaug.KeypointsOnImage">KeypointsOnImage</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.imgaug.KeypointsOnImage.to_keypoint_image">
<code class="descname">to_keypoint_image</code><span class="sig-paren">(</span><em>size=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#KeypointsOnImage.to_keypoint_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.to_keypoint_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a new black image of shape (H,W,N) in which all keypoint coordinates
are set to 255.
(H=shape height, W=shape width, N=number of keypoints)</p>
<p>This function can be used as a helper when augmenting keypoints with
a method that only supports the augmentation of images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> (<em>int</em>) – Size of each (squared) point.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>image</strong> – Image in which the keypoints are marked. H is the height,
defined in KeypointsOnImage.shape[0] (analogous W). N is the
number of keypoints.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">(H,W,N) ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="imgaug.imgaug.KeypointsOnImage.width">
<code class="descname">width</code><a class="headerlink" href="#imgaug.imgaug.KeypointsOnImage.width" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.angle_between_vectors">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">angle_between_vectors</code><span class="sig-paren">(</span><em>v1</em>, <em>v2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#angle_between_vectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.angle_between_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the angle in radians between vectors ‘v1’ and ‘v2’.</p>
<p>From <a class="reference external" href="http://stackoverflow.com/questions/2827393/angles-between-two-n-dimensional-vectors-in-python">http://stackoverflow.com/questions/2827393/angles-between-two-n-dimensional-vectors-in-python</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>{v1, v2}</strong> (<em>(N,) ndarray</em>) – Input
vectors.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Angle in radians.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">angle_between</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">1.5707963267948966</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">angle_between</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">angle_between</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">3.141592653589793</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.copy_random_state">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">copy_random_state</code><span class="sig-paren">(</span><em>random_state</em>, <em>force_copy=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#copy_random_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.copy_random_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a copy of a random state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>random_state</strong> (<em>np.random.RandomState</em>) – The random state to
copy.</li>
<li><strong>force_copy</strong> (<em>bool, optional(default=False)</em>) – If True, this function will always create a copy of every random
state. If False, it will not copy numpy’s default random state,
but all other random states.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>rs_copy</strong> – The copied random state.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.random.RandomState</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.current_random_state">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">current_random_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#current_random_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.current_random_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current/global random state of the library.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – The current/global random state.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">np.random.RandomState</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.derive_random_state">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">derive_random_state</code><span class="sig-paren">(</span><em>random_state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#derive_random_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.derive_random_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.derive_random_states">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">derive_random_states</code><span class="sig-paren">(</span><em>random_state</em>, <em>n=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#derive_random_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.derive_random_states" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.do_assert">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">do_assert</code><span class="sig-paren">(</span><em>condition</em>, <em>message='Assertion failed.'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#do_assert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.do_assert" title="Permalink to this definition">¶</a></dt>
<dd><p>Function that behaves equally to an <cite>assert</cite> statement, but raises an
Exception.</p>
<p>This is added because <cite>assert</cite> statements are removed in optimized code.
It replaces <cite>assert</cite> statements throughout the library that should be
kept even in optimized code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>condition</strong> (<em>bool</em>) – If False, an exception is raised.</li>
<li><strong>message</strong> (<em>string, optional(default=”Assertion failed.”)</em>) – Error message.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.draw_grid">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">draw_grid</code><span class="sig-paren">(</span><em>images</em>, <em>rows=None</em>, <em>cols=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#draw_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.draw_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts multiple input images into a single image showing them in a grid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>images</strong> (<em>(N,H,W,3) ndarray or iterable of (H,W,3) array</em>) – The input images to convert to a grid.
Expected to be RGB and have dtype uint8.</li>
<li><strong>rows</strong> (<em>None or int, optional(default=None)</em>) – The number of rows to show in the grid.
If None, it will be automatically derived.</li>
<li><strong>cols</strong> (<em>None or int, optional(default=None)</em>) – The number of cols to show in the grid.
If None, it will be automatically derived.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>grid</strong> – Image of the generated grid.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(H’,W’,3) ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.draw_text">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">draw_text</code><span class="sig-paren">(</span><em>img, y, x, text, color=[0, 255, 0], size=25</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#draw_text"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.draw_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw text on an image.</p>
<p>This uses by default DejaVuSans as its font, which is included in the
library.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>img</strong> (<em>(H,W,3) ndarray</em>) – The image array to draw text on.
Expected to be of dtype uint8 or float32 (value range 0.0 to 255.0).</li>
<li><strong>{y, x}</strong> (<em>int</em>) – x- and y- coordinate of the top left corner of the
text.</li>
<li><strong>color</strong> (<em>iterable of 3 ints, optional(default=[0, 255, 0])</em>) – Color of the text to draw. For RGB-images this is expected to be
an RGB color.</li>
<li><strong>size</strong> (<em>int, optional(default=25)</em>) – Font size of the text to
draw.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>img_np</strong> – Input image with text drawn on it.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(H,W,3) ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.dummy_random_state">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">dummy_random_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#dummy_random_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.dummy_random_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dummy random state that is always based on a seed of 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – The new random state.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">np.random.RandomState</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.forward_random_state">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">forward_random_state</code><span class="sig-paren">(</span><em>random_state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#forward_random_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.forward_random_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.imresize_many_images">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">imresize_many_images</code><span class="sig-paren">(</span><em>images</em>, <em>sizes=None</em>, <em>interpolation=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#imresize_many_images"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.imresize_many_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize many images to a specified size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><p class="first"><strong>images</strong> (<em>(N,H,W,C) ndarray</em>) – Array of the images to resize.
Expected to usually be of dtype uint8.</p>
</li>
<li><p class="first"><strong>sizes</strong> (<em>iterable of two ints</em>) – The new size in (height, width)
format.</p>
</li>
<li><p class="first"><strong>interpolation</strong> (<em>None or string or int, optional(default=None)</em>) – The interpolation to use during resize.
If int, then expected to be one of:</p>
<blockquote>
<div><ul class="simple">
<li>cv2.INTER_NEAREST (nearest neighbour interpolation)</li>
<li>cv2.INTER_LINEAR (linear interpolation)</li>
<li>cv2.INTER_AREA (area interpolation)</li>
<li>cv2.INTER_CUBIC (cubic interpolation)</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>If string, then expected to be one of:</dt>
<dd><ul class="first last simple">
<li>“nearest” (identical to cv2.INTER_NEAREST)</li>
<li>“linear” (identical to cv2.INTER_LINEAR)</li>
<li>“area” (identical to cv2.INTER_AREA)</li>
<li>“cubic” (identical to cv2.INTER_CUBIC)</li>
</ul>
</dd>
</dl>
<p>If None, the interpolation will be chosen automatically. For size
increases, area interpolation will be picked and for size decreases,
linear interpolation will be picked.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> – Array of the resized images.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(N,H’,W’,C) ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.imresize_single_image">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">imresize_single_image</code><span class="sig-paren">(</span><em>image</em>, <em>sizes</em>, <em>interpolation=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#imresize_single_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.imresize_single_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Resizes a single image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> (<em>(H,W,C) ndarray or (H,W) ndarray</em>) – Array of the image to resize.
Expected to usually be of dtype uint8.</li>
<li><strong>sizes</strong> (<em>iterable of two ints</em>) – See <cite>imresize_many_images()</cite>.</li>
<li><strong>interpolation</strong> (<em>None or string or int, optional(default=None)</em>) – See <cite>imresize_many_images()</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The resized image.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(H’,W’,C) ndarray or (H’,W’) ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_callable">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_callable</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_callable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_callable" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is a callable, e.g. a function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is a callable. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_float_array">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_float_array</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_float_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_float_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is a numpy float array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is a numpy float array. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_integer_array">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_integer_array</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_integer_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_integer_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is a numpy integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is a numpy integer array. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_iterable">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_iterable</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_iterable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_iterable" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is iterable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is an iterable. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_np_array">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_np_array</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_np_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_np_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is a numpy array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is a numpy array. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_single_float">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_single_float</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_single_float"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_single_float" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is a float.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is a float. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_single_integer">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_single_integer</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_single_integer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_single_integer" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is an integer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is an integer. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_single_number">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_single_number</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_single_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_single_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is a number, i.e. an integer or float.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is a number. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.is_string">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">is_string</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#is_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.is_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a variable is a string.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>val</strong> (<em>anything</em>) – The variable to
check.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – True if the variable is a string. Otherwise False.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">bool</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.new_random_state">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">new_random_state</code><span class="sig-paren">(</span><em>seed=None</em>, <em>fully_random=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#new_random_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.new_random_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new random state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>seed</strong> (<em>None or int, optional(default=None)</em>) – Optional seed value to use.
The same datatypes are allowed as for np.random.RandomState(seed).</li>
<li><strong>fully_random</strong> (<em>bool, optional(default=False)</em>) – Whether to use numpy’s random initialization for the
RandomState (used if set to True). If False, a seed is sampled from
the global random state, which is a bit faster and hence the default.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – The new random state.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">np.random.RandomState</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.quokka">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">quokka</code><span class="sig-paren">(</span><em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#quokka"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.quokka" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an image of a quokka as a numpy array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> (<em>None or float or tuple of two ints, optional(default=None)</em>) – Size of the output image. Input into scipy.misc.imresize.
Usually expected to be a tuple (H, W), where H is the desired height
and W is the width. If None, then the image will not be resized.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>img</strong> – The image array of dtype uint8.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">(H,W,3) ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.quokka_square">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">quokka_square</code><span class="sig-paren">(</span><em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#quokka_square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.quokka_square" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an (square) image of a quokka as a numpy array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>size</strong> (<em>None or float or tuple of two ints, optional(default=None)</em>) – Size of the output image. Input into scipy.misc.imresize.
Usually expected to be a tuple (H, W), where H is the desired height
and W is the width. If None, then the image will not be resized.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>img</strong> – The image array of dtype uint8.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">(H,W,3) ndarray</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.seed">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">seed</code><span class="sig-paren">(</span><em>seedval</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#seed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the seed used by the global random state and thereby all randomness
in the library.</p>
<p>This random state is by default by all augmenters. Under special
circumstances (e.g. when an augmenter is switched to deterministic mode),
the global random state is replaced by another – local – one.
The replacement is dependent on the global random state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>seedval</strong> (<em>int</em>) – The seed to
use.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.imgaug.show_grid">
<code class="descclassname">imgaug.imgaug.</code><code class="descname">show_grid</code><span class="sig-paren">(</span><em>images</em>, <em>rows=None</em>, <em>cols=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/imgaug.html#show_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.imgaug.show_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts the input images to a grid image and shows it in a new window.</p>
<p>This function wraps around scipy.misc.imshow(), which requires the
<cite>see &lt;image&gt;</cite> command to work. On Windows systems, this tends to not be
the case.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>images</strong> (<em>(N,H,W,3) ndarray or iterable of (H,W,3) array</em>) – See <cite>draw_grid()</cite>.</li>
<li><strong>rows</strong> (<em>None or int, optional(default=None)</em>) – See <cite>draw_grid()</cite>.</li>
<li><strong>cols</strong> (<em>None or int, optional(default=None)</em>) – See <cite>draw_grid()</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-imgaug.parameters">
<span id="parameters"></span><h2>parameters<a class="headerlink" href="#module-imgaug.parameters" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="imgaug.parameters.Absolute">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Absolute</code><span class="sig-paren">(</span><em>other_param</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Absolute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Absolute" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Converts another parameter’s results to absolute values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other_param</strong> (<em>StochasticParameter</em>) – Other parameter which’s sampled values are to be
modified.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Absolute</span><span class="p">(</span><span class="n">Uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Converts a uniform range [-1.0, 1.0) to [0.0, 1.0].</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Add">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Add</code><span class="sig-paren">(</span><em>other_param</em>, <em>val</em>, <em>elementwise=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Add" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter to add to other parameter’s results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Other parameter which’s sampled values are to be
modified.</li>
<li><strong>val</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Value to add to the other parameter’s results. If this is a
StochasticParameter, either a single or multiple values will be
sampled and added.</li>
<li><strong>elementwise</strong> (<em>bool, optional(default=False)</em>) – Controls the sampling behaviour when <cite>val</cite> is a StochasticParameter.
If set to False, a single value will be sampled from val and added
to all values generated by <cite>other_param</cite>.
If set to True and <cite>_draw_samples(size=S)</cite> is called, <cite>S</cite> values will
be sampled from <cite>val</cite> and added to the results of <cite>other_param</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">Uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Converts a uniform range [0.0, 1.0) to [1.0, 2.0).</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Beta">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Beta</code><span class="sig-paren">(</span><em>alpha</em>, <em>beta</em>, <em>epsilon=0.0001</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Beta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a (continuous) beta distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>{alpha, beta}</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – alpha and beta parameters of the beta
distribution.</p>
<blockquote>
<div><ul class="simple">
<li>If number, that number will always be used.</li>
<li>If tuple of two number, a random value will be sampled per
call to <cite>_draw_samples()</cite> from the range [a, b).</li>
<li>If list of number, a random element from that list will be
sampled per call to <cite>_draw_samples()</cite>.</li>
<li>If a StochasticParameter, a random value will be sampled
from that parameter per call to <cite>_draw_samples()</cite>.</li>
</ul>
</div></blockquote>
<p>alpha and beta have to be values above 0. If they end up &lt;=0 they
are automatically clipped to 0+epsilon.</p>
</li>
<li><p class="first"><strong>epsilon</strong> (<em>number</em>) – Clipping parameter. If alpha or beta end up &lt;=0, they are clipped to
0+epsilon.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Beta</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Samples random values from the beta distribution with alpha=beta=0.5.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Binomial">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Binomial</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Binomial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Binomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Binomial distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Probability of the binomial distribution. Expected to be in the
range [0, 1]. If this is a StochasticParameter, the value will be
sampled once per call to _draw_samples().</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Binomial</span><span class="p">(</span><span class="n">Uniform</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">))</span>
</pre></div>
</div>
<p>Uses a varying probability <cite>p</cite> between 0.01 and 0.2 per sampling.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.ChiSquare">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">ChiSquare</code><span class="sig-paren">(</span><em>df</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#ChiSquare"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.ChiSquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a (continuous) chi-square distribution.</p>
<p>This is a wrapper around numpy’s random.chisquare().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df</strong> (<em>int or tuple of two int or list of int or StochasticParameter</em>) – Degrees of freedom (must be 1 or
higher).</p>
<blockquote class="last">
<div><ul class="simple">
<li>If a single int, this int will be used as a constant value.</li>
<li>If a tuple of two ints (a, b), the value will be sampled
once per call to <cite>_draw_samples()</cite> from the discrete
range [a..b].</li>
<li>If a list of ints, a random value will be picked from the
list per call to <cite>_draw_samples()</cite>.</li>
<li>If a StochasticParameter, that parameter will be queried once
per call to <cite>_draw_samples()</cite>.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">ChiSquare</span><span class="p">(</span><span class="n">df</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>A chi-square distribution with two degrees of freedom.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Choice">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Choice</code><span class="sig-paren">(</span><em>a</em>, <em>replace=True</em>, <em>p=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Choice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Choice" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that samples value from a list of allowed values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> (<em>iterable</em>) – List of allowed values.
Usually expected to be integers, floats or strings.</li>
<li><strong>replace</strong> (<em>bool, optional(default=True)</em>) – Whether to perform sampling with or without
replacing.</li>
<li><strong>p</strong> (<em>None or iterable, optional(default=None)</em>) – Optional probabilities of each element in <cite>a</cite>.
Must have the same length as <cite>a</cite> (if provided).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
</pre></div>
</div>
<p>Parameter of which 50 pecent of all sampled values will be 0.5.
The other 50 percent will be either 0.25 or 0.75.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Clip">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Clip</code><span class="sig-paren">(</span><em>other_param</em>, <em>minval=None</em>, <em>maxval=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Clip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Clips another parameter to a defined value range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – The other parameter, which’s values are to be
clipped.</li>
<li><strong>minval</strong> (<em>None or number, optional(default=None)</em>) – The minimum value to use.
If None, no minimum will be used.</li>
<li><strong>maxval</strong> (<em>None or number, optional(default=None)</em>) – The maximum value to use.
If None, no maximum will be used.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Clip</span><span class="p">(</span><span class="n">Normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">minval</span><span class="o">=-</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">maxval</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Defines a standard normal distribution, which’s values never go below -2.0
or above 2.0. Note that this will lead to small “bumps” of higher
probability at -2.0 and 2.0, as values below/above these will be clipped
to them.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Deterministic">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Deterministic</code><span class="sig-paren">(</span><em>value</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Deterministic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Deterministic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a constant value.</p>
<p>If N values are sampled from this parameter, it will return N times V,
where V is the constant value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>value</strong> (<em>number or string or StochasticParameter</em>) – A constant value to use.
A string may be provided to generate arrays of strings.
If this is a StochasticParameter, a single value will be sampled
from it exactly once and then used as the constant value.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Will always sample the value 10.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.DiscreteUniform">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">DiscreteUniform</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#DiscreteUniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.DiscreteUniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a discrete range of values [a .. b].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>{a, b}</strong> (<em>int or StochasticParameter</em>) – Lower and upper bound of the sampling range. Values will be sampled
from a &lt;= x &lt;= b. All sampled values will be discrete. If a or b is
a StochasticParameter, it will be queried once per sampling to
estimate the value of a/b. If a&gt;b, the values will automatically be
flipped. If a==b, all generated values will be identical to a.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">Choice</span><span class="p">([</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">]))</span>
</pre></div>
</div>
<p>Sampled values will be discrete and come from the either [10..20] or
[10..30] or [10..40].</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Discretize">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Discretize</code><span class="sig-paren">(</span><em>other_param</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Discretize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Discretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Convert values sampled from a continuous distribution into discrete values.</p>
<p>This will round the values and then cast them to integers.
Values sampled from discrete distributions are not changed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>other_param</strong> (<em>StochasticParameter</em>) – The other parameter, which’s values are to be
discretized.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Discretize</span><span class="p">(</span><span class="n">Normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Generates a discrete standard normal distribution.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Divide">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Divide</code><span class="sig-paren">(</span><em>other_param</em>, <em>val</em>, <em>elementwise=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter to divide other parameter’s results with.</p>
<p>This parameter will automatically prevent division by zero (uses 1.0)
as the denominator in these cases.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Other parameter which’s sampled values are to be
divided.</li>
<li><strong>val</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Denominator to use. If this is a StochasticParameter, either
a single or multiple values will be sampled and used as the
denominator(s).</li>
<li><strong>elementwise</strong> (<em>bool, optional(default=False)</em>) – Controls the sampling behaviour when <cite>val</cite> is a StochasticParameter.
If set to False, a single value will be sampled from val and used as
the constant denominator.
If set to True and <cite>_draw_samples(size=S)</cite> is called, <cite>S</cite> values will
be sampled from <cite>val</cite> and used as the elementwise denominators for the
results of <cite>other_param</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Divide</span><span class="p">(</span><span class="n">Uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Converts a uniform range [0.0, 1.0) to [0, 0.5).</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.ForceSign">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">ForceSign</code><span class="sig-paren">(</span><em>other_param</em>, <em>positive</em>, <em>mode='invert'</em>, <em>reroll_count_max=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#ForceSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.ForceSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Converts another parameter’s results to positive or negative values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – Other parameter which’s sampled values are to be
modified.</li>
<li><strong>positive</strong> (<em>bool</em>) – Whether to force all signs to be positive/+ (True) or
negative/- (False).</li>
<li><strong>mode</strong> (<em>string, optional(default=”invert”)</em>) – How to change the signs. Valid values are “invert” and “reroll”.
“invert” means that wrong signs are simply flipped.
“reroll” means that all samples with wrong signs are sampled again,
optionally many times, until they randomly end up having the correct
sign.</li>
<li><strong>reroll_count_max</strong> (<em>int, optional(default=2)</em>) – If <cite>mode</cite> is set to “reroll”, this determines how often values may
be rerolled before giving up and simply flipping the sign (as in
mode=”invert”). This shouldn’t be set too high, as rerolling is
expensive.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">ForceSign</span><span class="p">(</span><span class="n">Poisson</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">positive</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Generates a poisson distribution with alpha=1 that is flipped towards
negative values.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.FrequencyNoise">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">FrequencyNoise</code><span class="sig-paren">(</span><em>exponent=(-4, 4), size_px_max=(4, 32), upscale_method=['linear', 'nearest']</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#FrequencyNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.FrequencyNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter to generate noise of varying frequencies.</p>
<p>This parameter expects to sample noise for 2d planes, i.e. for
sizes (H, W) and will return a value in the range [0.0, 1.0] per location
in that plane.</p>
<p>The exponent controls the frequencies and therefore noise patterns.
Low values (around -4.0) will result in large blobs. High values (around
4.0) will result in small, repetitive patterns.</p>
<p>The noise is sampled from low resolution planes and
upscaled to the requested height and width. The size of the low
resolution plane may be defined (high values can be slow) and the
interpolation method for upscaling can be set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>exponent</strong> (<em>number or tuple of numbers of list of numbers or StochasticParameter, optional(default=(-4, 4))</em>) – Exponent to use when scaling in the frequency domain.
Sane values are in the range -4 (large blobs) to 4 (small patterns).
To generate cloud-like structures, use roughly -2.</p>
<blockquote>
<div><ul class="simple">
<li>If number, then that number will be used as the exponent for all
iterations.</li>
<li>If tuple of two numbers (a, b), then a value will be sampled
per iteration from the range [a, b].</li>
<li>If a list of numbers, then a value will be picked per iteration
at random from that list.</li>
<li>If a StochasticParameter, then a value will be sampled from
that parameter per iteration.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_px_max</strong> (<em>int or tuple of ints or list of ints or StochasticParameter, optional(default=(4, 16))</em>) – The frequency noise is generated in a low resolution environment.
This parameter defines the maximum size of that environment (in
pixels). The environment is initialized at the same size as the input
image and then downscaled, so that no side exceeds <cite>size_px_max</cite>
(aspect ratio is kept).</p>
<blockquote>
<div><ul class="simple">
<li>If int, then that number will be used as the size for all
iterations.</li>
<li>If tuple of two ints (a, b), then a value will be sampled
per iteration from the discrete range [a..b].</li>
<li>If a list of ints, then a value will be picked per iteration at
random from that list.</li>
<li>If a StochasticParameter, then a value will be sampled from
that parameter per iteration.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>upscale_method</strong> (<em>None or ia.ALL or string or list of string or StochasticParameter, optional(default=None)</em>) – After generating the noise maps in low resolution environments, they
have to be upscaled to the input image size. This parameter controls
the upscaling method.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then either ‘nearest’ or ‘linear’ or ‘cubic’ is picked.
Most weight is put on linear, followed by cubic.</li>
<li>If ia.ALL, then either ‘nearest’ or ‘linear’ or ‘area’ or ‘cubic’
is picked per iteration (all same probability).</li>
<li>If string, then that value will be used as the method (must be
‘nearest’ or ‘linear’ or ‘area’ or ‘cubic’).</li>
<li>If list of string, then a random value will be picked from that
list per iteration.</li>
<li>If StochasticParameter, then a random value will be sampled
from that parameter per iteration.</li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">FrequencyNoise</span><span class="p">(</span><span class="n">exponent</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">size_px_max</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span> <span class="n">upscale_method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Generates noise with cloud-like patterns.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.FromLowerResolution">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">FromLowerResolution</code><span class="sig-paren">(</span><em>other_param</em>, <em>size_percent=None</em>, <em>size_px=None</em>, <em>method='nearest'</em>, <em>min_size=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#FromLowerResolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.FromLowerResolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>A meta parameter used to sample other parameter values on a low resolution
2d plane (where 2d means of size (H,W,C)).</p>
<p>This is intended to be used with parameters that would usually sample
once value per pixel (or one value per pixel and channel). With this
parameter, the sampling can be made more coarse, i.e. the result will
become rectangles instead of single pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – The other parameter which is to be sampled on a coarser
image.</li>
<li><strong>size_percent</strong> (<em>None or number or iterable of two numbers or StochasticParameter, optional(default=None)</em>) – Size of the 2d sampling plane in percent of the requested size.
I.e. this is relative to the size provided in the call to
<cite>_draw_samples(size, …)</cite>. Lower values will result in smaller
sampling planes, which are then upsampled to <cite>size</cite>. This means that
lower values will result in larger rectangles.
The size may be provided as a constant value or a tuple (a, b), which
will automatically be converted to the continuous uniform range [a, b)
or a StochasticParameter, which will be queried per call to
<cite>_draw_samples()</cite>.</li>
<li><strong>size_px</strong> (<em>None or number or iterable of two numbers or StochasticParameter, optional(default=None)</em>) – Size of the 2d sampling plane in pixels.
Lower values will result in smaller sampling planes, which are then
upsampled to the input <cite>size</cite> of <cite>draw_samples(size, …)</cite>.
This means that lower values will result in larger rectangles.
The size may be provided as a constant value or a tuple (a, b), which
will automatically be converted to the discrete uniform range [a..b]
or a StochasticParameter, which will be queried per call to
<cite>_draw_samples()</cite>.</li>
<li><strong>method</strong> (<em>string or int or StochasticParameter, optional(default=”nearest”)</em>) – Upsampling/interpolation method to use. This is used after the sampling
is finished and the low resolution plane has to be upsampled to the
requested <cite>size</cite> in <cite>_draw_samples(size, …)</cite>. The method may be
the same as in <cite>imgaug.imresize_many_images()</cite>. Usually <cite>nearest</cite>
or <cite>linear</cite> are good choices. <cite>nearest</cite> will result in rectangles
with sharp edges and <cite>linear</cite> in rectangles with blurry and round
edges. The method may be provided as a StochasticParameter, which
will be queried per call to <cite>_draw_samples()</cite>.</li>
<li><strong>min_size</strong> (<em>int, optional(default=1)</em>) – Minimum size in pixels of the low resolution sampling
plane.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">FromLowerResolution</span><span class="p">(</span><span class="n">Binomial</span><span class="p">(</span><span class="mf">0.05</span><span class="p">),</span> <span class="n">size_px</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">Choice</span><span class="p">([</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">]))</span>
</pre></div>
</div>
<p>Samples from a binomial distribution with p=0.05. The sampling plane
will always have a size HxWxC with H and W being independently sampled
from [2..16] (i.e. it may range from 2x2xC up to 16x16xC max, but may
also be e.g. 4x8xC). The upsampling method will be “nearest” in 50 percent
of all cases and “linear” in the other 50 percent. The result will
sometimes be rectangular patches of sharp 1s surrounded by 0s and
sometimes blurry blobs of 1s, surrounded by values &lt;1.0.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.IterativeNoiseAggregator">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">IterativeNoiseAggregator</code><span class="sig-paren">(</span><em>other_param, iterations=(1, 3), aggregation_method=['max', 'avg']</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#IterativeNoiseAggregator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.IterativeNoiseAggregator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter to generate noise maps in multiple iterations and aggregate
their results.</p>
<p>This is supposed to be used in conjunction with SimplexNoise or
FrequencyNoise.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – The noise parameter to iterate multiple
times.</li>
<li><strong>iterations</strong> (<em>int or iterable of two ints or list of ints or StochasticParameter, optional(default=(1, 3))</em>) – The number of iterations. This may be a single integer or a tuple
of integers (a, b), which will result in [a..b] iterations or
a list of integers [a, b, c, …], which will result in a or b or
c, … iterations. It may also be a StochasticParameter, in which case
the number of iterations will be sampled once per call
to <cite>_draw_samples()</cite>.</li>
<li><strong>aggregation_method</strong> (<em>ia.ALL or string or list of string or StochasticParameter, optional(default=[“max”, “avg”])</em>) – The method to use to aggregate the results of multiple iterations.
If a string, it must have the value “min” or “max” or “avg”.
If “min” is chosen, the elementwise minimum will be computed over
all iterations (pushing the noise towards zeros). “max” will result
in the elementwise maximum and “avg” in the average over all
iterations. If <cite>ia.ALL</cite> is used, it will be randomly either min or max
or avg (per call to <cite>_draw_samples()</cite>). If a list is chosen, it must
contain the mentioned strings and a random one will be picked per call
to <cite>_draw_samples()</cite>. If a StochasticParameter is used, a value will
be sampled from it per call to <cite>_draw_samples()</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">noise</span> <span class="o">=</span> <span class="n">IterativeNoiseAggregator</span><span class="p">(</span><span class="n">SimplexNoise</span><span class="p">(),</span> <span class="n">iterations</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">aggregation_method</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Generates per call 2 to 5 times simplex noise of a given size. Then
combines these noise maps to a single map using elementwise maximum.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Laplace">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Laplace</code><span class="sig-paren">(</span><em>loc</em>, <em>scale</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Laplace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Laplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a (continuous) laplace distribution.</p>
<p>This is a wrapper around numpy’s random.laplace().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>loc</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – The position of the distribution peak, similar to the mean in normal
distributions.</p>
<blockquote>
<div><ul class="simple">
<li>If a single number, this number will be used as a constant value.</li>
<li>If a tuple of two numbers (a, b), the value will be sampled
once per call to <cite>_draw_samples()</cite> from the continuous
range [a, b).</li>
<li>If a list of numbers, a random value will be picked from the
list per call to <cite>_draw_samples()</cite>.</li>
<li>If a StochasticParameter, that parameter will be queried once
per call to <cite>_draw_samples()</cite>.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>scale</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – The exponential decay factor, similar to standard deviation in
normal distributions.</p>
<blockquote>
<div><ul class="simple">
<li>If a single number, this number will be used as a constant value.</li>
<li>If a tuple of two numbers (a, b), the value will be sampled
once per call to <cite>_draw_samples()</cite> from the continuous
range [a, b).</li>
<li>If a list of numbers, a random value will be picked from the
list per call to <cite>_draw_samples()</cite>.</li>
<li>If a StochasticParameter, that parameter will be queried once
per call to <cite>_draw_samples()</cite>.</li>
</ul>
</div></blockquote>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Laplace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>A laplace distribution, which’s peak is at 0 and decay is 1.0.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Multiply">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Multiply</code><span class="sig-paren">(</span><em>other_param</em>, <em>val</em>, <em>elementwise=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter to multiply other parameter’s results with.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Other parameter which’s sampled values are to be
multiplied.</li>
<li><strong>val</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Multiplier to use. If this is a StochasticParameter, either
a single or multiple values will be sampled and used as the
multiplier(s).</li>
<li><strong>elementwise</strong> (<em>bool, optional(default=False)</em>) – Controls the sampling behaviour when <cite>val</cite> is a StochasticParameter.
If set to False, a single value will be sampled from val and used as
the constant multiplier.
If set to True and <cite>_draw_samples(size=S)</cite> is called, <cite>S</cite> values will
be sampled from <cite>val</cite> and multiplied elementwise with the results
of <cite>other_param</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Multiply</span><span class="p">(</span><span class="n">Uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Converts a uniform range [0.0, 1.0) to (-1.0, 0.0].</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.parameters.Negative">
<code class="descclassname">imgaug.parameters.</code><code class="descname">Negative</code><span class="sig-paren">(</span><em>other_param</em>, <em>mode='invert'</em>, <em>reroll_count_max=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Negative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts another parameter’s results to negative values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – Other parameter which’s sampled values are to be
modified.</li>
<li><strong>mode</strong> (<em>string, optional(default=”invert”)</em>) – How to change the signs. Valid values are “invert” and “reroll”.
“invert” means that wrong signs are simply flipped.
“reroll” means that all samples with wrong signs are sampled again,
optionally many times, until they randomly end up having the correct
sign.</li>
<li><strong>reroll_count_max</strong> (<em>int, optional(default=2)</em>) – If <cite>mode</cite> is set to “reroll”, this determines how often values may
be rerolled before giving up and simply flipping the sign (as in
mode=”invert”). This shouldn’t be set too high, as rerolling is
expensive.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Negative</span><span class="p">(</span><span class="n">Normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reroll&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Generates a normal distribution that has only negative values.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Normal">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Normal</code><span class="sig-paren">(</span><em>loc</em>, <em>scale</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Normal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a (continuous) normal distribution.</p>
<p>This is a wrapper around numpy’s random.normal().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>loc</strong> (<em>number or StochasticParameter</em>) – The mean of the normal distribution.
If StochasticParameter, the mean will be sampled once per call
to <cite>_draw_samples()</cite>.</li>
<li><strong>scale</strong> (<em>number or StochasticParameter</em>) – The standard deviation of the normal distribution.
If StochasticParameter, the scale will be sampled once per call
to <cite>_draw_samples()</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">(</span><span class="n">Choice</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]),</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>A standard normal distribution, which’s mean is shifted either 1.0 to
the left or 1.0 to the right.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Poisson">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Poisson</code><span class="sig-paren">(</span><em>lam</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Poisson"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Poisson" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a poisson distribution.</p>
<p>A poisson distribution with lambda=0 has its highest probability at
point 0 and decreases quickly from there.
Poisson distributions are discrete and never negative.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>lam</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Lambda parameter of the poisson
distribution.</p>
<blockquote class="last">
<div><ul class="simple">
<li>If a number, this number will be used as a constant value.</li>
<li>If a tuple of two numbers (a, b), the value will be sampled
once per call to <cite>_draw_samples()</cite> from the range [a, b).</li>
<li>If a list of numbers, a random value will be picked from the
list per call to <cite>_draw_samples()</cite>.</li>
<li>If a StochasticParameter, that parameter will be queried once
per call to <cite>_draw_samples()</cite>.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Poisson</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Sample from a poisson distribution with lambda=1.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.parameters.Positive">
<code class="descclassname">imgaug.parameters.</code><code class="descname">Positive</code><span class="sig-paren">(</span><em>other_param</em>, <em>mode='invert'</em>, <em>reroll_count_max=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Positive"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Positive" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts another parameter’s results to positive values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – Other parameter which’s sampled values are to be
modified.</li>
<li><strong>mode</strong> (<em>string, optional(default=”invert”)</em>) – How to change the signs. Valid values are “invert” and “reroll”.
“invert” means that wrong signs are simply flipped.
“reroll” means that all samples with wrong signs are sampled again,
optionally many times, until they randomly end up having the correct
sign.</li>
<li><strong>reroll_count_max</strong> (<em>int, optional(default=2)</em>) – If <cite>mode</cite> is set to “reroll”, this determines how often values may
be rerolled before giving up and simply flipping the sign (as in
mode=”invert”). This shouldn’t be set too high, as rerolling is
expensive.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Positive</span><span class="p">(</span><span class="n">Normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reroll&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Generates a normal distribution that has only positive values.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Power">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Power</code><span class="sig-paren">(</span><em>other_param</em>, <em>val</em>, <em>elementwise=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Power"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Power" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter to exponentiate another parameter’s results with.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Other parameter which’s sampled values are to be
modified.</li>
<li><strong>val</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Value to use exponentiate the other parameter’s results with. If this
is a StochasticParameter, either a single or multiple values will be
sampled and used as the exponents.</li>
<li><strong>elementwise</strong> (<em>bool, optional(default=False)</em>) – Controls the sampling behaviour when <cite>val</cite> is a StochasticParameter.
If set to False, a single value will be sampled from val and used as
the exponent for all values generated by <cite>other_param</cite>.
If set to True and <cite>_draw_samples(size=S)</cite> is called, <cite>S</cite> values will
be sampled from <cite>val</cite> and used as the exponents for the results of
<cite>other_param</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Power</span><span class="p">(</span><span class="n">Uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Converts a uniform range [0.0, 1.0) to a distribution that is peaked
towards 1.0.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.RandomSign">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">RandomSign</code><span class="sig-paren">(</span><em>other_param</em>, <em>p_positive=0.5</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#RandomSign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.RandomSign" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Converts another parameter’s results randomly to positive or negative
values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – Other parameter which’s sampled values are to be
modified.</li>
<li><strong>p_positive</strong> (<em>number</em>) – Fraction of values that are supposed to be turned to positive
values.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">RandomSign</span><span class="p">(</span><span class="n">Poisson</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Generates a poisson distribution with alpha=1 that is mirrored at the
y-axis.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Sigmoid">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Sigmoid</code><span class="sig-paren">(</span><em>other_param</em>, <em>threshold=(-10</em>, <em>10)</em>, <em>activated=True</em>, <em>mul=1</em>, <em>add=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Sigmoid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Sigmoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Applies a sigmoid function to the outputs of another parameter.</p>
<p>This is intended to be used in combination with SimplexNoise or
FrequencyNoise. It pushes the noise values away from ~0.5 and towards
0.0 or 1.0, making the noise maps more binary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – The other parameter to which the sigmoid will be
applied.</li>
<li><strong>threshold</strong> (<em>number or tuple of two numbers or iterable of numbers or StochasticParameter, optional(default=(-10, 10))</em>) – Sets the value of the sigmoid’s saddle point, i.e. where values
start to quickly shift from 0.0 to 1.0.
This may be set using a single number, a tuple (a, b) (will result in
a random threshold a&lt;=x&lt;b per call), a list of numbers (will
result in a random threshold drawn from the list per call) or a
StochasticParameter (will be queried once per call to determine the
threshold).</li>
<li><strong>activated</strong> (<em>bool or number, optional(default=True)</em>) – Defines whether the sigmoid is activated. If this is False, the
results of other_param will not be altered. This may be set to a
float value p with 0&lt;=p&lt;=1.0, which will result in <cite>activated</cite> being
True in p percent of all calls.</li>
<li><strong>mul</strong> (<em>number, optional(default=1)</em>) – The results of other_param will be multiplied with this value before
applying the sigmoid. For noise values (range [0.0, 1.0]) this should
be set to about 20.</li>
<li><strong>add</strong> (<em>number, optional(default=0)</em>) – This value will be added to the results of other_param before applying
the sigmoid. For noise values (range [0.0, 1.0]) this should be set
to about -10.0, provided <cite>mul</cite> was set to 20.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Sigmoid</span><span class="p">(</span><span class="n">SimplexNoise</span><span class="p">(),</span> <span class="n">activated</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mul</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">add</span><span class="o">=-</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Applies a sigmoid to simplex noise in 50 percent of all calls. The noise
results are modified to match the sigmoid’s expected value range. The
sigmoid’s outputs are in the range [0.0, 1.0].</p>
<p class="rubric">Methods</p>
<dl class="staticmethod">
<dt id="imgaug.parameters.Sigmoid.create_for_noise">
<em class="property">static </em><code class="descname">create_for_noise</code><span class="sig-paren">(</span><em>other_param</em>, <em>threshold=(-10</em>, <em>10)</em>, <em>activated=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Sigmoid.create_for_noise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Sigmoid.create_for_noise" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a Sigmoid that is adjusted to be used with noise parameters,
i.e. with parameters which’s output values are in the range [0.0, 1.0].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>other_param</strong> (<em>StochasticParameter</em>) – See <cite>Sigmoid</cite>.</li>
<li><strong>threshold</strong> (<em>number or tuple of two numbers or iterable of numbers or StochasticParameter, optional(default=(-10, 10))</em>) – See <cite>Sigmoid</cite>.</li>
<li><strong>activated</strong> (<em>bool or number, optional(default=True)</em>) – See <cite>Sigmoid</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – A sigmoid adjusted to be used with noise.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.parameters.Sigmoid" title="imgaug.parameters.Sigmoid">Sigmoid</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.SimplexNoise">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">SimplexNoise</code><span class="sig-paren">(</span><em>size_px_max=(2, 16), upscale_method=['linear', 'nearest']</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#SimplexNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.SimplexNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>A parameter that generates simplex noise of varying resolutions.</p>
<p>This parameter expects to sample noise for 2d planes, i.e. for
sizes (H, W) and will return a value in the range [0.0, 1.0] per location
in that plane.</p>
<p>The noise is sampled from low resolution planes and
upscaled to the requested height and width. The size of the low
resolution plane may be defined (high values can be slow) and the
interpolation method for upscaling can be set.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>size_px_max</strong> (<em>int or tuple of two int or list of int or StochasticParameter, optional(default=(2, 16))</em>) – Size in pixels of the low resolution plane.
A single int will be used as a constant value. A tuple of two
ints (a, b) will result in random values sampled from [a..b].
A list of ints will result in random values being sampled from that
list. A StochasticParameter will be queried once per call
to <cite>_draw_samples()</cite>.</li>
<li><strong>upscale_method</strong> (<em>string or int or StochasticParameter, optional(default=”nearest”)</em>) – Upsampling/interpolation method to use. This is used after the sampling
is finished and the low resolution plane has to be upsampled to the
requested <cite>size</cite> in <cite>_draw_samples(size, …)</cite>. The method may be
the same as in <cite>imgaug.imresize_many_images()</cite>. Usually <cite>nearest</cite>
or <cite>linear</cite> are good choices. <cite>nearest</cite> will result in rectangles
with sharp edges and <cite>linear</cite> in rectangles with blurry and round
edges. The method may be provided as a StochasticParameter, which
will be queried per call to <cite>_draw_samples()</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">SimplexNoise</span><span class="p">(</span><span class="n">upscale_method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Results in smooth simplex noise of varying sizes.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">SimplexNoise</span><span class="p">(</span><span class="n">size_px_max</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">upscale_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Results in rectangular simplex noise of rather high detail.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.StochasticParameter">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">StochasticParameter</code><a class="reference internal" href="../_modules/imgaug/parameters.html#StochasticParameter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.StochasticParameter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Abstract parent class for all stochastic parameters.</p>
<p>Stochastic parameters are here all parameters from which values are
supposed to be sampled. Usually the sampled values are to a degree random.
E.g. a stochastic parameter may be the range [-10, 10], with sampled
values being 5.2, -3.7, -9.7 and 6.4.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.parameters.StochasticParameter.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#StochasticParameter.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.StochasticParameter.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a shallow copy of this parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Shallow copy.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter">StochasticParameter</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.parameters.StochasticParameter.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#StochasticParameter.deepcopy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.StochasticParameter.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a deep copy of this parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – Deep copy.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter">StochasticParameter</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.parameters.StochasticParameter.draw_distribution_graph">
<code class="descname">draw_distribution_graph</code><span class="sig-paren">(</span><em>title=None</em>, <em>size=(1000</em>, <em>1000)</em>, <em>bins=100</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#StochasticParameter.draw_distribution_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.StochasticParameter.draw_distribution_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a plot (image) that shows the parameter’s distribution of
values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>title</strong> (<em>None or False or string, optional(default=None)</em>) – Title of the plot. None is automatically replaced by a title
derived from <cite>str(param)</cite>. If set to False, no title will be
shown.</li>
<li><strong>size</strong> (<em>tuple of int</em>) – Number of points to sample. This is always expected to have at
least two values. The first defines the number of sampling runs,
the second (and further) dimensions define the size assigned
to each <cite>draw_samples()</cite> call. E.g. <cite>(10, 20, 15)</cite> will lead
to <cite>10</cite> calls of <cite>draw_samples(size=(20, 15))</cite>. The results
will be merged to a single 1d array.</li>
<li><strong>bins</strong> (<em>int</em>) – Number of bins in the plot histograms.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>data</strong> – Image of the plot.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(H,W,3) ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.parameters.StochasticParameter.draw_sample">
<code class="descname">draw_sample</code><span class="sig-paren">(</span><em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#StochasticParameter.draw_sample"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.StochasticParameter.draw_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a single sample value from this parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>random_state</strong> (<em>None or np.random.RandomState, optional(default=None)</em>) – A random state to use during the sampling process.
If None, the libraries global random state will be used.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>out</strong> – A single sample value.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">anything</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.parameters.StochasticParameter.draw_samples">
<code class="descname">draw_samples</code><span class="sig-paren">(</span><em>size</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#StochasticParameter.draw_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.StochasticParameter.draw_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws one or more sample values from the parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>size</strong> (<em>tuple of int</em>) – Number of sample values by
dimension.</li>
<li><strong>random_state</strong> (<em>None or np.random.RandomState, optional(default=None)</em>) – A random state to use during the sampling process.
If None, the libraries global random state will be used.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> – Sampled values. Usually a numpy ndarray of basically any dtype,
though not strictly limited to numpy arrays.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(<a class="reference internal" href="#module-imgaug.augmenters.size" title="imgaug.augmenters.size">size</a>) iterable</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Subtract">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Subtract</code><span class="sig-paren">(</span><em>other_param</em>, <em>val</em>, <em>elementwise=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Subtract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter to subtract from another parameter’s results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>other_param</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Other parameter which’s sampled values are to be
modified.</li>
<li><strong>val</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Value to add to the other parameter’s results. If this is a
StochasticParameter, either a single or multiple values will be
sampled and subtracted.</li>
<li><strong>elementwise</strong> (<em>bool, optional(default=False)</em>) – Controls the sampling behaviour when <cite>val</cite> is a StochasticParameter.
If set to False, a single value will be sampled from val and subtracted
from all values generated by <cite>other_param</cite>.
If set to True and <cite>_draw_samples(size=S)</cite> is called, <cite>S</cite> values will
be sampled from <cite>val</cite> and subtracted from the results of <cite>other_param</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="n">Uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Converts a uniform range [0.0, 1.0) to [1.0, 2.0).</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Uniform">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Uniform</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Uniform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Uniform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a (continuous) uniform range [a, b).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>{a, b}</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Lower and upper bound of the sampling range. Values will be sampled
from a &lt;= x &lt; b. All sampled values will be continuous. If a or b is
a StochasticParameter, it will be queried once per sampling to
estimate the value of a/b. If a&gt;b, the values will automatically be
flipped. If a==b, all generated values will be identical to a.</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)</span>
</pre></div>
</div>
<p>Samples random values from the range [0, 10.0).</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.parameters.Weibull">
<em class="property">class </em><code class="descclassname">imgaug.parameters.</code><code class="descname">Weibull</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#Weibull"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.Weibull" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.parameters.StochasticParameter" title="imgaug.parameters.StochasticParameter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.parameters.StochasticParameter</span></code></a></p>
<p>Parameter that resembles a (continuous) weibull distribution.</p>
<p>This is a wrapper around numpy’s random.weibull().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – Shape parameter of the
distribution.</p>
<blockquote class="last">
<div><ul class="simple">
<li>If a single number, this number will be used as a constant value.</li>
<li>If a tuple of two numbers (a, b), the value will be sampled
once per call to <cite>_draw_samples()</cite> from the continuous
range [a, b).</li>
<li>If a list of numbers, a random value will be picked from the
list per call to <cite>_draw_samples()</cite>.</li>
<li>If a StochasticParameter, that parameter will be queried once
per call to <cite>_draw_samples()</cite>.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">param</span> <span class="o">=</span> <span class="n">Weibull</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>A weibull distribution with shape 0.5.</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.parameters.both_np_float_if_one_is_float">
<code class="descclassname">imgaug.parameters.</code><code class="descname">both_np_float_if_one_is_float</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#both_np_float_if_one_is_float"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.both_np_float_if_one_is_float" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.parameters.draw_distributions_grid">
<code class="descclassname">imgaug.parameters.</code><code class="descname">draw_distributions_grid</code><span class="sig-paren">(</span><em>params</em>, <em>rows=None</em>, <em>cols=None</em>, <em>graph_sizes=(350</em>, <em>350)</em>, <em>sample_sizes=None</em>, <em>titles=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#draw_distributions_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.draw_distributions_grid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.parameters.force_np_float_dtype">
<code class="descclassname">imgaug.parameters.</code><code class="descname">force_np_float_dtype</code><span class="sig-paren">(</span><em>val</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#force_np_float_dtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.force_np_float_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.parameters.handle_continuous_param">
<code class="descclassname">imgaug.parameters.</code><code class="descname">handle_continuous_param</code><span class="sig-paren">(</span><em>param</em>, <em>name</em>, <em>value_range=None</em>, <em>tuple_to_uniform=True</em>, <em>list_to_choice=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#handle_continuous_param"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.handle_continuous_param" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.parameters.handle_discrete_param">
<code class="descclassname">imgaug.parameters.</code><code class="descname">handle_discrete_param</code><span class="sig-paren">(</span><em>param</em>, <em>name</em>, <em>value_range=None</em>, <em>tuple_to_uniform=True</em>, <em>list_to_choice=True</em>, <em>allow_floats=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#handle_discrete_param"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.handle_discrete_param" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.parameters.handle_probability_param">
<code class="descclassname">imgaug.parameters.</code><code class="descname">handle_probability_param</code><span class="sig-paren">(</span><em>param</em>, <em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#handle_probability_param"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.handle_probability_param" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.parameters.show_distributions_grid">
<code class="descclassname">imgaug.parameters.</code><code class="descname">show_distributions_grid</code><span class="sig-paren">(</span><em>params</em>, <em>rows=None</em>, <em>cols=None</em>, <em>graph_sizes=(350</em>, <em>350)</em>, <em>sample_sizes=None</em>, <em>titles=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/parameters.html#show_distributions_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.parameters.show_distributions_grid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.meta">
<span id="augmenters-meta"></span><h2>augmenters.meta<a class="headerlink" href="#module-imgaug.augmenters.meta" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that don’t apply augmentations themselves, but are needed
for meta usage.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<dl class="docutils">
<dt>and then e.g.</dt>
<dd><cite>seq = iaa.Sequential([…])</cite></dd>
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>Augmenter (base class for all augmenters)</li>
<li>Sequential</li>
<li>SomeOf</li>
<li>OneOf</li>
<li>Sometimes</li>
<li>WithChannels</li>
<li>Noop</li>
<li>Lambda</li>
<li>AssertLambda</li>
<li>AssertShape</li>
</ul>
</dd>
</dl>
<p>Note that WithColorspace is in <cite>color.py</cite>.</p>
<dl class="function">
<dt id="imgaug.augmenters.meta.AssertLambda">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">AssertLambda</code><span class="sig-paren">(</span><em>func_images</em>, <em>func_keypoints</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#AssertLambda"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.AssertLambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that runs an assert on each batch of input images
using a lambda function as condition.</p>
<p>This is useful to make generic assumption about the input images and error
out early if they aren’t met.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>func_images</strong> (<em>callable,</em>) – The function to call for each batch of images.
It must follow the form</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">function(images,</span> <span class="pre">random_state,</span> <span class="pre">parents,</span> <span class="pre">hooks)</span></code></p>
</div></blockquote>
<p>and return either True (valid input) or False (invalid input).
It essentially reuses the interface of Augmenter._augment_images().</p>
</li>
<li><p class="first"><strong>func_keypoints</strong> (<em>callable,</em>) – The function to call for each batch of keypoints.
It must follow the form</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">function(keypoints_on_images,</span> <span class="pre">random_state,</span> <span class="pre">parents,</span> <span class="pre">hooks)</span></code></p>
</div></blockquote>
<p>and return either True (valid input) or False (invalid input).
It essentially reuses the interface of Augmenter._augment_keypoints().</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.AssertShape">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">AssertShape</code><span class="sig-paren">(</span><em>shape</em>, <em>check_images=True</em>, <em>check_keypoints=True</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#AssertShape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.AssertShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter to make assumptions about the shape of input image(s)
and keypoints.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>shape</strong> (<em>tuple with each entry being None or tuple of two ints or list of ints</em>) – The expected shape. Given as a tuple. The number of entries in the tuple
must match the number of dimensions, i.e. usually four entries for
(N, H, W, C).</p>
<blockquote>
<div><ul class="simple">
<li>If an entry is None, any value for that dimensions is accepted.</li>
<li>If an entry is int, exactly that integer value will be accepted
or no other value.</li>
<li>If an entry is a tuple of two ints with values a and b, only a
value x with a &lt;= x &lt; b will be accepted for the dimension.</li>
<li>If an entry is a list of ints, only a value for the dimension
will be accepted which is contained in the list.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>check_images</strong> (<em>bool, optional(default=True)</em>) – Whether to validate input images via the given shape.</p>
</li>
<li><p class="first"><strong>check_keypoints</strong> (<em>bool, optional(default=True)</em>) – Whether to validate input keypoints via the given shape.
The number of keypoints will be checked and for each KeypointsOnImage
instance its image’s shape, i.e. KeypointsOnImage.shape.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">AssertShape</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
</pre></div>
</div>
<p>will first check for each image batch, if it contains a variable number of
32x32 images with 3 channels each. Only if that check succeeds, the
horizontal flip will be executed (otherwise an assertion error will be
thrown).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">AssertShape</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span> <span class="mi">32</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
</pre></div>
</div>
<p>like above, but now the height may be in the range 32 &lt;= H &lt; 64 and
the number of channels may be either 1 or 3.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.meta.Augmenter">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">Augmenter</code><span class="sig-paren">(</span><em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Base class for Augmenter objects.
All augmenters derive from this class.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.augment_batches">
<code class="descname">augment_batches</code><span class="sig-paren">(</span><em>batches</em>, <em>hooks=None</em>, <em>background=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.augment_batches"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.augment_batches" title="Permalink to this definition">¶</a></dt>
<dd><p>Augment multiple batches of images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first">
<li><p class="first"><strong>batches</strong> (<em>list</em>) – List of image batches to augment.
The expected input is a list, with each entry having one of the
following datatypes:</p>
<blockquote>
<div><ul class="simple">
<li>ia.Batch</li>
<li>[]</li>
<li>list of ia.KeypointsOnImage</li>
<li>list of (H,W,C) ndarray</li>
<li>list of (H,W) ndarray</li>
<li>(N,H,W,C) ndarray</li>
<li>(N,H,W) ndarray</li>
</ul>
</div></blockquote>
<p>where N = number of images, H = height, W = width,
C = number of channels.
Each image is recommended to have dtype uint8 (range 0-255).</p>
</li>
<li><p class="first"><strong>hooks</strong> (<em>None or ia.HooksImages, optional(default=None)</em>) – HooksImages object to dynamically interfere with the augmentation
process.</p>
</li>
<li><p class="first"><strong>background</strong> (<em>bool, optional(default=False)</em>) – Whether to augment the batches in background processes.
If true, hooks can currently not be used as that would require
pickling functions.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first last"><strong>augmented_batch</strong> (<em>ia.Batch or list of ia.KeypointsOnImage or list of (H,W,C) ndarray or list of (H,W) ndarray or (N,H,W,C) ndarray or (N,H,W) ndarray</em>) – Augmented images/keypoints.
Datatype usually matches the input datatypes per list element.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.augment_bounding_boxes">
<code class="descname">augment_bounding_boxes</code><span class="sig-paren">(</span><em>bounding_boxes_on_images</em>, <em>hooks=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.augment_bounding_boxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.augment_bounding_boxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Augment image bounding boxes.</p>
<p>This is the corresponding function to <cite>augment_keypoints()</cite>, just for
bounding boxes.
Usually you will want to call <cite>augment_images()</cite> with a list of images,
e.g. <cite>augment_images([A, B, C])</cite> and then <cite>augment_bounding_boxes()</cite>
with the corresponding list of bounding boxes on these images, e.g.
<cite>augment_bounding_boxes([Abb, Bbb, Cbb])</cite>, where <cite>Abb</cite> are the
bounding boxes on image <cite>A</cite>.</p>
<p>Make sure to first convert the augmenter(s) to deterministic states
before augmenting images and their corresponding bounding boxes,
e.g. by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq_det</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq_det</span><span class="o">.</span><span class="n">augment_images</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bbs_aug</span> <span class="o">=</span> <span class="n">seq_det</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">([</span><span class="n">Abb</span><span class="p">,</span> <span class="n">Bbb</span><span class="p">,</span> <span class="n">Cbb</span><span class="p">])</span>
</pre></div>
</div>
<p>Otherwise, different random values will be sampled for the image
and bounding box augmentations, resulting in different augmentations
(e.g. images might be rotated by <cite>30deg</cite> and bounding boxes by
<cite>-10deg</cite>). Also make sure to call <cite>to_deterministic()</cite> again for each
new batch, otherwise you would augment all batches in the same way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>bounding_boxes_on_images</strong> (<em>list of ia.BoundingBoxesOnImage</em>) – The bounding boxes to augment.
Expected is a list of ia.BoundingBoxesOnImage objects,
each containing the bounding boxes of a single image.</li>
<li><strong>hooks</strong> (<em>None or ia.HooksKeypoints, optional(default=None)</em>) – HooksKeypoints object to dynamically interfere with the
augmentation process.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> – Augmented bounding boxes.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of ia.BoundingBoxesOnImage</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.augment_image">
<code class="descname">augment_image</code><span class="sig-paren">(</span><em>image</em>, <em>hooks=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.augment_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.augment_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Augment a single image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>image</strong> (<em>(H,W,C) ndarray or (H,W) ndarray</em>) – The image to augment. Should have dtype uint8 (range 0-255).</li>
<li><strong>hooks</strong> (<em>None or ia.HooksImages, optional(default=None)</em>) – HooksImages object to dynamically interfere with the augmentation
process.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>img</strong> – The corresponding augmented image.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.augment_images">
<code class="descname">augment_images</code><span class="sig-paren">(</span><em>images</em>, <em>parents=None</em>, <em>hooks=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.augment_images"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.augment_images" title="Permalink to this definition">¶</a></dt>
<dd><p>Augment multiple images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>images</strong> (<em>(N,H,W,C) ndarray or (N,H,W) ndarray or list of (H,W,C) ndarray or list of (H,W) ndarray</em>) – Images to augment. The input can be a list of numpy arrays or
a single array. Each array is expected to have shape (H, W, C)
or (H, W), where H is the height, W is the width and C are the
channels. Number of channels may differ between images.
If a list is chosen, height and width may differ per between images.
Currently the recommended dtype is uint8 (i.e. integer values in
the range 0 to 255). Other dtypes are not tested.</li>
<li><strong>parents</strong> (<em>None or list of Augmenter, optional(default=None)</em>) – Parent augmenters that have previously been called before the
call to this function. Usually you can leave this parameter as None.
It is set automatically for child augmenters.</li>
<li><strong>hooks</strong> (<em>None or ia.HooksImages, optional(default=None)</em>) – HooksImages object to dynamically interfere with the augmentation
process.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>images_result</strong> – Corresponding augmented images.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray or list</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.augment_keypoints">
<code class="descname">augment_keypoints</code><span class="sig-paren">(</span><em>keypoints_on_images</em>, <em>parents=None</em>, <em>hooks=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.augment_keypoints"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.augment_keypoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Augment image keypoints.</p>
<p>This is the corresponding function to <cite>augment_images()</cite>, just for
keypoints/landmarks (i.e. coordinates on the image).
Usually you will want to call <cite>augment_images()</cite> with a list of images,
e.g. <cite>augment_images([A, B, C])</cite> and then <cite>augment_keypoints()</cite> with the
corresponding list of keypoints on these images, e.g.
<cite>augment_keypoints([Ak, Bk, Ck])</cite>, where <cite>Ak</cite> are the keypoints on
image <cite>A</cite>.</p>
<p>Make sure to first convert the augmenter(s) to deterministic states
before augmenting images and their corresponding keypoints,
e.g. by</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq_det</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq_det</span><span class="o">.</span><span class="n">augment_images</span><span class="p">([</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kps_aug</span> <span class="o">=</span> <span class="n">seq_det</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">([</span><span class="n">Ak</span><span class="p">,</span> <span class="n">Bk</span><span class="p">,</span> <span class="n">Ck</span><span class="p">])</span>
</pre></div>
</div>
<p>Otherwise, different random values will be sampled for the image
and keypoint augmentations, resulting in different augmentations (e.g.
images might be rotated by <cite>30deg</cite> and keypoints by <cite>-10deg</cite>).
Also make sure to call <cite>to_deterministic()</cite> again for each new batch,
otherwise you would augment all batches in the same way.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>keypoints_on_images</strong> (<em>list of ia.KeypointsOnImage</em>) – The keypoints/landmarks to augment.
Expected is a list of ia.KeypointsOnImage objects,
each containing the keypoints of a single image.</li>
<li><strong>parents</strong> (<em>None or list of Augmenter, optional(default=None)</em>) – Parent augmenters that have previously been called before the
call to this function. Usually you can leave this parameter as None.
It is set automatically for child augmenters.</li>
<li><strong>hooks</strong> (<em>None or ia.HooksKeypoints, optional(default=None)</em>) – HooksKeypoints object to dynamically interfere with the
augmentation process.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>keypoints_on_images_result</strong> – Augmented keypoints.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of ia.KeypointsOnImage</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a shallow copy of this Augmenter instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>aug</strong> – Shallow copy of this Augmenter instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter">Augmenter</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.copy_random_state">
<code class="descname">copy_random_state</code><span class="sig-paren">(</span><em>source</em>, <em>recursive=True</em>, <em>matching='position'</em>, <em>matching_tolerant=True</em>, <em>copy_determinism=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.copy_random_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.copy_random_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the random states from a source augmenter sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source</strong> (<em>Augmenter</em>) – See <cite>Augmenter.copy_random_state_()</cite>.</li>
<li><strong>recursive</strong> (<em>bool, optional(default=True)</em>) – See <cite>Augmenter.copy_random_state_()</cite>.</li>
<li><strong>matching</strong> (<em>{‘position’, ‘name’}, optional(default=’position’)</em>) – See <cite>Augmenter.copy_random_state_()</cite>.</li>
<li><strong>matching_tolerant</strong> (<em>bool, optional(default=True)</em>) – See <cite>Augmenter.copy_random_state_()</cite>.</li>
<li><strong>copy_determinism</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.copy_random_state_()</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aug</strong> – Copy of the augmenter(s) with the same random state(s) as in the
source augmenter(s).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter">Augmenter</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.copy_random_state_">
<code class="descname">copy_random_state_</code><span class="sig-paren">(</span><em>source</em>, <em>recursive=True</em>, <em>matching='position'</em>, <em>matching_tolerant=True</em>, <em>copy_determinism=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.copy_random_state_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.copy_random_state_" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the random states from a source augmenter sequence (inplace).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source</strong> (<em>Augmenter</em>) – The source augmenter from where to copy the random_state(s).
May have children (e.g. a Sequential).
May not use the global random state. This is used by default
by all augmenters. Call <cite>localize_random_state_()</cite> once on the
source to localize all random states.</li>
<li><strong>recursive</strong> (<em>bool, optional(default=True)</em>) – Whether to copy the random states of the source augmenter <em>and</em>
all of its children (True) or just the source augmenter (False).</li>
<li><strong>matching</strong> (<em>{‘position’, ‘name’}, optional(default=’position’)</em>) – Defines the matching mode to use during recursive copy.
This is used to associate source augmenters with target augmenters.
If ‘position’ then the target and source sequences of augmenters
are turned into flattened lists and are associated based on
their list indices. If ‘name’ then the target and source augmenters
are matched based on their names (i.e. <cite>augmenter.name</cite>).</li>
<li><strong>matching_tolerant</strong> (<em>bool, optional(default=True)</em>) – Whether to use tolerant matching between source and target
augmenters. If set to False: Name matching will raise an exception
for any target augmenter which’s name does not appear among the
source augmeters. Position matching will raise an exception if
source and target augmenter have an unequal number of children.</li>
<li><strong>copy_determinism</strong> (<em>bool, optional(default=False)</em>) – Whether to copy the <cite>deterministic</cite> flags from source to target
augmenters too.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong> – Returns itself (after random state copy).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter">Augmenter</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.deepcopy">
<code class="descname">deepcopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.deepcopy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.deepcopy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a deep copy of this Augmenter instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>aug</strong> – Deep copy of this Augmenter instance.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter">Augmenter</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.draw_grid">
<code class="descname">draw_grid</code><span class="sig-paren">(</span><em>images</em>, <em>rows</em>, <em>cols</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.draw_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.draw_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this augmenter to the given images and return a grid
image of the results.
Each cell in the grid contains a single augmented variation of
an input image.</p>
<p>If multiple images are provided, the row count is multiplied by
the number of images and each image gets its own row.
E.g. for <cite>images = [A, B]</cite>, <cite>rows=2</cite>, <cite>cols=3</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">A</span> <span class="n">A</span>
<span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">A</span> <span class="n">A</span> <span class="n">A</span>
<span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
</pre></div>
</div>
<p>for <cite>images = [A]</cite>, <cite>rows=2</cite>,
<cite>cols=3</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">A</span> <span class="n">A</span>
<span class="n">A</span> <span class="n">A</span> <span class="n">A</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>images</strong> (<em>(N,H,W,3) ndarray or (H,W,3) ndarray or (H,W) ndarray or list of (H,W,3) ndarray or list of (H,W) ndarray</em>) – List of images of which to show the augmented versions.
If a list, then each element is expected to have shape (H, W) or
(H, W, 3). If a single array, then it is expected to have
shape (N, H, W, 3) or (H, W, 3) or (H, W).</li>
<li><strong>rows</strong> (<em>int</em>) – Number of rows in the grid.
If N input images are given, this value will automatically be
multiplied by N to create rows for each image.</li>
<li><strong>cols</strong> (<em>int</em>) – Number of columns in the grid.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>grid</strong> – The generated grid image with augmented versions of the input
images. Here, Hg and Wg reference the output size of the grid,
and <em>not</em> the sizes of the input images.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">(Hg,Wg,3) ndarray</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.find_augmenters">
<code class="descname">find_augmenters</code><span class="sig-paren">(</span><em>func</em>, <em>parents=None</em>, <em>flat=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.find_augmenters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.find_augmenters" title="Permalink to this definition">¶</a></dt>
<dd><p>Find augmenters that match a condition.
This function will compare this augmenter and all of its children
with a condition. The condition is a lambda function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func</strong> (<em>callable</em>) – A function that receives an Augmenter instance and a list of
parent Augmenter instances and must return True, if that
augmenter is valid match.</li>
<li><strong>parents</strong> (<em>None or list of Augmenter, optional</em>) – List of parent augmenters.
Intended for nested calls and can usually be left as None.</li>
<li><strong>flat</strong> (<em>bool, optional</em>) – Whether to return the result as a flat list (True)
or a nested list (False). In the latter case, the nesting matches
each augmenters position among the children.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>augmenters</strong> – Nested list if flat was set to False.
Flat list if flat was set to True.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of Augmenter</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">nn</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;fliplr&quot;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">nn</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;flipud&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">aug</span><span class="o">.</span><span class="n">find_augmenters</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">parents</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;fliplr&quot;</span><span class="p">))</span>
</pre></div>
</div>
<p>This will return the first child augmenter (Fliplr instance).</p>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.find_augmenters_by_name">
<code class="descname">find_augmenters_by_name</code><span class="sig-paren">(</span><em>name</em>, <em>regex=False</em>, <em>flat=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.find_augmenters_by_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.find_augmenters_by_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Find augmenter(s) by name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>name</strong> (<em>string</em>) – Name of the augmenter(s) to search for.</li>
<li><strong>regex</strong> (<em>bool, optional</em>) – Whether <cite>name</cite> parameter is a regular expression.</li>
<li><strong>flat</strong> (<em>bool, optional</em>) – See <cite>Augmenter.find_augmenters()</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>augmenters</strong> – Nested list if flat was set to False.
Flat list if flat was set to True.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of Augmenter objects</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.find_augmenters_by_names">
<code class="descname">find_augmenters_by_names</code><span class="sig-paren">(</span><em>names</em>, <em>regex=False</em>, <em>flat=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.find_augmenters_by_names"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.find_augmenters_by_names" title="Permalink to this definition">¶</a></dt>
<dd><p>Find augmenter(s) by names.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>names</strong> (<em>list of string</em>) – Names of the augmenter(s) to search for.</li>
<li><strong>regex</strong> (<em>bool, optional</em>) – Whether <cite>names</cite> is a list of regular expressions.</li>
<li><strong>flat</strong> (<em>boolean, optional</em>) – See <cite>Augmenter.find_augmenters()</cite>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>augmenters</strong> – Nested list if flat was set to False.
Flat list if flat was set to True.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of Augmenter</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.get_all_children">
<code class="descname">get_all_children</code><span class="sig-paren">(</span><em>flat=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.get_all_children"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.get_all_children" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all children of this augmenter as a list.</p>
<p>If the augmenter has no children, the returned list is empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>flat</strong> (<em>bool</em>) – If set to True, the returned list will be
flat.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>result</strong> – The children as a nested or flat list.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">list of Augmenter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.get_children_lists">
<code class="descname">get_children_lists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.get_children_lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.get_children_lists" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a list of lists of children of this augmenter.</p>
<p>For most augmenters, the result will be a single empty list.
For augmenters with children it will often be a list with one sublist containing all
children. In some cases the augmenter will contain multiple distinct lists of children,
e.g. an if-list and an else-list. This will lead to a result consisting of a single
list with multiple sublists, each representing the respective sublist of children.</p>
<p>E.g. for an if/else-augmenter that executes the children A1, A2 if a condition is met
and otherwise executes the children B1, B2, B3 the result will be [[A1, A2], [B1, B2, B3]].</p>
<p>IMPORTANT: While the topmost list may be newly created, each of the sublist must be
editable inplace resulting in a changed children list of the augmenter. E.g. if
an Augmenter IfElse(condition, [A1, A2], [B1, B2, B3]) returns [[A1, A2], [B1, B2, B3]]
for a call to get_children_lists() and A2 is removed inplace from [A1, A2], then the
children lists of IfElse(…) must also change to [A1], [B1, B2, B3]. This is used
if remove_augmenters_inplace().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>children</strong> – May be a single empty list.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">A list of lists of children (i.e. Augmenter instances)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.localize_random_state">
<code class="descname">localize_random_state</code><span class="sig-paren">(</span><em>recursive=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.localize_random_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.localize_random_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts global random states to local ones.
See <cite>Augmenter.localize_random_state_()</cite> for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recursive</strong> (<em>bool, optional(default=True)</em>) – See <cite>Augmenter.localize_random_state_()</cite>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>aug</strong> – Returns copy of augmenter and children, with localized random
states.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter">Augmenter</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.localize_random_state_">
<code class="descname">localize_random_state_</code><span class="sig-paren">(</span><em>recursive=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.localize_random_state_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.localize_random_state_" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts global random states to local ones.</p>
<p>A global random state exists exactly once. Many augmenters can point
to it (and thereby use it to sample random numbers).
Local random usually exists for exactly one augmenter and are
saved within that augmenter.</p>
<p>Usually there is no need to change global into local random states.
The only noteworthy exceptions are</p>
<blockquote>
<div><ul class="simple">
<li>whenever you want to use determinism (so that the global random
state is not accidentally reverted)</li>
<li>whenever you want to copy random states from one augmenter to
another. (Copying the global random state doesn’t help very
much. If you copy the state from A to B, then execute A and then
B, B’s (global) random state has already changed because of A’s
sampling.)</li>
</ul>
</div></blockquote>
<p>The case of determinism is handled automatically by to_deterministic().
Only when you copy random states (via copy_random_state()), you need
to call this function first.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>recursive</strong> (<em>bool, optional(default=True)</em>) – Whether to localize the random states of children
too.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>self</strong> – Returns itself (with localized random states).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter">Augmenter</a></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.remove_augmenters">
<code class="descname">remove_augmenters</code><span class="sig-paren">(</span><em>func</em>, <em>copy=True</em>, <em>noop_if_topmost=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.remove_augmenters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.remove_augmenters" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove this augmenter or its children that match a condition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>func</strong> (<em>callable</em>) – Condition to match per augmenter.
The function must expect the augmenter itself and a list of parent
augmenters and returns True if that augmenter is to be removed,
or False otherwise.
E.g. <cite>lambda a, parents: a.name == “fliplr” and len(parents) == 1</cite>
removes an augmenter with name “fliplr” if it is the direct child
of the augmenter upon which <cite>remove_augmenters()</cite> was initially called.</li>
<li><strong>copy</strong> (<em>bool, optional</em>) – Whether to copy this augmenter and all if its children before
removing. If False, removal is performed in-place.</li>
<li><strong>noop_if_topmost</strong> (<em>bool, optional</em>) – If True and the condition (lambda function) leads to the removal
of the topmost augmenter (the one this function is called on
initially), then that topmost augmenter will be replaced by a
Noop instance (i.e. an object will still knows <cite>augment_images()</cite>,
but doesnt change images). If False, None will be returned in
these cases.
This can only be False if copy is set to True.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>aug</strong> – This augmenter after the removal was performed.
Is None iff condition was matched for the topmost augmenter,
copy was set to True and <cite>noop_if_topmost</cite> was set to False.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter">Augmenter</a> or None</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;fliplr&quot;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;flipud&quot;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">remove_augmenters</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">parents</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;fliplr&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This removes the augmenter Fliplr from the Sequential object’s children.</p>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.remove_augmenters_inplace">
<code class="descname">remove_augmenters_inplace</code><span class="sig-paren">(</span><em>func</em>, <em>parents=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.remove_augmenters_inplace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.remove_augmenters_inplace" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove in-place children of this augmenter that match a condition.</p>
<p>This is functionally identical to <cite>remove_augmenters()</cite> with
<cite>copy=False</cite>, except that it does not affect the topmost augmenter
(the one on which this function is initially called on).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>func</strong> (<em>callable</em>) – See <cite>Augmenter.remove_augmenters()</cite>.</li>
<li><strong>parents</strong> (<em>None or list of Augmenter, optional</em>) – List of parent Augmenter instances that lead to this
Augmenter. If None, an empty list will be used.
This parameter can usually be left empty and will be set
automatically for children.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;fliplr&quot;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>   <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;flipud&quot;</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span><span class="o">.</span><span class="n">remove_augmenters_inplace</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">parents</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;fliplr&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This removes the augmenter Fliplr from the Sequential object’s children.</p>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.reseed">
<code class="descname">reseed</code><span class="sig-paren">(</span><em>random_state=None</em>, <em>deterministic_too=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.reseed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.reseed" title="Permalink to this definition">¶</a></dt>
<dd><p>Reseed this augmenter and all of its children (if it has any).</p>
<p>This function is useful, when augmentations are run in the
background (i.e. on multiple cores).
It should be called before sending this Augmenter object to a
background worker (i.e., if N workers are used, the function
should be called N times). Otherwise, all background workers will
use the same seeds and therefore apply the same augmentations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>random_state</strong> (<em>None or int or np.random.RandomState, optional</em>) – A RandomState that is used to sample seeds per augmenter.
If int, the parameter will be used as a seed for a new RandomState.
If None, a new RandomState will automatically be created.</li>
<li><strong>deterministic_too</strong> (<em>bool, optional</em>) – Whether to also change the seed of an augmenter <cite>A</cite>, if <cite>A</cite>
is deterministic. This is the case both when this augmenter
object is <cite>A</cite> or one of its children is <cite>A</cite>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.show_grid">
<code class="descname">show_grid</code><span class="sig-paren">(</span><em>images</em>, <em>rows</em>, <em>cols</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.show_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.show_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply this augmenter to the given images and show/plot the results as
a grid of images.</p>
<p>If multiple images are provided, the row count is multiplied by
the number of images and each image gets its own row.
E.g. for <cite>images = [A, B]</cite>, <cite>rows=2</cite>, <cite>cols=3</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">A</span> <span class="n">A</span>
<span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
<span class="n">A</span> <span class="n">A</span> <span class="n">A</span>
<span class="n">B</span> <span class="n">B</span> <span class="n">B</span>
</pre></div>
</div>
<p>for <cite>images = [A]</cite>, <cite>rows=2</cite>,
<cite>cols=3</cite>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">A</span> <span class="n">A</span>
<span class="n">A</span> <span class="n">A</span> <span class="n">A</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>images</strong> (<em>(N,H,W,3) ndarray or (H,W,3) ndarray or (H,W) ndarray or list of (H,W,3) ndarray or list of (H,W) ndarray</em>) – List of images of which to show the augmented versions.
If a list, then each element is expected to have shape (H, W)
or (H, W, 3).
If a single array, then it is expected to have shape (N, H, W, 3)
or (H, W, 3) or (H, W).</li>
<li><strong>rows</strong> (<em>int</em>) – Number of rows in the grid.
If N input images are given, this value will automatically be
multiplied by N to create rows for each image.</li>
<li><strong>cols</strong> (<em>int</em>) – Number of columns in the grid.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Augmenter.to_deterministic">
<code class="descname">to_deterministic</code><span class="sig-paren">(</span><em>n=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Augmenter.to_deterministic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Augmenter.to_deterministic" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts this augmenter from a stochastic to a deterministic one.</p>
<p>A stochastic augmenter samples new values for each parameter per image.
Feed a new batch of images into the augmenter and you will get a
new set of transformations.
A deterministic augmenter also samples new values for each parameter
per image, but starts each batch with the same RandomState (i.e. seed).
Feed two batches of images into the augmenter and you get the same
transformations both times (same number of images assumed; some
augmenter’s results are also dependend on image height, width and
channel count).</p>
<p>Using determinism is useful for keypoint augmentation,
as you will usually want to augment images and their corresponding
keypoints in the same way (e.g. if an image is rotated by <cite>30deg</cite>, then
also rotate its keypoints by <cite>30deg</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> (<em>None or int, optional</em>) – Number of deterministic augmenters to return.
If None then only one Augmenter object will be returned.
If 1 or higher, then a list containing n Augmenter objects
will be returned.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>det</strong> – A single Augmenter object if n was None,
otherwise a list of Augmenter objects (even if n was 1).</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter">Augmenter</a> or list of Augmenter</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.meta.Lambda">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">Lambda</code><span class="sig-paren">(</span><em>func_images</em>, <em>func_keypoints</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Lambda"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Lambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter that calls a lambda function for each batch of input image.</p>
<p>This is useful to add missing functions to a list of augmenters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>func_images</strong> (<em>callable,</em>) – The function to call for each batch of images.
It must follow the form</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">function(images,</span> <span class="pre">random_state,</span> <span class="pre">parents,</span> <span class="pre">hooks)</span></code></p>
</div></blockquote>
<p>and return the changed images (may be transformed in-place).
This is essentially the interface of <cite>Augmenter._augment_images()</cite>.</p>
</li>
<li><p class="first"><strong>func_keypoints</strong> (<em>callable,</em>) – The function to call for each batch of image keypoints.
It must follow the form</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">function(keypoints_on_images,</span> <span class="pre">random_state,</span> <span class="pre">parents,</span> <span class="pre">hooks)</span></code></p>
</div></blockquote>
<p>and return the changed keypoints (may be transformed in-place).
This is essentially the interface of <cite>Augmenter._augment_keypoints()</cite>.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func_images</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">images</span><span class="p">[:,</span> <span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">images</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func_keypoints</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">keypoints_on_images</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Lambda</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">func_images</span><span class="o">=</span><span class="n">func_images</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">func_keypoints</span><span class="o">=</span><span class="n">func_keypoints</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">)</span>
</pre></div>
</div>
<p>Replaces every second row in images with black pixels and leaves keypoints
unchanged.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.meta.Lambda.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Lambda.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Lambda.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.meta.Noop">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">Noop</code><span class="sig-paren">(</span><em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Noop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Noop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter that never changes input images (“no operation”).</p>
<p>This augmenter is useful when you just want to use a placeholder augmenter
in some situation, so that you can continue to call <cite>augment_images()</cite>,
without actually changing them (e.g. when switching from training to test).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.meta.Noop.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Noop.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Noop.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.OneOf">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">OneOf</code><span class="sig-paren">(</span><em>children</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#OneOf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.OneOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that always executes exactly one of its children.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>children</strong> (<em>list of Augmenter</em>) – The choices of augmenters to apply.</li>
<li><strong>random_order</strong> (<em>boolean, optional(default=False)</em>) – Whether to apply the child augmenters in random order per image.
The order is resampled for each image.</li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">OneOf</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
<p>flips each image either horizontally or vertically.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">OneOf</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.05</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">iaa</span><span class="o">.</span><span class="n">AdditiveGaussianNoise</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="mi">255</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">]),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Noop</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
<p>either flips each image horizontally, or ads blur+dropout+noise or does
nothing.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.meta.Sequential">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">Sequential</code><span class="sig-paren">(</span><em>children=None</em>, <em>random_order=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Sequential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">list</span></code></p>
<p>List augmenter that may contain other augmenters to apply in sequence
or random order.</p>
<p>NOTE: You are <em>not</em> forced to use <cite>Sequential</cite> in order to use other
augmenters. Each augmenter can be used on its own, e.g the following
defines an augmenter for horizontal flips and then augments a single
image:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">image_aug</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">augment_image</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>children</strong> (<em>Augmenter or list of Augmenter or None, optional(default=None)</em>) – The augmenters to apply to images.</li>
<li><strong>random_order</strong> (<em>bool, optional(default=False)</em>) – Whether to apply the child augmenters in random order per image.
The order is resampled for each image.</li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
<p>Calls always first the horizontal flip augmenter and then the vertical
flip augmenter (each having a probability of 50 percent to be used).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">],</span> <span class="n">random_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
<p>Calls sometimes first the horizontal flip augmenter and sometimes first the
vertical flip augmenter (each again with 50 percent probability to be used).</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.meta.Sequential.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>augmenter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Sequential.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Sequential.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an augmenter to the list of child augmenters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>augmenter</strong> (<em>Augmenter</em>) – The augmenter to add.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Sequential.get_children_lists">
<code class="descname">get_children_lists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Sequential.get_children_lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Sequential.get_children_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Sequential.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Sequential.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Sequential.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.meta.SomeOf">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">SomeOf</code><span class="sig-paren">(</span><em>n=None</em>, <em>children=None</em>, <em>random_order=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#SomeOf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.SomeOf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a>, <code class="xref py py-class docutils literal"><span class="pre">list</span></code></p>
<p>List augmenter that applies only some of its children to images.</p>
<p>E.g. this allows to define a list of 20 augmenters, but only apply a
random selection of 5 of them to each image.</p>
<p>This augmenter currently does not support replacing (i.e. picking the same
child multiple times) due to implementation difficulties in connection
with deterministic augmenters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>n</strong> (<em>int or tuple of two ints or list of ints or StochasticParameter or None, optional(default=None)</em>) – Count of augmenters to
apply.</p>
<blockquote>
<div><ul class="simple">
<li>If int n, then exactly n of the child augmenters are applied to
every image.</li>
<li>If tuple of two ints (a, b), then a &lt;= x &lt;= b augmenters are
picked and applied to every image. Here, b may be set to None,
then it will automatically replaced with the total number of
available children.</li>
<li>If StochasticParameter, then N numbers will be sampled for N images.
The parameter is expected to be discrete.</li>
<li>If None, then the total number of available children will be
used (i.e. all children will be applied).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>children</strong> (<em>Augmenter or list of Augmenter or None, optional(default=None)</em>) – The augmenters to apply to images.</p>
</li>
<li><p class="first"><strong>random_order</strong> (<em>boolean, optional(default=False)</em>) – Whether to apply the child augmenters in random order per image.
The order is resampled for each image.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">SomeOf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
<p>Applies either Fliplr or Flipud to images.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">SomeOf</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">[</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
<p>Applies one to three of the listed augmenters (Fliplr, Flipud,
GaussianBlur) to images. They are always applied in the
order (1st) Fliplr, (2nd) Flipud, (3rd) GaussianBlur.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">SomeOf</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">[</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">],</span> <span class="n">random_order</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs_aug</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
</pre></div>
</div>
<p>Applies one to all of the listed augmenters (Fliplr, Flipud,
GaussianBlur) to images. They are applied in random order, i.e.
sometimes Blur first, followed by Fliplr, sometimes Fliplr follow by
Flipud followed by Blur, sometimes Flipud follow by Blur, etc.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.meta.SomeOf.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>augmenter</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#SomeOf.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.SomeOf.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an augmenter to the list of child augmenters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>augmenter</strong> (<em>Augmenter</em>) – The augmenter to add.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.SomeOf.get_children_lists">
<code class="descname">get_children_lists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#SomeOf.get_children_lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.SomeOf.get_children_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.SomeOf.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#SomeOf.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.SomeOf.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.meta.Sometimes">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">Sometimes</code><span class="sig-paren">(</span><em>p=0.5</em>, <em>then_list=None</em>, <em>else_list=None</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Sometimes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Sometimes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augment only p percent of all images with one or more augmenters.</p>
<p>Let C be one or more child augmenters given to Sometimes.
Let p be the percent of images to augment.
Let I be the input images.
Then (on average) p percent of all images in I will be augmented using C.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> (<em>float or StochasticParameter, optional(default=0.5)</em>) – Sets the probability with which the given augmenters will be applied to
input images. E.g. a value of 0.5 will result in 50 percent of all
input images being augmented.</li>
<li><strong>then_list</strong> (<em>None or Augmenter or list of Augmenters, optional(default=None)</em>) – Augmenter(s) to apply to p percent of all images.</li>
<li><strong>else_list</strong> (<em>None or Augmenter or list of Augmenters, optional(default=None)</em>) – Augmenter(s) to apply to (1-p) percent of all images.
These augmenters will be applied only when the ones in then_list
are NOT applied (either-or-relationship).</li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sometimes</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="mf">0.3</span><span class="p">))</span>
</pre></div>
</div>
<p>when calling <cite>aug.augment_images()</cite>, only (on average) 50 percent of
all images will be blurred.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sometimes</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="mf">0.3</span><span class="p">),</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>when calling <cite>aug.augment_images()</cite>, (on average) 50 percent of all images
will be blurred, the other (again, on average) 50 percent will be
horizontally flipped.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.meta.Sometimes.get_children_lists">
<code class="descname">get_children_lists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Sometimes.get_children_lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Sometimes.get_children_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.Sometimes.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#Sometimes.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.Sometimes.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.meta.WithChannels">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">WithChannels</code><span class="sig-paren">(</span><em>channels=None</em>, <em>children=None</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#WithChannels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.WithChannels" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Apply child augmenters to specific channels.</p>
<p>Let C be one or more child augmenters given to this augmenter.
Let H be a list of channels.
Let I be the input images.
Then this augmenter will pick the channels H from each image
in I (resulting in new images) and apply C to them.
The result of the augmentation will be merged back into the original
images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>channels</strong> (<em>integer or list of integers or None, optional(default=None)</em>) – Sets the channels to extract from each image.
If None, all channels will be used.</li>
<li><strong>children</strong> (<em>Augmenter or list of Augmenters or None, optional(default=None)</em>) – One or more augmenters to apply to images, after the channels
are extracted.</li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">WithChannels</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>assuming input images are RGB, then this augmenter will add 10 only
to the first channel, i.e. make images more red.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.meta.WithChannels.get_children_lists">
<code class="descname">get_children_lists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#WithChannels.get_children_lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.WithChannels.get_children_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.meta.WithChannels.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#WithChannels.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.WithChannels.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.clip_augmented_image">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">clip_augmented_image</code><span class="sig-paren">(</span><em>image</em>, <em>minval</em>, <em>maxval</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#clip_augmented_image"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.clip_augmented_image" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.clip_augmented_image_">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">clip_augmented_image_</code><span class="sig-paren">(</span><em>image</em>, <em>minval</em>, <em>maxval</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#clip_augmented_image_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.clip_augmented_image_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.clip_augmented_images">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">clip_augmented_images</code><span class="sig-paren">(</span><em>images</em>, <em>minval</em>, <em>maxval</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#clip_augmented_images"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.clip_augmented_images" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.clip_augmented_images_">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">clip_augmented_images_</code><span class="sig-paren">(</span><em>images</em>, <em>minval</em>, <em>maxval</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#clip_augmented_images_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.clip_augmented_images_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.copy_dtypes_for_restore">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">copy_dtypes_for_restore</code><span class="sig-paren">(</span><em>images</em>, <em>force_list=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#copy_dtypes_for_restore"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.copy_dtypes_for_restore" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.handle_children_list">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">handle_children_list</code><span class="sig-paren">(</span><em>lst</em>, <em>augmenter_name</em>, <em>lst_name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#handle_children_list"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.handle_children_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.restore_augmented_image_dtype">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">restore_augmented_image_dtype</code><span class="sig-paren">(</span><em>image</em>, <em>orig_dtype</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#restore_augmented_image_dtype"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.restore_augmented_image_dtype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.restore_augmented_image_dtype_">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">restore_augmented_image_dtype_</code><span class="sig-paren">(</span><em>image</em>, <em>orig_dtype</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#restore_augmented_image_dtype_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.restore_augmented_image_dtype_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.restore_augmented_images_dtypes">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">restore_augmented_images_dtypes</code><span class="sig-paren">(</span><em>images</em>, <em>orig_dtypes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#restore_augmented_images_dtypes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.restore_augmented_images_dtypes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.meta.restore_augmented_images_dtypes_">
<code class="descclassname">imgaug.augmenters.meta.</code><code class="descname">restore_augmented_images_dtypes_</code><span class="sig-paren">(</span><em>images</em>, <em>orig_dtypes</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/meta.html#restore_augmented_images_dtypes_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.meta.restore_augmented_images_dtypes_" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.arithmetic">
<span id="augmenters-arithmetic"></span><h2>augmenters.arithmetic<a class="headerlink" href="#module-imgaug.augmenters.arithmetic" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that perform simple arithmetic changes.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<dl class="docutils">
<dt>and then e.g.</dt>
<dd><cite>seq = iaa.Sequential([iaa.Add((-5, 5)), iaa.Multiply((0.9, 1.1))])</cite></dd>
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>Add</li>
<li>AddElementwise</li>
<li>AdditiveGaussianNoise</li>
<li>Multiply</li>
<li>Dropout</li>
<li>CoarseDropout</li>
<li>Invert</li>
<li>ContrastNormalization</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="imgaug.augmenters.arithmetic.Add">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">Add</code><span class="sig-paren">(</span><em>value=0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Add" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Add a value to all pixels in an image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>value</strong> (<em>int or iterable of two ints or StochasticParameter, optional(default=0)</em>) – Value to add to all
pixels.</p>
<blockquote>
<div><ul class="simple">
<li>If an int, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value from the discrete range [a .. b]
will be used.</li>
<li>If a StochasticParameter, then a value will be sampled per image
from that parameter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>always adds a value of 10 to all pixels in the image.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">((</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>adds a value from the discrete range [-10 .. 10] to all pixels of
the input images. The exact value is sampled per image.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">((</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>adds a value from the discrete range [-10 .. 10] to all pixels of
the input images. The exact value is sampled per image AND channel,
i.e. to a red-channel it might add 5 while subtracting 7 from the
blue channel of the same image.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">((</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>same as previous example, but the <cite>per_channel</cite> feature is only active
for 50 percent of all images.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.arithmetic.Add.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Add.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Add.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.arithmetic.AddElementwise">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">AddElementwise</code><span class="sig-paren">(</span><em>value=0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#AddElementwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.AddElementwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Add values to the pixels of images with possibly different values
for neighbouring pixels.</p>
<p>While the Add Augmenter adds a constant value per image, this one can
add different values (sampled per pixel).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>value</strong> (<em>int or iterable of two ints or StochasticParameter, optional(default=0)</em>) – Value to add to the
pixels.</p>
<blockquote>
<div><ul class="simple">
<li>If an int, then that value will be used for all images.</li>
<li>If a tuple (a, b), then values from the discrete range [a .. b]
will be sampled.</li>
<li>If a StochasticParameter, then values will be sampled per pixel
(and possibly channel) from that parameter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AddElementwise</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>always adds a value of 10 to all pixels in the image.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AddElementwise</span><span class="p">((</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>samples per pixel a value from the discrete range [-10 .. 10] and
adds that value to the pixel.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AddElementwise</span><span class="p">((</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>samples per pixel <em>and channel</em> a value from the discrete
range [-10 .. 10] ands adds it to the pixel’s value. Therefore,
added values may differ between channels of the same pixel.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AddElementwise</span><span class="p">((</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>same as previous example, but the <cite>per_channel</cite> feature is only active
for 50 percent of all images.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.arithmetic.AddElementwise.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#AddElementwise.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.AddElementwise.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.AdditiveGaussianNoise">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">AdditiveGaussianNoise</code><span class="sig-paren">(</span><em>loc=0</em>, <em>scale=0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#AdditiveGaussianNoise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.AdditiveGaussianNoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Add gaussian noise (aka white noise) to images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>loc</strong> (<em>int or float or tupel of two ints/floats or StochasticParameter, optional(default=0)</em>) – Mean of the normal distribution that generates the
noise.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>scale</strong> (<em>int or float or tupel of two ints/floats or StochasticParameter, optional(default=0)</em>) – Standard deviation of the normal distribution that generates the
noise. If this value gets too close to zero, the image will not be
changed.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same noise value per pixel for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianNoise</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="mi">255</span><span class="p">)</span>
</pre></div>
</div>
<p>adds gaussian noise from the distribution N(0, 0.1*255) to images.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianNoise</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="o">*</span><span class="mi">255</span><span class="p">))</span>
</pre></div>
</div>
<p>adds gaussian noise from the distribution N(0, s) to images,
where s is sampled per image from the range 0 &lt;= s &lt;= 0.1*255.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianNoise</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="mi">255</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>adds gaussian noise from the distribution N(0, 0.1*255) to images,
where the noise value is different per pixel <em>and</em> channel (e.g. a
different one for red, green and blue channels for the same pixel).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianNoise</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="mi">255</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>adds gaussian noise from the distribution N(0, 0.1*255) to images,
where the noise value is sometimes (50 percent of all cases) the same
per pixel for all channels and sometimes different (other 50 percent).</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.CoarseDropout">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">CoarseDropout</code><span class="sig-paren">(</span><em>p=0</em>, <em>size_px=None</em>, <em>size_percent=None</em>, <em>per_channel=False</em>, <em>min_size=4</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#CoarseDropout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.CoarseDropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that sets rectangular areas within images to zero.</p>
<p>In contrast to Dropout, these areas can have larger sizes.
(E.g. you might end up with three large black rectangles in an image.)
Note that the current implementation leads to correlated sizes,
so when there is one large area that is dropped, there is a high likelihood
that all other dropped areas are also large.</p>
<p>This method is implemented by generating the dropout mask at a
lower resolution (than the image has) and then upsampling the mask
before dropping the pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – The probability of any pixel being dropped (i.e. set to
zero).</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all pixels. A value
of 1.0 would mean, that all pixels will be dropped. A value of
0.0 would lead to no pixels being dropped.</li>
<li>If a tuple (a, b), then a value p will be sampled from the
range a &lt;= p &lt;= b per image and be used as the pixel’s dropout
probability.</li>
<li>If a StochasticParameter, then this parameter will be used to
determine per pixel whether it should be dropped (sampled value
of 0) or shouldn’t (sampled value of 1).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_px</strong> (<em>int or tuple of two ints or StochasticParameter, optional(default=None)</em>) – The size of the lower resolution image from which to sample the dropout
mask in absolute pixel dimensions.</p>
<blockquote>
<div><ul class="simple">
<li>If an integer, then that size will be used for both height and
width. E.g. a value of 3 would lead to a 3x3 mask, which is then
upsampled to HxW, where H is the image size and W the image width.</li>
<li>If a tuple (a, b), then two values M, N will be sampled from the
range [a..b] and the mask will be generated at size MxN, then
upsampled to HxW.</li>
<li>If a StochasticParameter, then this parameter will be used to
determine the sizes. It is expected to be discrete.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_percent</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=None)</em>) – The size of the lower resolution image from which to sample the dropout
mask <em>in percent</em> of the input image.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used as the percentage of the
height and width (relative to the original size). E.g. for value
p, the mask will be sampled from (p*H)x(p*W) and later upsampled
to HxW.</li>
<li>If a tuple (a, b), then two values m, n will be sampled from the
interval (a, b) and used as the percentages, i.e the mask size
will be (m*H)x(n*W).</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the percentage values. It is expected to be continuous.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value (is dropped / is not dropped)
for all channels of a pixel (False) or to sample a new value for each
channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>min_size</strong> (<em>int, optional(default=4)</em>) – Minimum size of the low resolution mask, both width and height. If
<cite>size_percent</cite> or <cite>size_px</cite> leads to a lower value than this, <cite>min_size</cite>
will be used instead. This should never have a value of less than 2,
otherwise one may end up with a 1x1 low resolution mask, leading easily
to the whole image being dropped.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">size_percent</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>drops 2 percent of all pixels on an lower-resolution image that has
50 percent of the original image’s size, leading to dropped areas that
have roughly 2x2 pixels size.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span> <span class="n">size_percent</span><span class="o">=</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>
</pre></div>
</div>
<p>generates a dropout mask at 5 to 50 percent of image’s size. In that mask,
0 to 5 percent of all pixels are dropped (random per image).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span> <span class="n">size_px</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
</pre></div>
</div>
<p>same as previous example, but the lower resolution image has 2 to 16 pixels
size.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">size_percent</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>drops 2 percent of all pixels at 50 percent resolution (2x2 sizes)
in a channel-wise fashion, i.e. it is unlikely
for any pixel to have all channels set to zero (black pixels).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">size_percent</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>same as previous example, but the <cite>per_channel</cite> feature is only active
for 50 percent of all images.</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.CoarsePepper">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">CoarsePepper</code><span class="sig-paren">(</span><em>p=0</em>, <em>size_px=None</em>, <em>size_percent=None</em>, <em>per_channel=False</em>, <em>min_size=4</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#CoarsePepper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.CoarsePepper" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds coarse pepper noise to an image, i.e. rectangles that contain
noisy black-ish pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Probability of changing a pixel to pepper
noise.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all images as the
probability.</li>
<li>If a tuple (a, b), then a probability will be sampled per image
from the range a &lt;= x &lt;= b..</li>
<li>If a StochasticParameter, then this parameter will be used as
the <em>mask</em>, i.e. it is expected to contain values between
0.0 and 1.0, where 1.0 means that pepper is to be added
at that location.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_px</strong> (<em>int or tuple of two ints or StochasticParameter, optional(default=None)</em>) – The size of the lower resolution image from which to sample the noise
mask in absolute pixel dimensions.</p>
<blockquote>
<div><ul class="simple">
<li>If an integer, then that size will be used for both height and
width. E.g. a value of 3 would lead to a 3x3 mask, which is then
upsampled to HxW, where H is the image size and W the image width.</li>
<li>If a tuple (a, b), then two values M, N will be sampled from the
range [a..b] and the mask will be generated at size MxN, then
upsampled to HxW.</li>
<li>If a StochasticParameter, then this parameter will be used to
determine the sizes. It is expected to be discrete.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_percent</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=None)</em>) – The size of the lower resolution image from which to sample the noise
mask <em>in percent</em> of the input image.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used as the percentage of the
height and width (relative to the original size). E.g. for value
p, the mask will be sampled from (p*H)x(p*W) and later upsampled
to HxW.</li>
<li>If a tuple (a, b), then two values m, n will be sampled from the
interval (a, b) and used as the percentages, i.e the mask size
will be (m*H)x(n*W).</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the percentage values. It is expected to be continuous.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value (is dropped / is not dropped)
for all channels of a pixel (False) or to sample a new value for each
channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>min_size</strong> (<em>int, optional(default=4)</em>) – Minimum size of the low resolution mask, both width and height. If
<cite>size_percent</cite> or <cite>size_px</cite> leads to a lower value than this, <cite>min_size</cite>
will be used instead. This should never have a value of less than 2,
otherwise one may end up with a 1x1 low resolution mask, leading easily
to the whole image being replaced.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CoarsePepper</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">size_percent</span><span class="o">=</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
</pre></div>
</div>
<p>Replaces 5 percent of all pixels with pepper in an image that has
1 to 10 percent of the input image size, then upscales the results
to the input image size, leading to large rectangular areas being replaced.</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.CoarseSalt">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">CoarseSalt</code><span class="sig-paren">(</span><em>p=0</em>, <em>size_px=None</em>, <em>size_percent=None</em>, <em>per_channel=False</em>, <em>min_size=4</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#CoarseSalt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.CoarseSalt" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds coarse salt noise to an image, i.e. rectangles containing noisy
white-ish pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Probability of changing a pixel to salt
noise.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all images as the
probability.</li>
<li>If a tuple (a, b), then a probability will be sampled per image
from the range a &lt;= x &lt;= b..</li>
<li>If a StochasticParameter, then this parameter will be used as
the <em>mask</em>, i.e. it is expected to contain values between
0.0 and 1.0, where 1.0 means that salt is to be added
at that location.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_px</strong> (<em>int or tuple of two ints or StochasticParameter, optional(default=None)</em>) – The size of the lower resolution image from which to sample the noise
mask in absolute pixel dimensions.</p>
<blockquote>
<div><ul class="simple">
<li>If an integer, then that size will be used for both height and
width. E.g. a value of 3 would lead to a 3x3 mask, which is then
upsampled to HxW, where H is the image size and W the image width.</li>
<li>If a tuple (a, b), then two values M, N will be sampled from the
range [a..b] and the mask will be generated at size MxN, then
upsampled to HxW.</li>
<li>If a StochasticParameter, then this parameter will be used to
determine the sizes. It is expected to be discrete.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_percent</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=None)</em>) – The size of the lower resolution image from which to sample the noise
mask <em>in percent</em> of the input image.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used as the percentage of the
height and width (relative to the original size). E.g. for value
p, the mask will be sampled from (p*H)x(p*W) and later upsampled
to HxW.</li>
<li>If a tuple (a, b), then two values m, n will be sampled from the
interval (a, b) and used as the percentages, i.e the mask size
will be (m*H)x(n*W).</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the percentage values. It is expected to be continuous.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value (is dropped / is not dropped)
for all channels of a pixel (False) or to sample a new value for each
channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>min_size</strong> (<em>int, optional(default=4)</em>) – Minimum size of the low resolution mask, both width and height. If
<cite>size_percent</cite> or <cite>size_px</cite> leads to a lower value than this, <cite>min_size</cite>
will be used instead. This should never have a value of less than 2,
otherwise one may end up with a 1x1 low resolution mask, leading easily
to the whole image being replaced.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CoarseSalt</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">size_percent</span><span class="o">=</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
</pre></div>
</div>
<p>Replaces 5 percent of all pixels with salt in an image that has
1 to 10 percent of the input image size, then upscales the results
to the input image size, leading to large rectangular areas being replaced.</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.CoarseSaltAndPepper">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">CoarseSaltAndPepper</code><span class="sig-paren">(</span><em>p=0</em>, <em>size_px=None</em>, <em>size_percent=None</em>, <em>per_channel=False</em>, <em>min_size=4</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#CoarseSaltAndPepper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.CoarseSaltAndPepper" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds coarse salt and pepper noise to an image, i.e. rectangles that
contain noisy white-ish and black-ish pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Probability of changing a pixel to salt/pepper
noise.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all images as the
probability.</li>
<li>If a tuple (a, b), then a probability will be sampled per image
from the range a &lt;= x &lt;= b..</li>
<li>If a StochasticParameter, then this parameter will be used as
the <em>mask</em>, i.e. it is expected to contain values between
0.0 and 1.0, where 1.0 means that salt/pepper is to be added
at that location.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_px</strong> (<em>int or tuple of two ints or StochasticParameter, optional(default=None)</em>) – The size of the lower resolution image from which to sample the noise
mask in absolute pixel dimensions.</p>
<blockquote>
<div><ul class="simple">
<li>If an integer, then that size will be used for both height and
width. E.g. a value of 3 would lead to a 3x3 mask, which is then
upsampled to HxW, where H is the image size and W the image width.</li>
<li>If a tuple (a, b), then two values M, N will be sampled from the
range [a..b] and the mask will be generated at size MxN, then
upsampled to HxW.</li>
<li>If a StochasticParameter, then this parameter will be used to
determine the sizes. It is expected to be discrete.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>size_percent</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=None)</em>) – The size of the lower resolution image from which to sample the noise
mask <em>in percent</em> of the input image.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used as the percentage of the
height and width (relative to the original size). E.g. for value
p, the mask will be sampled from (p*H)x(p*W) and later upsampled
to HxW.</li>
<li>If a tuple (a, b), then two values m, n will be sampled from the
interval (a, b) and used as the percentages, i.e the mask size
will be (m*H)x(n*W).</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the percentage values. It is expected to be continuous.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value (is dropped / is not dropped)
for all channels of a pixel (False) or to sample a new value for each
channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>min_size</strong> (<em>int, optional(default=4)</em>) – Minimum size of the low resolution mask, both width and height. If
<cite>size_percent</cite> or <cite>size_px</cite> leads to a lower value than this, <cite>min_size</cite>
will be used instead. This should never have a value of less than 2,
otherwise one may end up with a 1x1 low resolution mask, leading easily
to the whole image being replaced.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CoarseSaltAndPepper</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">size_percent</span><span class="o">=</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
</pre></div>
</div>
<p>Replaces 5 percent of all pixels with salt/pepper in an image that has
1 to 10 percent of the input image size, then upscales the results
to the input image size, leading to large rectangular areas being replaced.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.arithmetic.ContrastNormalization">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">ContrastNormalization</code><span class="sig-paren">(</span><em>alpha=1.0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#ContrastNormalization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.ContrastNormalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter that changes the contrast of images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>alpha</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=1.0)</em>) – Strength of the contrast normalization. Higher values than 1.0
lead to higher contrast, lower values decrease the contrast.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled per image from
the range a &lt;= x &lt;= b and be used as the alpha value.</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the alpha value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iaa</span><span class="o">.</span><span class="n">ContrastNormalization</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">))</span>
</pre></div>
</div>
<p>Decreases oder improves contrast per image by a random factor between
0.5 and 1.5. The factor 0.5 means that any difference from the center value
(i.e. 128) will be halved, leading to less contrast.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iaa</span><span class="o">.</span><span class="n">ContrastNormalization</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as before, but for 50 percent of all images the normalization is done
independently per channel (i.e. factors can vary per channel for the same
image). In the other 50 percent of all images, the factor is the same for
all channels.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.arithmetic.ContrastNormalization.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#ContrastNormalization.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.ContrastNormalization.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.Dropout">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">Dropout</code><span class="sig-paren">(</span><em>p=0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Dropout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Dropout" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that sets a certain fraction of pixels in images to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – The probability of any pixel being dropped (i.e. set to
zero).</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all images. A value
of 1.0 would mean that all pixels will be dropped and 0.0 that
no pixels would be dropped. A value of 0.05 corresponds to 5
percent of all pixels dropped.</li>
<li>If a tuple (a, b), then a value p will be sampled from the
range a &lt;= p &lt;= b per image and be used as the pixel’s dropout
probability.</li>
<li>If a StochasticParameter, then this parameter will be used to
determine per pixel whether it should be dropped (sampled value
of 0) or shouldn’t (sampled value of 1).
If you instead want to provide the probability as a stochastic
parameter, you can usually do <cite>Binomial(1-p)</cite> to convert parameter
<cite>p</cite> to a 0/1 representation.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value (is dropped / is not dropped)
for all channels of a pixel (False) or to sample a new value for each
channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.02</span><span class="p">)</span>
</pre></div>
</div>
<p>drops 2 percent of all pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">))</span>
</pre></div>
</div>
<p>drops in each image a random fraction of all pixels, where the fraction
is in the range 0.0 &lt;= x &lt;= 0.05.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>drops 2 percent of all pixels in a channel-wise fashion, i.e. it is unlikely
for any pixel to have all channels set to zero (black pixels).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>same as previous example, but the <cite>per_channel</cite> feature is only active
for 50 percent of all images.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.arithmetic.Invert">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">Invert</code><span class="sig-paren">(</span><em>p=0</em>, <em>per_channel=False</em>, <em>min_value=0</em>, <em>max_value=255</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Invert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter that inverts all values in images.</p>
<p>For the standard value range of 0-255 it converts 0 to 255, 255 to 0
and 10 to (255-10)=245.</p>
<p>Let M be the maximum value possible, m the minimum value possible,
v a value. Then the distance of v to m is d=abs(v-m) and the new value
is given by v’=M-d.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or StochasticParameter, optional(default=0)</em>) – The probability of an image to be
inverted.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that probability will be used for all images.</li>
<li>If a StochasticParameter, then that parameter will queried per
image and is expected to return values in the range [0.0, 1.0],
where values &gt;0.5 mean that the image/channel is supposed to be
inverted. Recommended to be some form of Binomial(…).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>min_value</strong> (<em>int or float, optional(default=0)</em>) – Minimum of the range of possible pixel values. For uint8 (0-255)
images, this should be 0.</p>
</li>
<li><p class="first"><strong>max_value</strong> (<em>int or float, optional(default=255)</em>) – Maximum of the range of possible pixel values. For uint8 (0-255)
images, this should be 255.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Invert</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>Inverts the colors in 10 percent of all images.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Invert</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>For 50 percent of all images, it inverts all channels with a probability of
10 percent (same as the first example). For the other 50 percent of all
images, it inverts each channel individually with a probability of 10
percent (so some channels of an image may end up inverted, others not).</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.arithmetic.Invert.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Invert.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Invert.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.arithmetic.Multiply">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">Multiply</code><span class="sig-paren">(</span><em>mul=1.0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Multiply all pixels in an image with a specific value.</p>
<p>This augmenter can be used to make images lighter or darker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>mul</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=1.0)</em>) – The value with which to multiply the pixel values in each
image.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will always be used.</li>
<li>If a tuple (a, b), then a value from the range a &lt;= x &lt;= b will
be sampled per image and used for all pixels.</li>
<li>If a StochasticParameter, then that parameter will be used to
sample a new value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same multiplier per pixel for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Multiply</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>would multiply all images by a factor of 2, making the images
significantly brighter.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Multiply</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">))</span>
</pre></div>
</div>
<p>would multiply images by a random value from the range 0.5 &lt;= x &lt;= 1.5,
making some images darker and others brighter.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.arithmetic.Multiply.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Multiply.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Multiply.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.arithmetic.MultiplyElementwise">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">MultiplyElementwise</code><span class="sig-paren">(</span><em>mul=1.0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#MultiplyElementwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.MultiplyElementwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Multiply values of pixels with possibly different values
for neighbouring pixels.</p>
<p>While the Multiply Augmenter uses a constant multiplier per image,
this one can use different multipliers per pixel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>mul</strong> (<em>float or iterable of two floats or StochasticParameter, optional(default=1.0)</em>) – The value by which to multiply the pixel values in the
image.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will always be used.</li>
<li>If a tuple (a, b), then a value from the range a &lt;= x &lt;= b will
be sampled per image and pixel.</li>
<li>If a StochasticParameter, then that parameter will be used to
sample a new value per image and pixel.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">MultiplyElementwise</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>multiply all images by a factor of 2.0, making them significantly
bighter.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">MultiplyElementwise</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">))</span>
</pre></div>
</div>
<p>samples per pixel a value from the range 0.5 &lt;= x &lt;= 1.5 and
multiplies the pixel with that value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">MultiplyElementwise</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>samples per pixel <em>and channel</em> a value from the range
0.5 &lt;= x &lt;= 1.5 ands multiplies the pixel by that value. Therefore,
added multipliers may differ between channels of the same pixel.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AddElementwise</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>same as previous example, but the <cite>per_channel</cite> feature is only active
for 50 percent of all images.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.arithmetic.MultiplyElementwise.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#MultiplyElementwise.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.MultiplyElementwise.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.Pepper">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">Pepper</code><span class="sig-paren">(</span><em>p=0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Pepper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Pepper" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds pepper noise to an image, i.e. black-ish pixels.
This is similar to dropout, but slower and the black pixels are not
uniformly black.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Probability of changing a pixel to pepper
noise.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all images as the
probability.</li>
<li>If a tuple (a, b), then a probability will be sampled per image
from the range a &lt;= x &lt;= b..</li>
<li>If a StochasticParameter, then this parameter will be used as
the <em>mask</em>, i.e. it is expected to contain values between
0.0 and 1.0, where 1.0 means that pepper is to be added
at that location.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pepper</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
<p>Replaces 5 percent of all pixels with pepper.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.arithmetic.ReplaceElementwise">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">ReplaceElementwise</code><span class="sig-paren">(</span><em>mask</em>, <em>replacement</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#ReplaceElementwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.ReplaceElementwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Replace pixels in an image with new values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>mask</strong> (<em>number or tuple of two number or StochasticParameter, optional(default=0)</em>) – Mask that indicates the pixels that are supposed to be replaced.
The mask will be thresholded with 0.5. A value of 1 then indicates a
pixel that is supposed to be replaced.</p>
<blockquote>
<div><ul class="simple">
<li>If this is a number, then that value will be used as the
probability of being a 1 per pixel.</li>
<li>If a tuple (a, b), then the probability will be sampled per image
from the range a &lt;= x &lt;= b.</li>
<li>If a StochasticParameter, then this parameter will be used to
sample a mask.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>replacement</strong> (<em>number or tuple of two number or list of number or StochasticParameter</em>) – The replacement to use at all locations that are marked as <cite>1</cite> in
the mask.</p>
<blockquote>
<div><ul class="simple">
<li>If this is a number, then that value will always be used as the
replacement.</li>
<li>If a tuple (a, b), then the replacement will be sampled pixelwise
from the range a &lt;= x &lt;= b.</li>
<li>If a list of number, then a random value will be picked from
that list as the replacement per pixel.</li>
<li>If a StochasticParameter, then this parameter will be used sample
pixelwise replacement values.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">ReplaceElementwise</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">])</span>
</pre></div>
</div>
<p>Replace 5 percent of all pixels in each image by either 0 or 255.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.arithmetic.ReplaceElementwise.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#ReplaceElementwise.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.ReplaceElementwise.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.Salt">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">Salt</code><span class="sig-paren">(</span><em>p=0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#Salt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.Salt" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds salt noise to an image, i.e. white-ish pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Probability of changing a pixel to salt
noise.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all images as the
probability.</li>
<li>If a tuple (a, b), then a probability will be sampled per image
from the range a &lt;= x &lt;= b..</li>
<li>If a StochasticParameter, then this parameter will be used as
the <em>mask</em>, i.e. it is expected to contain values between
0.0 and 1.0, where 1.0 means that salt is to be added
at that location.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Salt</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
<p>Replaces 5 percent of all pixels with salt.</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.arithmetic.SaltAndPepper">
<code class="descclassname">imgaug.augmenters.arithmetic.</code><code class="descname">SaltAndPepper</code><span class="sig-paren">(</span><em>p=0</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/arithmetic.html#SaltAndPepper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.arithmetic.SaltAndPepper" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds salt and pepper noise to an image, i.e. some white-ish and black-ish
pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>p</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Probability of changing a pixel to salt/pepper
noise.</p>
<blockquote>
<div><ul class="simple">
<li>If a float, then that value will be used for all images as the
probability.</li>
<li>If a tuple (a, b), then a probability will be sampled per image
from the range a &lt;= x &lt;= b..</li>
<li>If a StochasticParameter, then this parameter will be used as
the <em>mask</em>, i.e. it is expected to contain values between
0.0 and 1.0, where 1.0 means that salt/pepper is to be added
at that location.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same value for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">SaltAndPepper</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
<p>Replaces 5 percent of all pixels with salt/pepper.</p>
</dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.blur">
<span id="augmenters-blur"></span><h2>augmenters.blur<a class="headerlink" href="#module-imgaug.augmenters.blur" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that blur images.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<p>and then e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)),</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">AverageBlur</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>GaussianBlur</li>
<li>AverageBlur</li>
<li>MedianBlur</li>
<li>BilateralBlur</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="imgaug.augmenters.blur.AverageBlur">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.blur.</code><code class="descname">AverageBlur</code><span class="sig-paren">(</span><em>k=1</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/blur.html#AverageBlur"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.blur.AverageBlur" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Blur an image by computing simple means over neighbourhoods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>k</strong> (<em>int or tuple of two ints or tuple of each one/two ints or StochasticParameter or tuple of two StochasticParameter, optional</em>) –</p>
<dl class="docutils">
<dt>Kernel size to use.</dt>
<dd><ul class="first last simple">
<li>If a single int, then that value will be used for the height
and width of the kernel.</li>
<li>If a tuple of two ints <cite>(a, b)</cite>, then the kernel size will be
sampled from the interval <cite>[a..b]</cite>.</li>
<li>If a StochasticParameter, then <cite>N</cite> samples will be drawn from
that parameter per <cite>N</cite> input images, each representing the kernel
size for the nth image.</li>
<li>If a tuple <cite>(a, b)</cite>, where either <cite>a</cite> or <cite>b</cite> is a tuple, then <cite>a</cite>
and <cite>b</cite> will be treated according to the rules above. This leads
to different values for height and width of the kernel.</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>None or int or np.random.RandomState, optional</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AverageBlur</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Blurs all images using a kernel size of 5x5.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AverageBlur</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<p>Blurs images using a varying kernel size per image, which is sampled
from the interval [2..5].</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AverageBlur</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
<p>Blurs images using a varying kernel size per image, which’s height
is sampled from the interval [5..7] and which’s width is sampled
from [1..3].</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.blur.AverageBlur.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/blur.html#AverageBlur.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.blur.AverageBlur.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.blur.BilateralBlur">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.blur.</code><code class="descname">BilateralBlur</code><span class="sig-paren">(</span><em>d=1</em>, <em>sigma_color=(10</em>, <em>250)</em>, <em>sigma_space=(10</em>, <em>250)</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/blur.html#BilateralBlur"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.blur.BilateralBlur" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Blur/Denoise an image using a bilateral filter.</p>
<p>Bilateral filters blur homogenous and textured areas, while trying to
preserve edges.</p>
<p>See <a class="reference external" href="http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html#bilateralfilter">http://docs.opencv.org/2.4/modules/imgproc/doc/filtering.html#bilateralfilter</a>
for more information regarding the parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>d</strong> (<em>int or tuple of two ints or StochasticParameter</em>) – Diameter of each pixel neighborhood.
High values for d lead to significantly worse performance. Values
equal or less than 10 seem to be good.</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that value will be used for the diameter.</li>
<li>If a tuple of two ints (a, b), then the diameter will be a
value sampled from the interval [a..b].</li>
<li>If a StochasticParameter, then N samples will be drawn from
that parameter per N input images, each representing the diameter
for the nth image. Expected to be discrete.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>sigma_color</strong> (<em>int or tuple of two ints or StochasticParameter</em>) – Filter sigma in the color space. A larger value of the parameter means
that farther colors within the pixel neighborhood (see sigmaSpace )
will be mixed together, resulting in larger areas of semi-equal color.</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that value will be used for the diameter.</li>
<li>If a tuple of two ints (a, b), then the diameter will be a
value sampled from the interval [a..b].</li>
<li>If a StochasticParameter, then N samples will be drawn from
that parameter per N input images, each representing the diameter
for the nth image. Expected to be discrete.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>sigma_space</strong> – Filter sigma in the coordinate space. A larger value of the parameter
means that farther pixels will influence each other as long as their
colors are close enough (see sigmaColor ).
* If a single int, then that value will be used for the diameter.
* If a tuple of two ints (a, b), then the diameter will be a</p>
<blockquote>
<div><p>value sampled from the interval [a..b].</p>
</div></blockquote>
<ul class="simple">
<li>If a StochasticParameter, then N samples will be drawn from
that parameter per N input images, each representing the diameter
for the nth image. Expected to be discrete.</li>
</ul>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">BilateralBlur</span><span class="p">(</span><span class="n">d</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sigma_color</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">250</span><span class="p">),</span> <span class="n">sigma_space</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">250</span><span class="p">))</span>
</pre></div>
</div>
<p>blurs all images using a bilateral filter with max distance 3 to 10
and wide ranges for sigma_color and sigma_space.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.blur.BilateralBlur.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/blur.html#BilateralBlur.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.blur.BilateralBlur.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.blur.GaussianBlur">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.blur.</code><code class="descname">GaussianBlur</code><span class="sig-paren">(</span><em>sigma=0</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/blur.html#GaussianBlur"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.blur.GaussianBlur" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter to blur images using gaussian kernels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>sigma</strong> (<em>float or tuple of two floats or StochasticParameter</em>) – Standard deviation of the gaussian kernel.
Values in the range 0.0 (no blur) to 3.0 (strong blur) are common.</p>
<blockquote>
<div><ul class="simple">
<li>If a single float, that value will always be used as the standard
deviation.</li>
<li>If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b
will be picked per image.</li>
<li>If a StochasticParameter, then N samples will be drawn from
that parameter per N input images.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
</pre></div>
</div>
<p>blurs all images using a gaussian kernel with standard deviation 1.5.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">GaussianBlur</span><span class="p">(</span><span class="n">sigma</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">))</span>
</pre></div>
</div>
<p>blurs images using a gaussian kernel with a random standard deviation
from the range 0.0 &lt;= x &lt;= 3.0. The value is sampled per image.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.blur.GaussianBlur.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/blur.html#GaussianBlur.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.blur.GaussianBlur.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.blur.MedianBlur">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.blur.</code><code class="descname">MedianBlur</code><span class="sig-paren">(</span><em>k=1</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/blur.html#MedianBlur"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.blur.MedianBlur" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Blur an image by computing median values over neighbourhoods.</p>
<p>Median blurring can be used to remove small dirt from images.
At larger kernel sizes, its effects have some similarity with Superpixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>k</strong> (<em>int or tuple of two ints or StochasticParameter</em>) – Kernel
size.</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that value will be used for the height and
width of the kernel. Must be an odd value.</li>
<li>If a tuple of two ints (a, b), then the kernel size will be an
odd value sampled from the interval [a..b]. a and b must both
be odd values.</li>
<li>If a StochasticParameter, then N samples will be drawn from
that parameter per N input images, each representing the kernel
size for the nth image. Expected to be discrete. If a sampled
value is not odd, then that value will be increased by 1.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">MedianBlur</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>blurs all images using a kernel size of 5x5.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">MedianBlur</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
</pre></div>
</div>
<p>blurs images using a varying kernel size per image, which is
and odd value sampled from the interval [3..7], i.e. 3 or 5 or 7.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.blur.MedianBlur.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/blur.html#MedianBlur.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.blur.MedianBlur.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.color">
<span id="augmenters-color"></span><h2>augmenters.color<a class="headerlink" href="#module-imgaug.augmenters.color" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that apply color space oriented changes.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<p>and then e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Grayscale</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)),</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">AddToHueAndSaturation</span><span class="p">((</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>InColorspace (deprecated)</li>
<li>WithColorspace</li>
<li>AddToHueAndSaturation</li>
<li>ChangeColorspace</li>
<li>Grayscale</li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="imgaug.augmenters.color.AddToHueAndSaturation">
<code class="descclassname">imgaug.augmenters.color.</code><code class="descname">AddToHueAndSaturation</code><span class="sig-paren">(</span><em>value=0, per_channel=False, from_colorspace='RGB', channels=[0, 1], name=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/color.html#AddToHueAndSaturation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.color.AddToHueAndSaturation" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that transforms images into HSV space, selects the H and S
channels and then adds a given range of values to these.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>value</strong> (<em>int or iterable of two ints or StochasticParameter, optional(default=0)</em>) – See <cite>Add.__init__()</cite></li>
<li><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – See <cite>Add.__init__()</cite></li>
<li><strong>from_colorspace</strong> (<em>string, optional(default=”RGB”)</em>) – See <cite>ChangeColorspace.__init__()</cite></li>
<li><strong>channels</strong> (<em>integer or list of integers or None, optional(default=[0, 1])</em>) – See <cite>WithChannels.__init__()</cite></li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>&gt;&gt; aug = AddToHueAndSaturation((-20, 20), per_channel=True)</p>
<p>Adds random values between -20 and 20 to the hue and saturation
(independently per channel and the same value for all pixels within
that channel).</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.color.ChangeColorspace">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.color.</code><code class="descname">ChangeColorspace</code><span class="sig-paren">(</span><em>to_colorspace</em>, <em>from_colorspace='RGB'</em>, <em>alpha=1.0</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/color.html#ChangeColorspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter to change the colorspace of images.</p>
<p>NOTE: This augmenter is not tested. Some colorspaces might work, others
might not.</p>
<p>NOTE: This augmenter tries to project the colorspace value range on 0-255.
It outputs dtype=uint8 images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>to_colorspace</strong> (<em>string or iterable or StochasticParameter</em>) – The target colorspace.
Allowed are: RGB, BGR, GRAY, CIE, YCrCb, HSV, HLS, Lab, Luv.</p>
<blockquote>
<div><ul class="simple">
<li>If a string, it must be among the allowed colorspaces.</li>
<li>If an iterable, it is expected to be a list of strings, each one
being an allowed colorspace. A random element from the list
will be chosen per image.</li>
<li>If a StochasticParameter, it is expected to return string. A new
sample will be drawn per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>from_colorspace</strong> (<em>string, optional(default=”RGB”)</em>) – The source colorspace (of the input images).
Allowed are: RGB, BGR, GRAY, CIE, YCrCb, HSV, HLS, Lab, Luv.</p>
</li>
<li><p class="first"><strong>alpha</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=1.0)</em>) – The alpha value of the new colorspace when overlayed over the
old one. A value close to 1.0 means that mostly the new
colorspace is visible. A value close to 0.0 means, that mostly the
old image is visible. Use a tuple (a, b) to use a random value
<cite>x</cite> with <cite>a &lt;= x &lt;= b</cite> as the alpha value per image.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.BGR">
<code class="descname">BGR</code><em class="property"> = 'BGR'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.BGR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.CIE">
<code class="descname">CIE</code><em class="property"> = 'CIE'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.CIE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.COLORSPACES">
<code class="descname">COLORSPACES</code><em class="property"> = {'Lab', 'RGB', 'BGR', 'CIE', 'GRAY', 'HLS', 'Luv', 'HSV', 'YCrCb'}</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.COLORSPACES" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.CV_VARS">
<code class="descname">CV_VARS</code><em class="property"> = {'BGR2CIE': &lt;MagicMock id='2229563080488'&gt;, 'BGR2GRAY': &lt;MagicMock id='2229562768408'&gt;, 'BGR2HLS': &lt;MagicMock id='2229563248368'&gt;, 'BGR2HSV': &lt;MagicMock id='2229563160728'&gt;, 'BGR2LAB': &lt;MagicMock id='2229565862800'&gt;, 'BGR2LUV': &lt;MagicMock id='2229565879408'&gt;, 'BGR2RGB': &lt;MagicMock id='2229563095640'&gt;, 'BGR2YCrCb': &lt;MagicMock id='2229564335888'&gt;, 'HSV2BGR': &lt;MagicMock id='2229565904432'&gt;, 'HSV2RGB': &lt;MagicMock id='2229565896016'&gt;, 'RGB2BGR': &lt;MagicMock id='2229565751192'&gt;, 'RGB2CIE': &lt;MagicMock id='2229564315856'&gt;, 'RGB2GRAY': &lt;MagicMock id='2229564220080'&gt;, 'RGB2HLS': &lt;MagicMock id='2229564124072'&gt;, 'RGB2HSV': &lt;MagicMock id='2229564157176'&gt;, 'RGB2LAB': &lt;MagicMock id='2229565350912'&gt;, 'RGB2LUV': &lt;MagicMock id='2229563147040'&gt;, 'RGB2YCrCb': &lt;MagicMock id='2229564208856'&gt;}</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.CV_VARS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.GRAY">
<code class="descname">GRAY</code><em class="property"> = 'GRAY'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.GRAY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.HLS">
<code class="descname">HLS</code><em class="property"> = 'HLS'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.HLS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.HSV">
<code class="descname">HSV</code><em class="property"> = 'HSV'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.HSV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.Lab">
<code class="descname">Lab</code><em class="property"> = 'Lab'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.Lab" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.Luv">
<code class="descname">Luv</code><em class="property"> = 'Luv'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.Luv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.RGB">
<code class="descname">RGB</code><em class="property"> = 'RGB'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.RGB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="imgaug.augmenters.color.ChangeColorspace.YCrCb">
<code class="descname">YCrCb</code><em class="property"> = 'YCrCb'</em><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.YCrCb" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.color.ChangeColorspace.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/color.html#ChangeColorspace.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.color.ChangeColorspace.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.color.Grayscale">
<code class="descclassname">imgaug.augmenters.color.</code><code class="descname">Grayscale</code><span class="sig-paren">(</span><em>alpha=0</em>, <em>from_colorspace='RGB'</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/color.html#Grayscale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.color.Grayscale" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter to convert images to their grayscale versions.</p>
<p>NOTE: Number of output channels is still 3, i.e. this augmenter just
“removes” color.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>alpha</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=0)</em>) – The alpha value of the grayscale image when overlayed over the
old image. A value close to 1.0 means, that mostly the new grayscale
image is visible. A value close to 0.0 means, that mostly the
old image is visible. Use a tuple (a, b) to sample per image a
random value x with a &lt;= x &lt;= b as the alpha value.</li>
<li><strong>from_colorspace</strong> (<em>string, optional(default=”RGB”)</em>) – The source colorspace (of the input images).
Allowed are: RGB, BGR, GRAY, CIE, YCrCb, HSV, HLS, Lab, Luv.
Only RGB is decently tested.</li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Grayscale</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>creates an augmenter that turns images to their grayscale versions.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Grayscale</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>creates an augmenter that turns images to their grayscale versions with
an alpha value in the range 0 &lt;= alpha &lt;= 1. An alpha value of 0.5 would
mean, that the output image is 50 percent of the input image and 50
percent of the grayscale image (i.e. 50 percent of color removed).</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.color.InColorspace">
<code class="descclassname">imgaug.augmenters.color.</code><code class="descname">InColorspace</code><span class="sig-paren">(</span><em>to_colorspace</em>, <em>from_colorspace='RGB'</em>, <em>children=None</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/color.html#InColorspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.color.InColorspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated. Use WithColorspace.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.color.WithColorspace">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.color.</code><code class="descname">WithColorspace</code><span class="sig-paren">(</span><em>to_colorspace</em>, <em>from_colorspace='RGB'</em>, <em>children=None</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/color.html#WithColorspace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.color.WithColorspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Apply child augmenters within a specific colorspace.</p>
<p>This augumenter takes a source colorspace A and a target colorspace B
as well as children C. It changes images from A to B, then applies the
child augmenters C and finally changes the colorspace back from B to A.
See also ChangeColorspace() for more.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>to_colorspace</strong> (<em>string</em>) – See <cite>ChangeColorspace.__init__()</cite></li>
<li><strong>from_colorspace</strong> (<em>string, optional(default=”RGB”)</em>) – See <cite>ChangeColorspace.__init__()</cite></li>
<li><strong>children</strong> (<em>None or Augmenter or list of Augmenters, optional(default=None)</em>) – See <cite>ChangeColorspace.__init__()</cite></li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">WithColorspace</span><span class="p">(</span><span class="n">to_colorspace</span><span class="o">=</span><span class="s2">&quot;HSV&quot;</span><span class="p">,</span> <span class="n">from_colorspace</span><span class="o">=</span><span class="s2">&quot;RGB&quot;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="n">children</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">WithChannels</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span>
</pre></div>
</div>
<p>This augmenter will add 10 to Hue value in HSV colorspace,
then change the colorspace back to the original (RGB).</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.color.WithColorspace.get_children_lists">
<code class="descname">get_children_lists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/color.html#WithColorspace.get_children_lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.color.WithColorspace.get_children_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.color.WithColorspace.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/color.html#WithColorspace.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.color.WithColorspace.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.convolutional">
<span id="augmenters-convolutional"></span><h2>augmenters.convolutional<a class="headerlink" href="#module-imgaug.augmenters.convolutional" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that apply convolutions to images.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<p>and then e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Sharpen</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)),</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Emboss</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>Convolve</li>
<li>Sharpen</li>
<li>Emboss</li>
<li>EdgeDetect</li>
<li>DirectedEdgeDetect</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="imgaug.augmenters.convolutional.Convolve">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.convolutional.</code><code class="descname">Convolve</code><span class="sig-paren">(</span><em>matrix=None</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/convolutional.html#Convolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.convolutional.Convolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Apply a Convolution to input images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>matrix</strong> (<em>None or (H, W) ndarray or StochasticParameter or callable, optional(default=None)</em>) – The weight matrix of the convolution kernel to
apply.</p>
<blockquote>
<div><ul class="simple">
<li>If None, the input images will not be changed.</li>
<li>If a numpy array, that array will be used for all images and
channels as the kernel.</li>
<li>If a callable, the parameter will be called for each image
via param(image, C, random_state). The function must either return
a list of C matrices (i.e. one per channel) or a 2D numpy array
(will be used for all channels) or a 3D HxWxC numpy array.
If a list is returned, each entry may be None, which will result
in no changes to the respective channel.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                   <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Convolve</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">)</span>
</pre></div>
</div>
<p>convolves all input images with the kernel shown in the <cite>matrix</cite>
variable.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">gen_matrix</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">nb_channels</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">matrix_A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">matrix_B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">&gt;&gt;&gt; </span>                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="p">[</span><span class="n">matrix_A</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb_channels</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="p">[</span><span class="n">matrix_B</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb_channels</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Convolve</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">gen_matrix</span><span class="p">)</span>
</pre></div>
</div>
<p>convolves images that have an even height with matrix A and images
with an odd height with matrix B.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.convolutional.Convolve.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/convolutional.html#Convolve.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.convolutional.Convolve.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.convolutional.DirectedEdgeDetect">
<code class="descclassname">imgaug.augmenters.convolutional.</code><code class="descname">DirectedEdgeDetect</code><span class="sig-paren">(</span><em>alpha=0</em>, <em>direction=(0.0</em>, <em>1.0)</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/convolutional.html#DirectedEdgeDetect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.convolutional.DirectedEdgeDetect" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that detects edges that have certain directions and marks them
in a black and white image and then overlays the result with the original
image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>alpha</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=0)</em>) – Visibility of the sharpened image. At 0, only the original image is
visible, at 1.0 only its sharpened version is visible.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>direction</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=(0.0, 1.0))</em>) – Angle of edges to pronounce, where 0 represents 0 degrees and 1.0
represents 360 degrees (both clockwise, starting at the top).
Default value is (0.0, 1.0), i.e. pick a random angle per image.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">DirectedEdgeDetect</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>turns input images into edge images in which edges are detected from
top side of the image (i.e. the top sides of horizontal edges are
added to the output).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">DirectedEdgeDetect</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="mi">90</span><span class="o">/</span><span class="mi">360</span><span class="p">)</span>
</pre></div>
</div>
<p>same as before, but detecting edges from the right (right side of each
vertical edge).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">DirectedEdgeDetect</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>same as before, but detecting edges from a variable direction (anything
between 0 and 1.0, i.e. 0 degrees and 360 degrees, starting from the
top and moving clockwise).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">DirectedEdgeDetect</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">),</span> <span class="n">direction</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>generates edge images (edges detected from the top) and overlays them
with the input images by a variable amount between 0 and 30 percent
(e.g. for 0.3 then <cite>0.7*old_image + 0.3*edge_image</cite>).</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.convolutional.EdgeDetect">
<code class="descclassname">imgaug.augmenters.convolutional.</code><code class="descname">EdgeDetect</code><span class="sig-paren">(</span><em>alpha=0</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/convolutional.html#EdgeDetect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.convolutional.EdgeDetect" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that detects all edges in images, marks them in
a black and white image and then overlays the result with the original
image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>alpha</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=0)</em>) – Visibility of the sharpened image. At 0, only the original image is
visible, at 1.0 only its sharpened version is visible.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">EdgeDetect</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>detects edges in an image  and overlays the result with a variable alpha
in the range 0.0 &lt;= a &lt;= 1.0 over the old image.</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.convolutional.Emboss">
<code class="descclassname">imgaug.augmenters.convolutional.</code><code class="descname">Emboss</code><span class="sig-paren">(</span><em>alpha=0</em>, <em>strength=1</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/convolutional.html#Emboss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.convolutional.Emboss" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that embosses images and overlays the result with the original
image.</p>
<p>The embossed version pronounces highlights and shadows,
letting the image look as if it was recreated on a metal plate (“embossed”).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>alpha</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=0)</em>) – Visibility of the sharpened image. At 0, only the original image is
visible, at 1.0 only its sharpened version is visible.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>strength</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=1)</em>) – Parameter that controls the strength of the embossing.
Sane values are somewhere in the range (0, 2) with 1 being the standard
embossing effect. Default value is 1.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">Emboss</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">strength</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">))</span>
</pre></div>
</div>
<p>embosses an image with a variable strength in the range 0.5 &lt;= x &lt;= 1.5
and overlays the result with a variable alpha in the range 0.0 &lt;= a &lt;= 1.0
over the old image.</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.convolutional.Sharpen">
<code class="descclassname">imgaug.augmenters.convolutional.</code><code class="descname">Sharpen</code><span class="sig-paren">(</span><em>alpha=0</em>, <em>lightness=1</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/convolutional.html#Sharpen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.convolutional.Sharpen" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that sharpens images and overlays the result with the original
image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>alpha</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=0)</em>) – Visibility of the sharpened image. At 0, only the original image is
visible, at 1.0 only its sharpened version is visible.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>lightness</strong> (<em>int or float or tuple of two ints/floats or StochasticParameter, optional(default=1)</em>) – Parameter that controls the lightness/brightness of the sharped image.
Sane values are somewhere in the range (0.5, 2).
The value 0 results in an edge map. Values higher than 1 create bright
images. Default value is 1.</p>
<blockquote>
<div><ul class="simple">
<li>If an int or float, exactly that value will be used.</li>
<li>If a tuple (a, b), a random value from the range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If a StochasticParameter, a value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">Sharpen</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>sharpens input images and overlays the sharpened image by a variable
amount over the old image.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">Sharpen</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">lightness</span><span class="o">=</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">))</span>
</pre></div>
</div>
<p>sharpens input images with a variable lightness in the range
0.75 &lt;= x &lt;= 2.0 and with a variable alpha.</p>
</dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.flip">
<span id="augmenters-flip"></span><h2>augmenters.flip<a class="headerlink" href="#module-imgaug.augmenters.flip" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that apply mirroring/flipping operations to images.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<p>and then e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)),</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>Fliplr</li>
<li>Flipud</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="imgaug.augmenters.flip.Fliplr">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.flip.</code><code class="descname">Fliplr</code><span class="sig-paren">(</span><em>p=0</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/flip.html#Fliplr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.flip.Fliplr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Flip/mirror input images horizontally.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> (<em>int or float or StochasticParameter, optional(default=0)</em>) – Probability of each image to get flipped.</li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>would horizontally flip/mirror 50 percent of all input images.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Fliplr</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>would horizontally flip/mirror all input images.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.flip.Fliplr.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/flip.html#Fliplr.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.flip.Fliplr.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.flip.Flipud">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.flip.</code><code class="descname">Flipud</code><span class="sig-paren">(</span><em>p=0</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/flip.html#Flipud"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.flip.Flipud" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Flip/mirror input images vertically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> (<em>int or float or StochasticParameter, optional(default=0)</em>) – Probability of each image to get flipped.</li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>would vertically flip/mirror 50 percent of all input images.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Flipud</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>would vertically flip/mirror all input images.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.flip.Flipud.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/flip.html#Flipud.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.flip.Flipud.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.geometric">
<span id="augmenters-geometric"></span><h2>augmenters.geometric<a class="headerlink" href="#module-imgaug.augmenters.geometric" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that apply affine transformations or other similar augmentations.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<p>and then e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="o">...</span><span class="p">),</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">PerspectiveTransform</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>Affine</li>
<li>PiecewiseAffine</li>
<li>PerspectiveTransform</li>
<li>ElasticTransformation</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="imgaug.augmenters.geometric.Affine">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.geometric.</code><code class="descname">Affine</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>translate_percent=None</em>, <em>translate_px=None</em>, <em>rotate=0.0</em>, <em>shear=0.0</em>, <em>order=1</em>, <em>cval=0</em>, <em>mode='constant'</em>, <em>backend='auto'</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#Affine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.Affine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter to apply affine transformations to images.</p>
<p>This is mostly a wrapper around skimage’s AffineTransform class and
warp function.</p>
<p>Affine transformations
involve:</p>
<blockquote>
<div><ul class="simple">
<li>Translation (“move” image on the x-/y-axis)</li>
<li>Rotation</li>
<li>Scaling (“zoom” in/out)</li>
<li>Shear (move one side of the image, turning a square into a trapezoid)</li>
</ul>
</div></blockquote>
<p>All such transformations can create “new” pixels in the image without a
defined content, e.g. if the image is translated to the left, pixels
are created on the right.
A method has to be defined to deal with these pixel values. The
parameters <cite>cval</cite> and <cite>mode</cite> of this class deal with this.</p>
<p>Some transformations involve interpolations between several pixels
of the input image to generate output pixel values. The parameter <cite>order</cite>
deals with the method of interpolation used for this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>scale</strong> (<em>float or tuple of two floats or StochasticParameter or dict {“x”: float/tuple/StochasticParameter, “y”: float/tuple/StochasticParameter}, optional(default=1.0)</em>) – Scaling factor to use, where 1.0 represents no change and 0.5 is
zoomed out to 50 percent of the original size.</p>
<blockquote>
<div><ul class="simple">
<li>If a single float, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled from the range
a &lt;= x &lt;= b per image. That value will be used identically for
both x- and y-axis.</li>
<li>If a StochasticParameter, then from that parameter a value will
be sampled per image (again, used for both x- and y-axis).</li>
<li>If a dictionary, then it is expected to have the keys “x” and/or “y”.
Each of these keys can have the same values as described before
for this whole parameter (<cite>scale</cite>). Using a dictionary allows to
set different values for the axis. If they are set to the same
ranges, different values may still be sampled per axis.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>translate_percent</strong> (<em>float or tuple of two floats or StochasticParameter or dict {“x”: float/tuple/StochasticParameter, “y”: float/tuple/StochasticParameter}, optional(default=1.0)</em>) – Translation in percent relative to the image
height/width (x-translation, y-translation) to use,
where 0 represents no change and 0.5 is half of the image
height/width.</p>
<blockquote>
<div><ul class="simple">
<li>If a single float, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled from the range
a &lt;= x &lt;= b per image. That percent value will be used identically
for both x- and y-axis.</li>
<li>If a StochasticParameter, then from that parameter a value will
be sampled per image (again, used for both x- and y-axis).</li>
<li>If a dictionary, then it is expected to have the keys “x” and/or “y”.
Each of these keys can have the same values as described before
for this whole parameter (<cite>translate_percent</cite>).
Using a dictionary allows to set different values for the axis.
If they are set to the same ranges, different values may still
be sampled per axis.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>translate_px</strong> (<em>int or tuple of two ints or StochasticParameter or dict {“x”: int/tuple/StochasticParameter, “y”: int/tuple/StochasticParameter}, optional(default=1.0)</em>) – Translation in
pixels.</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled from the discrete
range [a .. b] per image. That number will be used identically
for both x- and y-axis.</li>
<li>If a StochasticParameter, then from that parameter a value will
be sampled per image (again, used for both x- and y-axis).</li>
<li>If a dictionary, then it is expected to have the keys “x” and/or “y”.
Each of these keys can have the same values as described before
for this whole parameter (<cite>translate_px</cite>).
Using a dictionary allows to set different values for the axis.
If they are set to the same ranges, different values may still
be sampled per axis.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>rotate</strong> (<em>float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)</em>) – Rotation in degrees (NOT radians), i.e. expected value range is
0 to 360 for positive rotations (may also be negative).</p>
<blockquote>
<div><ul class="simple">
<li>If a float/int, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled per image from the
range a &lt;= x &lt;= b and be used as the rotation value.</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the rotation value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>shear</strong> (<em>float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)</em>) – Shear in degrees (NOT radians), i.e. expected value range is
0 to 360 for positive shear (may also be negative).</p>
<blockquote>
<div><ul class="simple">
<li>If a float/int, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled per image from the
range a &lt;= x &lt;= b and be used as the rotation value.</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the shear value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>order</strong> (<em>int or iterable of int or ia.ALL or StochasticParameter, optional(default=1)</em>) – Interpolation order to use. Same meaning as in
skimage:</p>
<blockquote>
<div><ul class="simple">
<li>0: Nearest-neighbor</li>
<li>1: Bi-linear (default)</li>
<li>2: Bi-quadratic (not recommended by skimage)</li>
<li>3: Bi-cubic</li>
<li>4: Bi-quartic</li>
<li>5: Bi-quintic</li>
</ul>
</div></blockquote>
<p>Method 0 and 1 are fast, 3 is a bit slower, 4 and 5 are very
slow.
If the backend is <cite>cv2</cite>, the mapping to opencv’s interpolation modes
is as follows:</p>
<blockquote>
<div><ul class="simple">
<li>0 -&gt; cv2.INTER_NEAREST</li>
<li>1 -&gt; cv2.INTER_LINEAR</li>
<li>2 -&gt; cv2.INTER_CUBIC</li>
<li>3 -&gt; cv2.INTER_CUBIC</li>
<li>4 -&gt; cv2.INTER_CUBIC</li>
</ul>
</div></blockquote>
<p>As datatypes this parameter
accepts:</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that order will be used for all images.</li>
<li>If an iterable, then for each image a random value will be sampled
from that iterable (i.e. list of allowed order values).</li>
<li>If ia.ALL, then equivalant to list [0, 1, 3, 4, 5].</li>
<li>If StochasticParameter, then that parameter is queried per image
to sample the order value to use.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>cval</strong> (<em>number or tuple of two number or ia.ALL or StochasticParameter, optional(default=0)</em>) – The constant value used for skimage’s transform function.
This is the value used to fill up pixels in the result image that
didn’t exist in the input image (e.g. when translating to the left,
some new pixels are created at the right). Such a fill-up with a
constant value only happens, when <cite>mode</cite> is “constant”.
For standard uint8 images (value range 0-255), this value may also
come from the range 0-255. It may be a float value, even for
integer image dtypes.</p>
<blockquote>
<div><ul class="simple">
<li>If this is a single int or float, then that value will be used
(e.g. 0 results in black pixels).</li>
<li>If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b
is picked per image.</li>
<li>If ia.ALL, a value from the discrete range [0 .. 255] will be
sampled per image.</li>
<li>If a StochasticParameter, a new value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>mode</strong> (<em>string or list of string or ia.ALL or StochasticParameter, optional(default=”constant”)</em>) – Parameter that defines the handling of newly created pixels.
Same meaning as in skimage (and numpy.pad):</p>
<blockquote>
<div><ul class="simple">
<li>“constant”: Pads with a constant value</li>
<li>“edge”: Pads with the edge values of array</li>
<li>“symmetric”: Pads with the reflection of the vector mirrored
along the edge of the array.</li>
<li>“reflect”: Pads with the reflection of the vector mirrored on
the first and last values of the vector along each axis.</li>
<li>“wrap”: Pads with the wrap of the vector along the axis.
The first values are used to pad the end and the end values
are used to pad the beginning.</li>
</ul>
</div></blockquote>
<p>If <cite>cv2</cite> is chosen as the backend the mapping is as
follows:</p>
<blockquote>
<div><ul class="simple">
<li>“constant” -&gt; cv2.BORDER_CONSTANT</li>
<li>“edge” -&gt; cv2.BORDER_REPLICATE</li>
<li>“symmetric” -&gt; cv2.BORDER_REFLECT</li>
<li>“reflect” -&gt; cv2.BORDER_REFLECT_101</li>
<li>“wrap” -&gt; cv2.BORDER_WRAP</li>
</ul>
</div></blockquote>
<p>The datatype of the parameter may
be:</p>
<blockquote>
<div><ul class="simple">
<li>If a single string, then that mode will be used for all images.</li>
<li>If a list of strings, then per image a random mode will be picked
from that list.</li>
<li>If ia.ALL, then a random mode from all possible modes will be
picked.</li>
<li>If StochasticParameter, then the mode will be sampled from that
parameter per image, i.e. it must return only the above mentioned
strings.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>backend</strong> (<em>string, optional(default=”auto”)</em>) – Framework to use as a backend. Valid values are <cite>auto</cite>, <cite>skimage</cite>
(scikit-image’s warp) and <cite>cv2</cite> (opencv’s warp).
If <cite>auto</cite> is used, the augmenter will automatically try
to use cv2 where possible (order must be in [0, 1, 3] and
image’s dtype uint8, otherwise skimage is chosen). It will
silently fall back to skimage if order/dtype is not supported by cv2.
cv2 is generally faster than skimage. It also supports RGB cvals,
while skimage will resort to intensity cvals (i.e. 3x the same value
as RGB). If <cite>cv2</cite> is chosen and order is 2 or 4, it will automatically
fall back to order 3.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>zooms all images by a factor of 2.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p>translates all images on the x- and y-axis by 16 pixels (to the
right/top), fills up any new pixels with zero (black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_percent</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>translates all images on the x- and y-axis by 10 percent of their
width/height (to the right/top), fills up any new pixels with zero
(black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">rotate</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
</pre></div>
</div>
<p>rotates all images by 35 degrees, fills up any new pixels with zero
(black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">shear</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>rotates all images by 15 degrees, fills up any new pixels with zero
(black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
</pre></div>
</div>
<p>translates all images on the x- and y-axis by a random value
between -16 and 16 pixels (to the right/top) (same for both axis, i.e.
sampled once per image), fills up any new pixels with zero (black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)})</span>
</pre></div>
</div>
<p>translates all images on the x-axis by a random value
between -16 and 16 pixels (to the right) and on the y-axis by a
random value between -4 and 4 pixels to the top. Even if both ranges
were the same, both axis could use different samples.
Fills up any new pixels with zero (black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>same as previously, but uses (randomly) either nearest neighbour
interpolation or linear interpolation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
</pre></div>
</div>
<p>same as previously, but fills up any new pixels with a random
brightness (same for the whole image).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>same as previously, but fills up the new pixels in only 50 percent
of all images with black values. In the other 50 percent of all cases,
the value of the nearest edge is used.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.geometric.Affine.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#Affine.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.Affine.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.geometric.AffineCv2">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.geometric.</code><code class="descname">AffineCv2</code><span class="sig-paren">(</span><em>scale=1.0</em>, <em>translate_percent=None</em>, <em>translate_px=None</em>, <em>rotate=0.0</em>, <em>shear=0.0</em>, <em>order=&lt;MagicMock id='2229567528464'&gt;</em>, <em>cval=0</em>, <em>mode=&lt;MagicMock id='2229567538232'&gt;</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#AffineCv2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.AffineCv2" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter to apply affine transformations to images using cv2 (i.e. opencv)
backend.</p>
<p>NOTE: This augmenter will likely be removed in the future as Affine() already
offers a cv2 backend (use <cite>backend=”cv2”</cite>).</p>
<p>Affine transformations
involve:</p>
<blockquote>
<div><ul class="simple">
<li>Translation (“move” image on the x-/y-axis)</li>
<li>Rotation</li>
<li>Scaling (“zoom” in/out)</li>
<li>Shear (move one side of the image, turning a square into a trapezoid)</li>
</ul>
</div></blockquote>
<p>All such transformations can create “new” pixels in the image without a
defined content, e.g. if the image is translated to the left, pixels
are created on the right.
A method has to be defined to deal with these pixel values. The
parameters <cite>cval</cite> and <cite>mode</cite> of this class deal with this.</p>
<p>Some transformations involve interpolations between several pixels
of the input image to generate output pixel values. The parameter <cite>order</cite>
deals with the method of interpolation used for this.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>scale</strong> (<em>float or tuple of two floats or StochasticParameter or dict {“x”: float/tuple/StochasticParameter, “y”: float/tuple/StochasticParameter}, optional(default=1.0)</em>) – Scaling factor to use, where 1.0 represents no change and 0.5 is
zoomed out to 50 percent of the original size.</p>
<blockquote>
<div><ul class="simple">
<li>If a single float, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled from the range
a &lt;= x &lt;= b per image. That value will be used identically for
both x- and y-axis.</li>
<li>If a StochasticParameter, then from that parameter a value will
be sampled per image (again, used for both x- and y-axis).</li>
<li>If a dictionary, then it is expected to have the keys “x” and/or “y”.
Each of these keys can have the same values as described before
for this whole parameter (<cite>scale</cite>). Using a dictionary allows to
set different values for the axis. If they are set to the same
ranges, different values may still be sampled per axis.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>translate_percent</strong> (<em>float or tuple of two floats or StochasticParameter or dict {“x”: float/tuple/StochasticParameter, “y”: float/tuple/StochasticParameter}, optional(default=1.0)</em>) – Translation in percent relative to the image
height/width (x-translation, y-translation) to use,
where 0 represents no change and 0.5 is half of the image
height/width.</p>
<blockquote>
<div><ul class="simple">
<li>If a single float, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled from the range
a &lt;= x &lt;= b per image. That percent value will be used identically
for both x- and y-axis.</li>
<li>If a StochasticParameter, then from that parameter a value will
be sampled per image (again, used for both x- and y-axis).</li>
<li>If a dictionary, then it is expected to have the keys “x” and/or “y”.
Each of these keys can have the same values as described before
for this whole parameter (<cite>translate_percent</cite>).
Using a dictionary allows to set different values for the axis.
If they are set to the same ranges, different values may still
be sampled per axis.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>translate_px</strong> (<em>int or tuple of two ints or StochasticParameter or dict {“x”: int/tuple/StochasticParameter, “y”: int/tuple/StochasticParameter}, optional(default=1.0)</em>) – Translation in
pixels.</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled from the discrete
range [a .. b] per image. That number will be used identically
for both x- and y-axis.</li>
<li>If a StochasticParameter, then from that parameter a value will
be sampled per image (again, used for both x- and y-axis).</li>
<li>If a dictionary, then it is expected to have the keys “x” and/or “y”.
Each of these keys can have the same values as described before
for this whole parameter (<cite>translate_px</cite>).
Using a dictionary allows to set different values for the axis.
If they are set to the same ranges, different values may still
be sampled per axis.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>rotate</strong> (<em>float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)</em>) – Rotation in degrees (NOT radians), i.e. expected value range is
0 to 360 for positive rotations (may also be negative).</p>
<blockquote>
<div><ul class="simple">
<li>If a float/int, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled per image from the
range a &lt;= x &lt;= b and be used as the rotation value.</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the rotation value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>shear</strong> (<em>float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)</em>) – Shear in degrees (NOT radians), i.e. expected value range is
0 to 360 for positive shear (may also be negative).</p>
<blockquote>
<div><ul class="simple">
<li>If a float/int, then that value will be used for all images.</li>
<li>If a tuple (a, b), then a value will be sampled per image from the
range a &lt;= x &lt;= b and be used as the rotation value.</li>
<li>If a StochasticParameter, then this parameter will be used to
sample the shear value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>order</strong> (<em>int or iterable of int or string or iterable of string or ia.ALL or StochasticParameter, optional(default=1)</em>) –</p>
<dl class="docutils">
<dt>Interpolation order to use. Allowed are:</dt>
<dd><ul class="first last simple">
<li>cv2.INTER_NEAREST - a nearest-neighbor interpolation</li>
<li>cv2.INTER_LINEAR - a bilinear interpolation (used by default)</li>
<li>cv2.INTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhood</li>
<li>cv2.INTER_LANCZOS4</li>
<li>“nearest”</li>
<li>“linear”</li>
<li>“cubic”,</li>
<li>“lanczos4”</li>
</ul>
</dd>
</dl>
<p>The first four are OpenCV constants, the other four are strings that
are automatically replaced by the OpenCV constants.
INTER_NEAREST (nearest neighbour interpolation) and INTER_NEAREST
(linear interpolation) are the fastest.</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that order will be used for all images.</li>
<li>If a string, then it must be one of: “nearest”, “linear”, “cubic”,
“lanczos4”.</li>
<li>If an iterable of int/string, then for each image a random value
will be sampled from that iterable (i.e. list of allowed order
values).</li>
<li>If ia.ALL, then equivalant to list [cv2.INTER_NEAREST,
cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_LANCZOS4].</li>
<li>If StochasticParameter, then that parameter is queried per image
to sample the order value to use.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>cval</strong> (<em>number or tuple of two number or ia.ALL or StochasticParameter, optional(default=0)</em>) – The constant value used for skimage’s transform function.
This is the value used to fill up pixels in the result image that
didn’t exist in the input image (e.g. when translating to the left,
some new pixels are created at the right). Such a fill-up with a
constant value only happens, when <cite>mode</cite> is “constant”.
For standard uint8 images (value range 0-255), this value may also
come from the range 0-255. It may be a float value, even for
integer image dtypes.</p>
<blockquote>
<div><ul class="simple">
<li>If this is a single int or float, then that value will be used
(e.g. 0 results in black pixels).</li>
<li>If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b
is picked per image.</li>
<li>If ia.ALL, a value from the discrete range [0 .. 255] will be
sampled per image.</li>
<li>If a StochasticParameter, a new value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>mode</strong> (<em>int or string or list of string or list of ints or ia.ALL or StochasticParameter, optional(default=”constant”)</em>) – Parameter that defines the handling of newly created pixels.
Same meaning as in opencv’s border mode. Let <cite>abcdefgh</cite> be an image
content and <cite>|</cite> be an image boundary, then:</p>
<blockquote>
<div><ul class="simple">
<li><cite>cv2.BORDER_REPLICATE</cite>: <cite>aaaaaa|abcdefgh|hhhhhhh</cite></li>
<li><cite>cv2.BORDER_REFLECT</cite>: <cite>fedcba|abcdefgh|hgfedcb</cite></li>
<li><cite>cv2.BORDER_REFLECT_101</cite>: <cite>gfedcb|abcdefgh|gfedcba</cite></li>
<li><cite>cv2.BORDER_WRAP</cite>: <cite>cdefgh|abcdefgh|abcdefg</cite></li>
<li><cite>cv2.BORDER_CONSTANT</cite>: <cite>iiiiii|abcdefgh|iiiiiii</cite>, where <cite>i</cite> is
the defined cval.</li>
<li>“replicate”: Same as cv2.BORDER_REPLICATE.</li>
<li>“reflect”: Same as cv2.BORDER_REFLECT.</li>
<li>“reflect_101”: Same as cv2.BORDER_REFLECT_101.</li>
<li>“wrap”: Same as cv2.BORDER_WRAP.</li>
<li>“constant”: Same as cv2.BORDER_CONSTANT.</li>
</ul>
</div></blockquote>
<p>The datatype of the parameter may
be:</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then it must be one of <cite>cv2.BORDER_*</cite>.</li>
<li>If a single string, then it must be one of: “replicate”,
“reflect”, “reflect_101”, “wrap”, “constant”.</li>
<li>If a list of ints/strings, then per image a random mode will be
picked from that list.</li>
<li>If ia.ALL, then a random mode from all possible modes will be
picked.</li>
<li>If StochasticParameter, then the mode will be sampled from that
parameter per image, i.e. it must return only the above mentioned
strings.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
</pre></div>
</div>
<p>zooms all images by a factor of 2.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p>translates all images on the x- and y-axis by 16 pixels (to the
right/top), fills up any new pixels with zero (black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_percent</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>translates all images on the x- and y-axis by 10 percent of their
width/height (to the right/top), fills up any new pixels with zero
(black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">rotate</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
</pre></div>
</div>
<p>rotates all images by 35 degrees, fills up any new pixels with zero
(black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">shear</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
</pre></div>
</div>
<p>rotates all images by 15 degrees, fills up any new pixels with zero
(black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
</pre></div>
</div>
<p>translates all images on the x- and y-axis by a random value
between -16 and 16 pixels (to the right/top) (same for both axis, i.e.
sampled once per image), fills up any new pixels with zero (black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">16</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)})</span>
</pre></div>
</div>
<p>translates all images on the x-axis by a random value
between -16 and 16 pixels (to the right) and on the y-axis by a
random value between -4 and 4 pixels to the top. Even if both ranges
were the same, both axis could use different samples.
Fills up any new pixels with zero (black values).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
<p>same as previously, but uses (randomly) either nearest neighbour
interpolation or linear interpolation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
</pre></div>
</div>
<p>same as previously, but fills up any new pixels with a random
brightness (same for the whole image).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AffineCv2</span><span class="p">(</span><span class="n">translate_px</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;replicate&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>same as previously, but fills up the new pixels in only 50 percent
of all images with black values. In the other 50 percent of all cases,
the value of the closest edge is used.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.geometric.AffineCv2.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#AffineCv2.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.AffineCv2.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.geometric.ElasticTransformation">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.geometric.</code><code class="descname">ElasticTransformation</code><span class="sig-paren">(</span><em>alpha=0</em>, <em>sigma=0</em>, <em>order=3</em>, <em>cval=0</em>, <em>mode='constant'</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#ElasticTransformation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.ElasticTransformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter to transform images by moving pixels locally around using
displacement fields.</p>
<dl class="docutils">
<dt>See</dt>
<dd>Simard, Steinkraus and Platt
Best Practices for Convolutional Neural Networks applied to Visual
Document Analysis
in Proc. of the International Conference on Document Analysis and
Recognition, 2003</dd>
</dl>
<p>for a detailed explanation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>alpha</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Strength of the distortion field. Higher values mean more “movement” of
pixels.</p>
<blockquote>
<div><ul class="simple">
<li>If float, then that value will be used for all images.</li>
<li>If tuple (a, b), then a random value from range a &lt;= x &lt;= b will be
sampled per image.</li>
<li>If a list, then for each image a random value will be sampled
from that list.</li>
<li>If StochasticParameter, then that parameter will be used to sample
a value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>sigma</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Standard deviation of the gaussian kernel used to smooth the distortion
fields.</p>
<blockquote>
<div><ul class="simple">
<li>If float, then that value will be used for all images.</li>
<li>If tuple (a, b), then a random value from range a &lt;= x &lt;= b will be
sampled per image.</li>
<li>If a list, then for each image a random value will be sampled
from that list.</li>
<li>If StochasticParameter, then that parameter will be used to sample
a value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>order</strong> (<em>int or iterable of int or ia.ALL or StochasticParameter, optional(default=1)</em>) – Interpolation order to use. Same meaning as in
<cite>scipy.ndimage.map_coordinates</cite> and may take any integer value
in the range 0 to 5, where orders close to 0 are faster.</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that order will be used for all images.</li>
<li>If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b
is picked per image.</li>
<li>If a list, then for each image a random value will be sampled
from that list.</li>
<li>If ia.ALL, then equivalant to list [0, 1, 2, 3, 4, 5].</li>
<li>If StochasticParameter, then that parameter is queried per image
to sample the order value to use.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>cval</strong> (<em>number or tuple of two number or ia.ALL or StochasticParameter, optional(default=0)</em>) – The constant intensity value used to fill in new pixels.
This value is only used if <cite>mode</cite> is set to “constant”.
For standard uint8 images (value range 0-255), this value may also
come from the range 0-255. It may be a float value, even for
integer image dtypes.</p>
<blockquote>
<div><ul class="simple">
<li>If this is a single int or float, then that value will be used
(e.g. 0 results in black pixels).</li>
<li>If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b
is picked per image.</li>
<li>If a list, then a random value will be picked from that list per
image.</li>
<li>If ia.ALL, a value from the discrete range [0 .. 255] will be
sampled per image.</li>
<li>If a StochasticParameter, a new value will be sampled from the
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>mode</strong> (<em>string or list of string or ia.ALL or StochasticParameter, optional(default=”constant”)</em>) – Parameter that defines the handling of newly created pixels.
May take the same values as in <cite>scipy.ndimage.map_coordinates</cite>,
i.e. “constant”, “nearest”, “reflect” or “wrap”.
The datatype of the parameter may
be:</p>
<blockquote>
<div><ul class="simple">
<li>If a single string, then that mode will be used for all images.</li>
<li>If a list of strings, then per image a random mode will be picked
from that list.</li>
<li>If ia.ALL, then a random mode from all possible modes will be
picked.</li>
<li>If StochasticParameter, then the mode will be sampled from that
parameter per image, i.e. it must return only the above mentioned
strings.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">ElasticTransformation</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
</pre></div>
</div>
<p>apply elastic transformations with a strength/alpha of 0.5 and
smoothness of 0.25 to all images.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">ElasticTransformation</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">),</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
</pre></div>
</div>
<p>apply elastic transformations with a strength/alpha that comes
from the range 0.25 &lt;= x &lt;= 3.0 (randomly picked per image) and
smoothness of 0.25.</p>
<p class="rubric">Methods</p>
<dl class="staticmethod">
<dt id="imgaug.augmenters.geometric.ElasticTransformation.generate_indices">
<em class="property">static </em><code class="descname">generate_indices</code><span class="sig-paren">(</span><em>shape</em>, <em>alpha</em>, <em>sigma</em>, <em>random_state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#ElasticTransformation.generate_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.ElasticTransformation.generate_indices" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.geometric.ElasticTransformation.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#ElasticTransformation.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.ElasticTransformation.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="imgaug.augmenters.geometric.ElasticTransformation.map_coordinates">
<em class="property">static </em><code class="descname">map_coordinates</code><span class="sig-paren">(</span><em>image</em>, <em>indices_x</em>, <em>indices_y</em>, <em>order=1</em>, <em>cval=0</em>, <em>mode='constant'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#ElasticTransformation.map_coordinates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.ElasticTransformation.map_coordinates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.geometric.PerspectiveTransform">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.geometric.</code><code class="descname">PerspectiveTransform</code><span class="sig-paren">(</span><em>scale=0</em>, <em>keep_size=True</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#PerspectiveTransform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.PerspectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter that performs a random four point perspective transform.</p>
<p>Each of the four points is placed on the image using a random distance from
its respective corner. The distance is sampled from a normal distribution.
As a result, most transformations don’t change very much, while some
“focus” on polygons far inside the image.</p>
<p>The results of this augmenter have some similarity with Crop.</p>
<p>Code partially from <a class="reference external" href="http://www.pyimagesearch.com/2014/08/25/4-point-opencv-getperspective-transform-example/">http://www.pyimagesearch.com/2014/08/25/4-point-opencv-getperspective-transform-example/</a> .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>scale</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Standard deviation of the normal distributions. These are used to sample
the random distances of the subimage’s corners from the full image’s
corners. The sampled values reflect percentage values (with respect
to image height/width). Recommended values are in the range 0.0 to 0.1.</p>
<blockquote>
<div><ul class="simple">
<li>If a single float, then that value will always be used as the
scale.</li>
<li>If a tuple (a, b) of floats, then a random value will be picked
from the interval (a, b) (per image).</li>
<li>If a list of values, a random one of the values will be picked
per image.</li>
<li>If a StochasticParameter, then that parameter will be queried to
draw one value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>keep_size</strong> (<em>bool, optional(default=True)</em>) – Whether to resize image’s back to their original size after applying
the perspective transform. If set to False, the resulting images
may end up having different shapes and will always be a list, never
an array.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">PerspectiveTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">))</span>
</pre></div>
</div>
<p>Applies perspective transformations using a random scale between 0.01 and
0.1 per image, where the scale is roughly a measure of how far the
perspective transform’s corner points may be distanced from the original
image’s corner points.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.geometric.PerspectiveTransform.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#PerspectiveTransform.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.PerspectiveTransform.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.geometric.PiecewiseAffine">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.geometric.</code><code class="descname">PiecewiseAffine</code><span class="sig-paren">(</span><em>scale=0</em>, <em>nb_rows=4</em>, <em>nb_cols=4</em>, <em>order=1</em>, <em>cval=0</em>, <em>mode='constant'</em>, <em>absolute_scale=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#PiecewiseAffine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.PiecewiseAffine" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter that places a regular grid of points on an image and randomly
moves the neighbourhood of these point around via affine transformations.
This leads to local distortions.</p>
<p>This is mostly a wrapper around scikit-image’s PiecewiseAffine.
See also the Affine augmenter for a similar technique.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>scale</strong> (<em>float or tuple of two floats or StochasticParameter, optional(default=0)</em>) – Each point on the regular grid is moved around via a normal
distribution. This scale factor is equivalent to the normal
distribution’s sigma. Note that the jitter (how far each point is
moved in which direction) is multiplied by the height/width of the
image if <cite>absolute_scale=False</cite> (default), so this scale can be
the same for different sized images.
Recommended values are in the range 0.01 to 0.05 (weak to strong
augmentations).</p>
<blockquote>
<div><ul class="simple">
<li>If a single float, then that value will always be used as the
scale.</li>
<li>If a tuple (a, b) of floats, then a random value will be picked
from the interval (a, b) (per image).</li>
<li>If a list, then a random value will be sampled from that list
per image.</li>
<li>If a StochasticParameter, then that parameter will be queried to
draw one value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>nb_rows</strong> (<em>int or tuple of ints or StochasticParameter, optional(default=4)</em>) – Number of rows of points that the regular grid should have.
Must be at least 2. For large images, you might want to pick a
higher value than 4. You might have to then adjust scale to lower
values.</p>
<blockquote>
<div><ul class="simple">
<li>If a single int, then that value will always be used as the
number of rows.</li>
<li>If a tuple (a, b), then a value from the discrete interval [a..b]
will be sampled per image.</li>
<li>If a list, then a random value will be sampled from that list
per image.</li>
<li>If a StochasticParameter, then that parameter will be queried to
draw one value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>nb_cols</strong> (<em>int or tuple of ints or StochasticParameter, optional(default=4)</em>) – Number of columns. See <cite>nb_rows</cite>.</p>
</li>
<li><p class="first"><strong>order</strong> (<em>int or iterable of int or ia.ALL or StochasticParameter, optional(default=1)</em>) – See Affine.__init__().</p>
</li>
<li><p class="first"><strong>cval</strong> (<em>int or float or tuple of two floats or ia.ALL or StochasticParameter, optional(default=0)</em>) – See Affine.__init__().</p>
</li>
<li><p class="first"><strong>mode</strong> (<em>string or list of string or ia.ALL or StochasticParameter, optional(default=”constant”)</em>) – See Affine.__init__().</p>
</li>
<li><p class="first"><strong>absolute_scale</strong> (<em>bool, optional(default=False)</em>) – Take <cite>scale</cite> as an absolute value rather than a relative value.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">PiecewiseAffine</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">))</span>
</pre></div>
</div>
<p>Puts a grid of points on each image and then randomly moves each point
around by 1 to 5 percent (with respect to the image height/width). Pixels
between these points will be moved accordingly.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">PiecewiseAffine</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span> <span class="n">nb_rows</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">nb_cols</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as the previous example, but uses a denser grid of 8x8 points (default
is 4x4). This can be useful for large images.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.geometric.PiecewiseAffine.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/geometric.html#PiecewiseAffine.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.geometric.PiecewiseAffine.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.overlay">
<span id="augmenters-overlay"></span><h2>augmenters.overlay<a class="headerlink" href="#module-imgaug.augmenters.overlay" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that overlay two images with each other.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<p>and then e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Alpha</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">((</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
<span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>Alpha</li>
<li>AlphaElementwise</li>
<li>SimplexNoiseAlpha</li>
<li>FrequencyNoiseAlpha</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="imgaug.augmenters.overlay.Alpha">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.overlay.</code><code class="descname">Alpha</code><span class="sig-paren">(</span><em>factor=0</em>, <em>first=None</em>, <em>second=None</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/overlay.html#Alpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.overlay.Alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter to overlay two image sources with each other using an
alpha/transparency value.</p>
<p>The image sources can be imagined as branches.
If a source is not given, it is automatically the same as the input.
Let A be the first branch and B be the second branch.
Then the result images are defined as</p>
<blockquote>
<div>factor * A + (1-factor) * B,</div></blockquote>
<p>where <cite>factor</cite> is an overlay factor.</p>
<p>For keypoint augmentation this augmenter will pick the keypoints either
from the first or the second branch. The first one is picked if
<cite>factor &gt;= 0.5</cite> is true (per image). It is recommended to <em>not</em> use
augmenters that change keypoint positions with this class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>factor</strong> (<em>int or float or iterable of two floats or StochasticParameter, optional(default=0)</em>) – Weighting of the results of the first branch. Values close to 0 mean
that the results from the second branch (see parameter <cite>second</cite>)
make up most of the final image.</p>
<blockquote>
<div><ul class="simple">
<li>If float, then that value will be used for all images.</li>
<li>If tuple (a, b), then a random value from range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If StochasticParameter, then that parameter will be used to
sample a value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>first</strong> (<em>None or Augmenter or iterable of Augmenter, optional(default=None)</em>) – Augmenter(s) that make up the first of the two
branches.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then the input images will be reused as the output
of the first branch.</li>
<li>If Augmenter, then that augmenter will be used as the branch.</li>
<li>If iterable of Augmenter, then that iterable will be converted
into a Sequential and used as the augmenter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>second</strong> (<em>None or Augmenter or iterable of Augmenter, optional(default=None)</em>) – Augmenter(s) that make up the second of the two
branches.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then the input images will be reused as the output
of the second branch.</li>
<li>If Augmenter, then that augmenter will be used as the branch.</li>
<li>If iterable of Augmenter, then that iterable will be converted
into a Sequential and used as the augmenter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same factor for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Alpha</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Grayscale</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Converts each image to grayscale and overlays it by 50 percent with the
original image, thereby removing about 50 percent of all color. This
is equivalent to iaa.Grayscale(0.5).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Alpha</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Grayscale</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Converts each image to grayscale and overlays it by a random percentage
(sampled per image) with the original image, thereby removing a random
percentage of all colors. This is equivalent to iaa.Grayscale((0.0, 1.0)).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Alpha</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">rotate</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)),</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Rotates each image by a random degree from the range [-20, 20]. Then
overlays that new image with the original one by a random factor from the
range [0.0, 1.0]. In 50 percent of all cases, the overlay happens
channel-wise and the factor is sampled independently per channel. As a
result, e.g. the red channel may look visible rotated (factor near 1.0),
while the green and blue channels may not look rotated (factors near 0.0).
NOTE: It is not recommended to use Alpha with augmenters that change the
positions of pixels if you <em>also</em> want to augment keypoints, as it is
unclear which of the two keypoint results (first or second branch) should
be used as the final result.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Alpha</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">first</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">second</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">Multiply</span><span class="p">(</span><span class="mf">0.8</span><span class="p">))</span>
</pre></div>
</div>
<p>(A) Adds 10 to each image and (B) multiplies each image by 0.8. Then per
image an overlay factor is sampled from the range [0.0, 1.0]. If it is
close to 1.0, the results from (A) are mostly used, otherwise the ones
from (B). This is equivalent to
<cite>iaa.Sequential([iaa.Multiply(0.8), iaa.Alpha((0.0, 1.0), iaa.Add(10))])</cite>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Alpha</span><span class="p">(</span><span class="n">iap</span><span class="o">.</span><span class="n">Choice</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]),</span> <span class="n">iaa</span><span class="o">.</span><span class="n">MedianBlur</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
</pre></div>
</div>
<p>Applies a random median blur to each image and overlays the result with
the original image by either 25 or 75 percent strength.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.overlay.Alpha.get_children_lists">
<code class="descname">get_children_lists</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/overlay.html#Alpha.get_children_lists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.overlay.Alpha.get_children_lists" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="imgaug.augmenters.overlay.Alpha.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/overlay.html#Alpha.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.overlay.Alpha.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.overlay.AlphaElementwise">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.overlay.</code><code class="descname">AlphaElementwise</code><span class="sig-paren">(</span><em>factor=0</em>, <em>first=None</em>, <em>second=None</em>, <em>per_channel=False</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/overlay.html#AlphaElementwise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.overlay.AlphaElementwise" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.overlay.Alpha" title="imgaug.augmenters.overlay.Alpha"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.overlay.Alpha</span></code></a></p>
<p>Augmenter to overlay two image sources with each other using pixelwise
alpha values.</p>
<p>This is the same as <cite>Alpha</cite>, except that the transparency factor is
sampled per pixel instead of once per image (or a few times per image, if
per_channel is True).</p>
<p>See <cite>Alpha</cite> for more description.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>factor</strong> (<em>float or iterable of two floats or StochasticParameter, optional(default=0)</em>) – Weighting of the results of the first branch. Values close to 0 mean
that the results from the second branch (see parameter <cite>second</cite>)
make up most of the final image.</p>
<blockquote>
<div><ul class="simple">
<li>If float, then that value will be used for all images.</li>
<li>If tuple (a, b), then a random value from range a &lt;= x &lt;= b will
be sampled per image.</li>
<li>If StochasticParameter, then that parameter will be used to
sample a value per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>first</strong> (<em>None or Augmenter or iterable of Augmenter, optional(default=None)</em>) – Augmenter(s) that make up the first of the two
branches.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then the input images will be reused as the output
of the first branch.</li>
<li>If Augmenter, then that augmenter will be used as the branch.</li>
<li>If iterable of Augmenter, then that iterable will be converted
into a Sequential and used as the augmenter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>second</strong> (<em>None or Augmenter or iterable of Augmenter, optional(default=None)</em>) – Augmenter(s) that make up the second of the two
branches.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then the input images will be reused as the output
of the second branch.</li>
<li>If Augmenter, then that augmenter will be used as the branch.</li>
<li>If iterable of Augmenter, then that iterable will be converted
into a Sequential and used as the augmenter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same factor for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AlphaElementwise</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Grayscale</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Converts each image to grayscale and overlays it by 50 percent with the
original image, thereby removing about 50 percent of all color. This
is equivalent to iaa.Grayscale(0.5). This is also equivalent to
iaa.Alpha(0.5, iaa.Grayscale(1.0)), as the transparency factor is the
same for all pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AlphaElementwise</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Grayscale</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Converts each image to grayscale and overlays it by a random percentage
(sampled per pixel) with the original image, thereby removing a random
percentage of all colors per pixel.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AlphaElementwise</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Affine</span><span class="p">(</span><span class="n">rotate</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)),</span> <span class="n">per_channel</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Rotates each image by a random degree from the range [-20, 20]. Then
overlays that new image with the original one by a random factor from the
range [0.0, 1.0], sampled per pixel. In 50 percent of all cases, the
overlay happens channel-wise and the factor is sampled independently per
channel. As a result, e.g. the red channel may look visible rotated (factor
near 1.0), while the green and blue channels may not look rotated (factors
near 0.0). NOTE: It is not recommended to use Alpha with augmenters that
change the positions of pixels if you <em>also</em> want to augment keypoints, as
it is unclear which of the two keypoint results (first or second branch)
should be used as the final result.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AlphaElementwise</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">first</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="n">second</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">Multiply</span><span class="p">(</span><span class="mf">0.8</span><span class="p">))</span>
</pre></div>
</div>
<p>(A) Adds 10 to each image and (B) multiplies each image by 0.8. Then per
pixel an overlay factor is sampled from the range [0.0, 1.0]. If it is
close to 1.0, the results from (A) are mostly used, otherwise the ones
from (B).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">AlphaElementwise</span><span class="p">(</span><span class="n">iap</span><span class="o">.</span><span class="n">Choice</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]),</span> <span class="n">iaa</span><span class="o">.</span><span class="n">MedianBlur</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">)))</span>
</pre></div>
</div>
<p>Applies a random median blur to each image and overlays the result with
the original image by either 25 or 75 percent strength (sampled per pixel).</p>
<p class="rubric">Methods</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.overlay.FrequencyNoiseAlpha">
<code class="descclassname">imgaug.augmenters.overlay.</code><code class="descname">FrequencyNoiseAlpha</code><span class="sig-paren">(</span><em>exponent=(-4, 4), first=None, second=None, per_channel=False, size_px_max=(4, 16), upscale_method=None, iterations=(1, 3), aggregation_method=['avg', 'max'], sigmoid=0.5, sigmoid_thresh=None, name=None, deterministic=False, random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/overlay.html#FrequencyNoiseAlpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.overlay.FrequencyNoiseAlpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter to overlay two image sources with each other using alpha values
that follow noisy patterns.</p>
<p>The alpha masks are sampled using frequency noise of varying scales,
which can sometimes create large connected blobs of 1s surrounded by 0s
and other times results in smaller patterns. If nearest neighbour
upsampling is used, these blobs can be rectangular with sharp edges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>exponent</strong> (<em>number or tuple of numbers of list of numbers or StochasticParameter, optional(default=(-4, 4))</em>) – Exponent to use when scaling in the frequency domain.
Sane values are in the range -4 (large blobs) to 4 (small patterns).
To generate cloud-like structures, use roughly -2.</p>
<blockquote>
<div><ul class="simple">
<li>If number, then that number will be used as the exponent for all
iterations.</li>
<li>If tuple of two numbers (a, b), then a value will be sampled
per iteration from the range [a, b].</li>
<li>If a list of numbers, then a value will be picked per iteration
at random from that list.</li>
<li>If a StochasticParameter, then a value will be sampled from
that parameter per iteration.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>first</strong> (<em>None or Augmenter or iterable of Augmenter, optional(default=None)</em>) – Augmenter(s) that make up the first of the two
branches.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then the input images will be reused as the output
of the first branch.</li>
<li>If Augmenter, then that augmenter will be used as the branch.</li>
<li>If iterable of Augmenter, then that iterable will be converted
into a Sequential and used as the augmenter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>second</strong> (<em>None or Augmenter or iterable of Augmenter, optional(default=None)</em>) – Augmenter(s) that make up the second of the two
branches.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then the input images will be reused as the output
of the second branch.</li>
<li>If Augmenter, then that augmenter will be used as the branch.</li>
<li>If iterable of Augmenter, then that iterable will be converted
into a Sequential and used as the augmenter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same factor for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>size_px_max</strong> (<em>int or tuple of ints or list of ints or StochasticParameter, optional(default=(4, 16))</em>) – The noise is generated in a low resolution environment.
This parameter defines the maximum size of that environment (in
pixels). The environment is initialized at the same size as the input
image and then downscaled, so that no side exceeds <cite>size_px_max</cite>
(aspect ratio is kept).</p>
<blockquote>
<div><ul class="simple">
<li>If int, then that number will be used as the size for all
iterations.</li>
<li>If tuple of two ints (a, b), then a value will be sampled
per iteration from the discrete range [a..b].</li>
<li>If a list of ints, then a value will be picked per iteration at
random from that list.</li>
<li>If a StochasticParameter, then a value will be sampled from
that parameter per iteration.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>upscale_method</strong> (<em>None or ia.ALL or string or list of string or StochasticParameter, optional(default=None)</em>) – After generating the noise maps in low resolution environments, they
have to be upscaled to the input image size. This parameter controls
the upscaling method.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then either ‘nearest’ or ‘linear’ or ‘cubic’ is picked.
Most weight is put on linear, followed by cubic.</li>
<li>If ia.ALL, then either ‘nearest’ or ‘linear’ or ‘area’ or ‘cubic’
is picked per iteration (all same probability).</li>
<li>If string, then that value will be used as the method (must be
‘nearest’ or ‘linear’ or ‘area’ or ‘cubic’).</li>
<li>If list of string, then a random value will be picked from that
list per iteration.</li>
<li>If StochasticParameter, then a random value will be sampled
from that parameter per iteration.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>iterations</strong> (<em>int or tuple of ints or list of ints or StochasticParameter, optional(default=(1, 3))</em>) – How often to repeat the simplex noise generation process per
image.</p>
<blockquote>
<div><ul class="simple">
<li>If int, then that number will be used as the iterations for all
images.</li>
<li>If tuple of two ints (a, b), then a value will be sampled
per image from the discrete range [a..b].</li>
<li>If a list of ints, then a value will be picked per image at
random from that list.</li>
<li>If a StochasticParameter, then a value will be sampled from
that parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>aggregation_method</strong> (<em>ia.ALL or string or list of string or StochasticParameter, optional(default=[“avg”, “max”])</em>) – The noise maps (from each iteration) are combined to one noise map
using an aggregation process. This parameter defines the method used
for that process. Valid methods are ‘min’, ‘max’ or ‘avg’,
where ‘min’ combines the noise maps by taking the (elementwise) minimum
over all iteration’s results, ‘max’ the (elementwise) maximum and
‘avg’ the (elemtwise) average.</p>
<blockquote>
<div><ul class="simple">
<li>If ia.ALL, then a random value will be picked per image from the
valid ones.</li>
<li>If a string, then that value will always be used as the method.</li>
<li>If a list of string, then a random value will be picked from
that list per image.</li>
<li>If a StochasticParameter, then a random value will be sampled
from that paramter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>sigmoid</strong> (<em>bool or number, optional(default=0.5)</em>) – Whether to apply a sigmoid function to the final noise maps, resulting
in maps that have more extreme values (close to 0.0 or 1.0).</p>
<blockquote>
<div><ul class="simple">
<li>If bool, then a sigmoid will always (True) or never (False) be
applied.</li>
<li>If a number p with 0&lt;=p&lt;=1, then a sigmoid will be applied to
p percent of all final noise maps.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>sigmoid_thresh</strong> (<em>None or number or tuple of number or StochasticParameter, optional(default=None)</em>) – Threshold of the sigmoid, when applied. Thresholds above zero
(e.g. 5.0) will move the saddle point towards the right, leading to
more values close to 0.0.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then Normal(0, 5.0) will be used.</li>
<li>If number, then that threshold will be used for all images.</li>
<li>If tuple of two numbers (a, b), then a random value will
be sampled per image from the range [a, b].</li>
<li>If StochasticParameter, then a random value will be sampled from
that parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">FrequencyNoiseAlpha</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">EdgeDetect</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Detects per image all edges, marks them in a black and white image and
then overlays the result with the original image using frequency noise
masks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">FrequencyNoiseAlpha</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">EdgeDetect</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">upscale_method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as the first example, but uses only (smooth) linear upscaling to
scale the frequency noise masks to the final image sizes, i.e. no nearest
neighbour upsampling is used, which would result in rectangles with hard
edges.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">FrequencyNoiseAlpha</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">EdgeDetect</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">upscale_method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">exponent</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">sigmoid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as the previous example, but also limits the exponent to -2 and
deactivates the sigmoid, resulting in cloud-like patterns without sharp
edges.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">FrequencyNoiseAlpha</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="n">iaa</span><span class="o">.</span><span class="n">EdgeDetect</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">sigmoid_thresh</span><span class="o">=</span><span class="n">iap</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Same as the first example, but uses a threshold for the sigmoid function
that is further to the right. This is more conservative, i.e. the generated
noise masks will be mostly black (values around 0.0), which means that
most of the original images (parameter/branch <cite>second</cite>) will be kept,
rather than using the results of the augmentation (parameter/branch
<cite>first</cite>).</p>
</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.overlay.SimplexNoiseAlpha">
<code class="descclassname">imgaug.augmenters.overlay.</code><code class="descname">SimplexNoiseAlpha</code><span class="sig-paren">(</span><em>first=None</em>, <em>second=None</em>, <em>per_channel=False</em>, <em>size_px_max=(2</em>, <em>16)</em>, <em>upscale_method=None</em>, <em>iterations=(1</em>, <em>3)</em>, <em>aggregation_method='max'</em>, <em>sigmoid=True</em>, <em>sigmoid_thresh=None</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/overlay.html#SimplexNoiseAlpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.overlay.SimplexNoiseAlpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter to overlay two image sources with each other using alpha values
that follow noisy patterns.</p>
<p>The alpha masks are sampled using a simplex noise method, roughly creating
connected blobs of 1s surrounded by 0s. If nearest neighbour upsampling
is used, these blobs can be rectangular with sharp edges.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>first</strong> (<em>None or Augmenter or iterable of Augmenter, optional(default=None)</em>) – Augmenter(s) that make up the first of the two
branches.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then the input images will be reused as the output
of the first branch.</li>
<li>If Augmenter, then that augmenter will be used as the branch.</li>
<li>If iterable of Augmenter, then that iterable will be converted
into a Sequential and used as the augmenter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>second</strong> (<em>None or Augmenter or iterable of Augmenter, optional(default=None)</em>) – Augmenter(s) that make up the second of the two
branches.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then the input images will be reused as the output
of the second branch.</li>
<li>If Augmenter, then that augmenter will be used as the branch.</li>
<li>If iterable of Augmenter, then that iterable will be converted
into a Sequential and used as the augmenter.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>per_channel</strong> (<em>bool or float, optional(default=False)</em>) – Whether to use the same factor for all channels (False)
or to sample a new value for each channel (True).
If this value is a float p, then for p percent of all images
<cite>per_channel</cite> will be treated as True, otherwise as False.</p>
</li>
<li><p class="first"><strong>size_px_max</strong> (<em>int or tuple of ints or list of ints or StochasticParameter, optional(default=(2, 16))</em>) – The simplex noise is always generated in a low resolution environment.
This parameter defines the maximum size of that environment (in
pixels). The environment is initialized at the same size as the input
image and then downscaled, so that no side exceeds <cite>size_px_max</cite>
(aspect ratio is kept).</p>
<blockquote>
<div><ul class="simple">
<li>If int, then that number will be used as the size for all
iterations.</li>
<li>If tuple of two ints (a, b), then a value will be sampled
per iteration from the discrete range [a..b].</li>
<li>If a list of ints, then a value will be picked per iteration at
random from that list.</li>
<li>If a StochasticParameter, then a value will be sampled from
that parameter per iteration.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>upscale_method</strong> (<em>None or ia.ALL or string or list of string or StochasticParameter, optional(default=None)</em>) – After generating the noise maps in low resolution environments, they
have to be upscaled to the input image size. This parameter controls
the upscaling method.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then either ‘nearest’ or ‘linear’ or ‘cubic’ is picked.
Most weight is put on linear, followed by cubic.</li>
<li>If ia.ALL, then either ‘nearest’ or ‘linear’ or ‘area’ or ‘cubic’
is picked per iteration (all same probability).</li>
<li>If string, then that value will be used as the method (must be
‘nearest’ or ‘linear’ or ‘area’ or ‘cubic’).</li>
<li>If list of string, then a random value will be picked from that
list per iteration.</li>
<li>If StochasticParameter, then a random value will be sampled
from that parameter per iteration.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>iterations</strong> (<em>int or tuple of ints or list of ints or StochasticParameter, optional(default=(1, 3))</em>) – How often to repeat the simplex noise generation process per
image.</p>
<blockquote>
<div><ul class="simple">
<li>If int, then that number will be used as the iterations for all
images.</li>
<li>If tuple of two ints (a, b), then a value will be sampled
per image from the discrete range [a..b].</li>
<li>If a list of ints, then a value will be picked per image at
random from that list.</li>
<li>If a StochasticParameter, then a value will be sampled from
that parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>aggregation_method</strong> (<em>ia.ALL or string or list of string or StochasticParameter, optional(default=”max”)</em>) – The noise maps (from each iteration) are combined to one noise map
using an aggregation process. This parameter defines the method used
for that process. Valid methods are ‘min’, ‘max’ or ‘avg’,
where ‘min’ combines the noise maps by taking the (elementwise) minimum
over all iteration’s results, ‘max’ the (elementwise) maximum and
‘avg’ the (elemtwise) average.</p>
<blockquote>
<div><ul class="simple">
<li>If ia.ALL, then a random value will be picked per image from the
valid ones.</li>
<li>If a string, then that value will always be used as the method.</li>
<li>If a list of string, then a random value will be picked from
that list per image.</li>
<li>If a StochasticParameter, then a random value will be sampled
from that paramter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>sigmoid</strong> (<em>bool or number, optional(default=True)</em>) – Whether to apply a sigmoid function to the final noise maps, resulting
in maps that have more extreme values (close to 0.0 or 1.0).</p>
<blockquote>
<div><ul class="simple">
<li>If bool, then a sigmoid will always (True) or never (False) be
applied.</li>
<li>If a number p with 0&lt;=p&lt;=1, then a sigmoid will be applied to
p percent of all final noise maps.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>sigmoid_thresh</strong> (<em>None or number or tuple of number or StochasticParameter, optional(default=None)</em>) – Threshold of the sigmoid, when applied. Thresholds above zero
(e.g. 5.0) will move the saddle point towards the right, leading to
more values close to 0.0.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then Normal(0, 5.0) will be used.</li>
<li>If number, then that threshold will be used for all images.</li>
<li>If tuple of two numbers (a, b), then a random value will
be sampled per image from the range [a, b].</li>
<li>If StochasticParameter, then a random value will be sampled from
that parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">SimplexNoiseAlpha</span><span class="p">(</span><span class="n">iaa</span><span class="o">.</span><span class="n">EdgeDetect</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Detects per image all edges, marks them in a black and white image and
then overlays the result with the original image using simplex noise masks.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">SimplexNoiseAlpha</span><span class="p">(</span><span class="n">iaa</span><span class="o">.</span><span class="n">EdgeDetect</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">upscale_method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Same as the first example, but uses only (smooth) linear upscaling to
scale the simplex noise masks to the final image sizes, i.e. no nearest
neighbour upsampling is used, which would result in rectangles with hard
edges.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">SimplexNoiseAlpha</span><span class="p">(</span><span class="n">iaa</span><span class="o">.</span><span class="n">EdgeDetect</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">sigmoid_thresh</span><span class="o">=</span><span class="n">iap</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">))</span>
</pre></div>
</div>
<p>Same as the first example, but uses a threshold for the sigmoid function
that is further to the right. This is more conservative, i.e. the generated
noise masks will be mostly black (values around 0.0), which means that
most of the original images (parameter/branch <cite>second</cite>) will be kept,
rather than using the results of the augmentation (parameter/branch
<cite>first</cite>).</p>
</dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.segmentation">
<span id="augmenters-segmentation"></span><h2>augmenters.segmentation<a class="headerlink" href="#module-imgaug.augmenters.segmentation" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that apply changes to images based on forms of segmentation.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<p>and then e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Superpixels</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>Superpixels</li>
</ul>
</dd>
</dl>
<dl class="class">
<dt id="imgaug.augmenters.segmentation.Superpixels">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.segmentation.</code><code class="descname">Superpixels</code><span class="sig-paren">(</span><em>p_replace=0</em>, <em>n_segments=100</em>, <em>max_size=128</em>, <em>interpolation='linear'</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/segmentation.html#Superpixels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.segmentation.Superpixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Completely or partially transform images to their superpixel representation.</p>
<p>This implementation uses skimage’s version of the SLIC algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p_replace</strong> (<em>int or float or tuple/list of ints/floats or StochasticParameter, optional(default=0)</em>) – Defines the probability of any superpixel area being replaced by the
superpixel, i.e. by the average pixel color within its area.
A probability of 0 would mean, that no superpixel area is replaced by
its average (image is not changed at all).
A probability of 0.5 would mean, that half of all superpixels are
replaced by their average color.
A probability of 1.0 would mean, that all superpixels are replaced
by their average color (resulting in a standard superpixel image).
This parameter can be a tuple (a, b), e.g. (0.5, 1.0). In this case,
a random probability p with a &lt;= p &lt;= b will be rolled per image.
If this parameter is a StochasticParameter, it is expected to return
values between 0 and 1. Values &gt;=0.5 will be interpreted as the command
to replace a superpixel region with its mean. Recommended to be some
form of Binomial(…).</li>
<li><strong>n_segments</strong> (<em>int or tuple/list of ints or StochasticParameter, optional(default=100)</em>) – Target number of superpixels to generate.
Lower numbers are faster.</li>
<li><strong>max_size</strong> (<em>int or None, optional(default=128)</em>) – Maximum image size at which the superpixels are generated.
If the width or height of an image exceeds this value, it will be
downscaled so that the longest side matches <cite>max_size</cite>.
Though, the final output (superpixel) image has the same size as the
input image.
This is done to speed up the superpixel algorithm.
Use None to apply no downscaling.</li>
<li><strong>interpolation</strong> (<em>int or string, optional(default=”linear”)</em>) – Interpolation method to use during downscaling when <cite>max_size</cite> is
exceeded. Valid methods are the same as in
<cite>ia.imresize_single_image()</cite>.</li>
<li><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></li>
<li><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Superpixels</span><span class="p">(</span><span class="n">p_replace</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>generates ~64 superpixels per image and replaces all of them with
their average color (standard superpixel image).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Superpixels</span><span class="p">(</span><span class="n">p_replace</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
<p>generates always ~64 superpixels per image and replaces half of them
with their average color, while the other half are left unchanged (i.e.
they still show the input image’s content).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Superpixels</span><span class="p">(</span><span class="n">p_replace</span><span class="o">=</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">n_segments</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
</pre></div>
</div>
<p>generates between ~16 and ~128 superpixels per image and replaces
25 to 100 percent of them with their average color.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.segmentation.Superpixels.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/segmentation.html#Superpixels.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.segmentation.Superpixels.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-imgaug.augmenters.size">
<span id="augmenters-size"></span><h2>augmenters.size<a class="headerlink" href="#module-imgaug.augmenters.size" title="Permalink to this headline">¶</a></h2>
<p>Augmenters that somehow change the size of the images.</p>
<p>Do not import directly from this file, as the categorization is not final.
Use instead</p>
<blockquote>
<div><cite>from imgaug import augmenters as iaa</cite></div></blockquote>
<p>and then e.g.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">seq</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">({</span><span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="mi">64</span><span class="p">})</span>
    <span class="n">iaa</span><span class="o">.</span><span class="n">Crop</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>List of augmenters:</dt>
<dd><ul class="first last simple">
<li>Scale</li>
<li>CropAndPad</li>
<li>Crop</li>
<li>Pad</li>
</ul>
</dd>
</dl>
<dl class="function">
<dt id="imgaug.augmenters.size.Crop">
<code class="descclassname">imgaug.augmenters.size.</code><code class="descname">Crop</code><span class="sig-paren">(</span><em>px=None</em>, <em>percent=None</em>, <em>keep_size=True</em>, <em>sample_independently=True</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/size.html#Crop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.size.Crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that crops/cuts away pixels at the sides of the image.</p>
<p>That allows to cut out subimages from given (full) input images.
The number of pixels to cut off may be defined in absolute values or
percent of the image sizes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>px</strong> (<em>None or int or StochasticParameter or tuple, optional(default=None)</em>) – The number of pixels to crop away (cut off) on each side of the image.
Either this or the parameter <cite>percent</cite> may be set, not both at the same
time.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then pixel-based cropping will not be used.</li>
<li>If int, then that exact number of pixels will always be cropped.</li>
<li>If StochasticParameter, then that parameter will be used for each
image. Four samples will be drawn per image (top, right, bottom,
left).</li>
<li>If a tuple of two ints with values a and b, then each side will
be cropped by a random amount in the range a &lt;= x &lt;= b.
x is sampled per image side.</li>
<li>If a tuple of four entries, then the entries represent top, right,
bottom, left. Each entry may be a single integer (always crop by
exactly that value), a tuple of two ints a and b (crop by an
amount a &lt;= x &lt;= b), a list of ints (crop by a random value that
is contained in the list) or a StochasticParameter (sample the
amount to crop from that parameter).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>percent</strong> (<em>None or int or float or StochasticParameter or tuple, optional(default=None)</em>) – The number of pixels to crop away (cut off) on each side of the image
given <em>in percent</em> of the image height/width.
E.g. if this is set to 0.1, the augmenter will always crop away
10 percent of the image’s height at the top, 10 percent of the width
on the right, 10 percent of the height at the bottom and 10 percent
of the width on the left.
Either this or the parameter <cite>px</cite> may be set, not both at the same
time.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then percent-based cropping will not be used.</li>
<li>If int, then expected to be 0 (no cropping).</li>
<li>If float, then that percentage will always be cropped away.</li>
<li>If StochasticParameter, then that parameter will be used for each
image. Four samples will be drawn per image (top, right, bottom,
left).</li>
<li>If a tuple of two floats with values a and b, then each side will
be cropped by a random percentage in the range a &lt;= x &lt;= b.
x is sampled per image side.</li>
<li>If a tuple of four entries, then the entries represent top, right,
bottom, left. Each entry may be a single float (always crop by
exactly that percent value), a tuple of two floats a and b (crop
by a percentage a &lt;= x &lt;= b), a list of floats (crop by a random
value that is contained in the list) or a StochasticParameter
(sample the percentage to crop from that parameter).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>keep_size</strong> (<em>bool, optional(default=True)</em>) – After cropping, the result image has a different height/width than
the input image. If this parameter is set to True, then the cropped
image will be resized to the input image’s size, i.e. the image size
is then not changed by the augmenter.</p>
</li>
<li><p class="first"><strong>sample_independently</strong> (<em>bool, optional(default=True)</em>) – If false AND the values for px/percent result in exactly one
probability distribution for the amount to crop, only one
single value will be sampled from that probability distribution
and used for all sides. I.e. the crop amount then is the same
for all sides.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Crop</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>crops each side by a random value from the range 0px to 10px (the value
is sampled per side).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Crop</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sample_independently</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>samples one value v from the discrete range [0..10] and crops all sides
by v pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Crop</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">keep_size</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>crops each side by a random value from the range 0px to 10px (the value
is sampled per side). After cropping, the images are NOT resized to their
original size (i.e. the images may end up having different heights/widths).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Crop</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
</pre></div>
</div>
<p>crops the top and bottom by a random value from the range 0px to 10px
and the left and right by a random value in the range 0px to 5px.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Crop</span><span class="p">(</span><span class="n">percent</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
</pre></div>
</div>
<p>crops each side by a random value from the range 0 percent to
10 percent. (Percent with respect to the side’s size, e.g. for the
top side it uses the image’s height.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Crop</span><span class="p">(</span><span class="n">percent</span><span class="o">=</span><span class="p">([</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]))</span>
</pre></div>
</div>
<p>crops each side by either 5 percent or 10 percent.</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.size.CropAndPad">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.size.</code><code class="descname">CropAndPad</code><span class="sig-paren">(</span><em>px=None</em>, <em>percent=None</em>, <em>pad_mode='constant'</em>, <em>pad_cval=0</em>, <em>keep_size=True</em>, <em>sample_independently=True</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/size.html#CropAndPad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.size.CropAndPad" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter that crops/pads images by defined amounts in pixels or
percent (relative to input image size).
Cropping removes pixels at the sides (i.e. extracts a subimage from
a given full image). Padding adds pixels to the sides (e.g. black pixels).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>px</strong> (<em>None or int or StochasticParameter or tuple, optional(default=None)</em>) – The number of pixels to crop (negative values) or
pad (positive values) on each side of the image.
Either this or the parameter <cite>percent</cite> may be set, not both at the
same time.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then pixel-based cropping will not be used.</li>
<li>If int, then that exact number of pixels will always be cropped.</li>
<li>If StochasticParameter, then that parameter will be used for each
image. Four samples will be drawn per image (top, right, bottom,
left).
If however <cite>sample_independently</cite> is set to False, only one value
will be sampled per image and used for all sides.</li>
<li>If a tuple of two ints with values a and b, then each side will
be cropped by a random amount in the range a &lt;= x &lt;= b.
x is sampled per image side.
If however <cite>sample_independently</cite> is set to False, only one value
will be sampled per image and used for all sides.</li>
<li>If a tuple of four entries, then the entries represent top, right,
bottom, left. Each entry may be a single integer (always crop by
exactly that value), a tuple of two ints a and b (crop by an
amount a &lt;= x &lt;= b), a list of ints (crop by a random value that
is contained in the list) or a StochasticParameter (sample the
amount to crop from that parameter).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>percent</strong> (<em>None or int or float or StochasticParameter or tuple, optional(default=None)</em>) – The number of pixels to crop (negative values) or
pad (positive values) on each side of the image given <em>in percent</em>
of the image height/width. E.g. if this is set to 0.1, the
augmenter will always crop away 10 percent of the image’s height at
the top, 10 percent of the width on the right, 10 percent of the
height at the bottom and 10 percent of the width on the left.
Either this or the parameter <cite>px</cite> may be set, not both at the same
time.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then percent-based cropping will not be used.</li>
<li>If int, then expected to be 0 (no padding/cropping).</li>
<li>If float, then that percentage will always be cropped away.</li>
<li>If StochasticParameter, then that parameter will be used for each
image. Four samples will be drawn per image (top, right, bottom,
left).
If however <cite>sample_independently</cite> is set to False, only one value
will be sampled per image and used for all sides.</li>
<li>If a tuple of two floats with values a and b, then each side will
be cropped by a random percentage in the range a &lt;= x &lt;= b.
x is sampled per image side.
If however <cite>sample_independently</cite> is set to False, only one value
will be sampled per image and used for all sides.</li>
<li>If a tuple of four entries, then the entries represent top, right,
bottom, left. Each entry may be a single float (always crop by
exactly that percent value), a tuple of two floats a and b (crop
by a percentage a &lt;= x &lt;= b), a list of floats (crop by a random
value that is contained in the list) or a StochasticParameter
(sample the percentage to crop from that parameter).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>pad_mode</strong> (<em>ia.ALL or string or list of strings or StochasticParameter, optional(default=”constant”)</em>) – Padding mode to use for numpy’s pad function. The available modes
are <cite>constant</cite>, <cite>edge</cite>, <cite>linear_ramp</cite>, <cite>maximum</cite>, <cite>median</cite>,
<cite>minimum</cite>, <cite>reflect</cite>, <cite>symmetric</cite>, <cite>wrap</cite>. Each one of these is
explained in the numpy documentation. The modes “constant” and
<cite>linear_ramp</cite> use extra values, which are provided by <cite>pad_cval</cite>
when necessary.</p>
<blockquote>
<div><ul class="simple">
<li>If ia.ALL, then a random mode from all available
modes will be sampled per image.</li>
<li>If a string, it will be used as the pad mode for all
images.</li>
<li>If a list of strings, a random one of these will be
sampled per image and used as the mode.</li>
<li>If StochasticParameter, a random mode will be sampled from this
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>pad_cval</strong> (<em>float or int or tuple of two ints/floats or list of ints/floats or StochasticParameter, optional(default=0)</em>) – The constant value to use (for numpy’s pad function) if the pad
mode is “constant” or the end value to use if the mode
is <cite>linear_ramp</cite>.</p>
<blockquote>
<div><ul class="simple">
<li>If float/int, then that value will be used.</li>
<li>If a tuple of two numbers and at least one of them is a float,
then a random number will be sampled from the continuous range
a&lt;=x&lt;=b and used as the value. If both numbers are integers,
the range is discrete.</li>
<li>If a list of ints/floats, then a random value will be chosen from
the elements of the list and used as the value.</li>
<li>If StochasticParameter, a random value will be sampled from that
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>keep_size</strong> (<em>bool, optional(default=True)</em>) – After cropping, the result image has a different height/width than
the input image. If this parameter is set to True, then the cropped
image will be resized to the input image’s size, i.e. the image size
is then not changed by the augmenter.</p>
</li>
<li><p class="first"><strong>sample_independently</strong> (<em>bool, optional(default=True)</em>) – If false AND the values for px/percent result in exactly one
probability distribution for the amount to crop/pad, only one
single value will be sampled from that probability distribution
and used for all sides. I.e. the crop/pad amount then is the same
for all sides.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>crops each side by a random value from the range -10px to 0px (the value
is sampled per side).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the values
are sampled per side). The padding happens by zero-padding (i.e. adds
black pixels).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the values
are sampled per side). The padding uses the ‘edge’ mode from numpy’s
pad function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">pad_mode</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the values
are sampled per side). The padding uses randomly either the ‘constant’
or ‘edge’ mode from numpy’s pad function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span> <span class="n">pad_cval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the values
are sampled per side). It uses a random mode for numpy’s pad function.
If the mode is <cite>constant</cite> or <cite>linear_ramp</cite>, it samples a random value
v from the range [0, 255] and uses that as the constant
value (<cite>mode=constant</cite>) or end value (<cite>mode=linear_ramp</cite>).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sample_independently</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>samples one value v from the discrete range [0..10] and pads all sides
by v pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">keep_size</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the value
is sampled per side). After padding, the images are NOT resized to
their original size (i.e. the images may end up having different
heights/widths).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
</pre></div>
</div>
<p>pads the top and bottom by a random value from the range 0px to 10px
and the left and right by a random value in the range 0px to 5px.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">percent</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0 percent to
10 percent. (Percent with respect to the side’s size, e.g. for the
top side it uses the image’s height.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">percent</span><span class="o">=</span><span class="p">([</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]))</span>
</pre></div>
</div>
<p>pads each side by either 5 percent or 10 percent.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">CropAndPad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>samples per side and image a value v from the discrete range [-10..10]
and either crops (negative value) or pads (positive value) the side
by v pixels.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.size.CropAndPad.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/size.html#CropAndPad.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.size.CropAndPad.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="imgaug.augmenters.size.Pad">
<code class="descclassname">imgaug.augmenters.size.</code><code class="descname">Pad</code><span class="sig-paren">(</span><em>px=None</em>, <em>percent=None</em>, <em>pad_mode='constant'</em>, <em>pad_cval=0</em>, <em>keep_size=True</em>, <em>sample_independently=True</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/size.html#Pad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.size.Pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Augmenter that pads images, i.e. adds columns/rows to them.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>px</strong> (<em>None or int or StochasticParameter or tuple, optional(default=None)</em>) – The number of pixels to crop away (cut off) on each side of the image.
Either this or the parameter <cite>percent</cite> may be set, not both at the same
time.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then pixel-based cropping will not be used.</li>
<li>If int, then that exact number of pixels will always be cropped.</li>
<li>If StochasticParameter, then that parameter will be used for each
image. Four samples will be drawn per image (top, right, bottom,
left).</li>
<li>If a tuple of two ints with values a and b, then each side will
be cropped by a random amount in the range a &lt;= x &lt;= b.
x is sampled per image side.</li>
<li>If a tuple of four entries, then the entries represent top, right,
bottom, left. Each entry may be a single integer (always crop by
exactly that value), a tuple of two ints a and b (crop by an
amount a &lt;= x &lt;= b), a list of ints (crop by a random value that
is contained in the list) or a StochasticParameter (sample the
amount to crop from that parameter).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>percent</strong> (<em>None or int or float or StochasticParameter or tuple, optional(default=None)</em>) – The number of pixels to crop away (cut off) on each side of the image
given <em>in percent</em> of the image height/width.
E.g. if this is set to 0.1, the augmenter will always crop away
10 percent of the image’s height at the top, 10 percent of the width
on the right, 10 percent of the height at the bottom and 10 percent
of the width on the left.
Either this or the parameter <cite>px</cite> may be set, not both at the same
time.</p>
<blockquote>
<div><ul class="simple">
<li>If None, then percent-based cropping will not be used.</li>
<li>If int, then expected to be 0 (no cropping).</li>
<li>If float, then that percentage will always be cropped away.</li>
<li>If StochasticParameter, then that parameter will be used for each
image. Four samples will be drawn per image (top, right, bottom,
left).</li>
<li>If a tuple of two floats with values a and b, then each side will
be cropped by a random percentage in the range a &lt;= x &lt;= b.
x is sampled per image side.</li>
<li>If a tuple of four entries, then the entries represent top, right,
bottom, left. Each entry may be a single float (always crop by
exactly that percent value), a tuple of two floats a and b (crop
by a percentage a &lt;= x &lt;= b), a list of floats (crop by a random
value that is contained in the list) or a StochasticParameter
(sample the percentage to crop from that parameter).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>pad_mode</strong> (<em>ia.ALL or string or list of strings or StochasticParameter, optional(default=”constant”)</em>) – Padding mode to use for numpy’s pad function. The available modes
are <cite>constant</cite>, <cite>edge</cite>, <cite>linear_ramp</cite>, <cite>maximum</cite>, <cite>median</cite>,
<cite>minimum</cite>, <cite>reflect</cite>, <cite>symmetric</cite>, <cite>wrap</cite>. Each one of these is
explained in the numpy documentation. The modes <cite>constant</cite> and
<cite>linear_ramp</cite> use extra values, which are provided by <cite>pad_cval</cite>
when necessary.</p>
<blockquote>
<div><ul class="simple">
<li>If ia.ALL, then a random mode from all available
modes will be sampled per image.</li>
<li>If a string, it will be used as the pad mode for all
images.</li>
<li>If a list of strings, a random one of these will be
sampled per image and used as the mode.</li>
<li>If StochasticParameter, a random mode will be sampled from this
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>pad_cval</strong> (<em>float or int or tuple of two ints/floats or list of ints/floats or StochasticParameter, optional(default=0)</em>) – The constant value to use (for numpy’s pad function) if the pad
mode is “constant” or the end value to use if the mode
is <cite>linear_ramp</cite>.</p>
<blockquote>
<div><ul class="simple">
<li>If float/int, then that value will be used.</li>
<li>If a tuple of two numbers and at least one of them is a float,
then a random number will be sampled from the continuous range
a&lt;=x&lt;=b and used as the value. If both numbers are integers,
the range is discrete.</li>
<li>If a list of ints/floats, then a random value will be chosen from
the elements of the list and used as the value.</li>
<li>If StochasticParameter, a random value will be sampled from that
parameter per image.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>keep_size</strong> (<em>bool, optional(default=True)</em>) – After cropping, the result image has a different height/width than
the input image. If this parameter is set to True, then the cropped
image will be resized to the input image’s size, i.e. the image size
is then not changed by the augmenter.</p>
</li>
<li><p class="first"><strong>sample_independently</strong> (<em>bool, optional(default=True)</em>) – If false AND the values for px/percent result in exactly one
probability distribution for the amount to crop/pad, only one
single value will be sampled from that probability distribution
and used for all sides. I.e. the crop/pad amount then is the same
for all sides.</p>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the value
is sampled per side). The added rows/columns are filled with black pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sample_independently</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>samples one value v from the discrete range [0..10] and pads all sides
by v pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">keep_size</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the value
is sampled per side). After padding, the images are NOT resized to their
original size (i.e. the images may end up having different heights/widths).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)))</span>
</pre></div>
</div>
<p>pads the top and bottom by a random value from the range 0px to 10px
and the left and right by a random value in the range 0px to 5px.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">percent</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0 percent to
10 percent. (Percent with respect to the side’s size, e.g. for the
top side it uses the image’s height.)</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">percent</span><span class="o">=</span><span class="p">([</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]))</span>
</pre></div>
</div>
<p>pads each side by either 5 percent or 10 percent.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">pad_mode</span><span class="o">=</span><span class="s2">&quot;edge&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the values
are sampled per side). The padding uses the ‘edge’ mode from numpy’s
pad function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">pad_mode</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the values
are sampled per side). The padding uses randomly either the ‘constant’
or ‘edge’ mode from numpy’s pad function.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Pad</span><span class="p">(</span><span class="n">px</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">pad_mode</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">,</span> <span class="n">pad_cval</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
</pre></div>
</div>
<p>pads each side by a random value from the range 0px to 10px (the values
are sampled per side). It uses a random mode for numpy’s pad function.
If the mode is <cite>constant</cite> or <cite>linear_ramp</cite>, it samples a random value
v from the range [0, 255] and uses that as the constant
value (<cite>mode=constant</cite>) or end value (<cite>mode=linear_ramp</cite>).</p>
</dd></dl>

<dl class="class">
<dt id="imgaug.augmenters.size.Scale">
<em class="property">class </em><code class="descclassname">imgaug.augmenters.size.</code><code class="descname">Scale</code><span class="sig-paren">(</span><em>size</em>, <em>interpolation='cubic'</em>, <em>name=None</em>, <em>deterministic=False</em>, <em>random_state=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/size.html#Scale"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.size.Scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#imgaug.augmenters.meta.Augmenter" title="imgaug.augmenters.meta.Augmenter"><code class="xref py py-class docutils literal"><span class="pre">imgaug.augmenters.meta.Augmenter</span></code></a></p>
<p>Augmenter that scales/resizes images to specified heights and widths.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last">
<li><p class="first"><strong>size</strong> (<em>string “keep” or int or float or tuple of two ints/floats or list of ints/floats or StochasticParameter or dictionary</em>) – The new size of the
images.</p>
<blockquote>
<div><ul class="simple">
<li>If this has the string value ‘keep’, the original height and
width values will be kept (image is not scaled).</li>
<li>If this is an integer, this value will always be used as the new
height and width of the images.</li>
<li>If this is a float v, then per image the image’s height H and
width W will be changed to H*v and W*v.</li>
<li>If this is a tuple, it is expected to have two entries (a, b).
If at least one of these are floats, a value will be sampled from
range [a, b] and used as the float value to resize the image
(see above). If both are integers, a value will be sampled from
the discrete range [a .. b] and used as the integer value
to resize the image (see above).</li>
<li>If this is a list, a random value from the list will be picked
to resize the image. All values in the list must be integers or
floats (no mixture is possible).</li>
<li>If this is a StochasticParameter, then this parameter will first
be queried once per image. The resulting value will be used
for both height and width.</li>
<li>If this is a dictionary, it may contain the keys “height” and
“width”. Each key may have the same datatypes as above and
describes the scaling on x and y-axis. Both axis are sampled
independently. Additionally, one of the keys may have the value
“keep-aspect-ratio”, which means that the respective side of the
image will be resized so that the original aspect ratio is kept.
This is useful when only resizing one image size by a pixel
value (e.g. resize images to a height of 64 pixels and resize
the width so that the overall aspect ratio is maintained).</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>interpolation</strong> (<em>ia.ALL or int or string or list of ints/strings or StochasticParameter, optional(default=”cubic”)</em>) – Interpolation to
use.</p>
<blockquote>
<div><ul class="simple">
<li>If ia.ALL, then a random interpolation from <cite>nearest</cite>, <cite>linear</cite>,
<cite>area</cite> or <cite>cubic</cite> will be picked (per image).</li>
<li>If int, then this interpolation will always be used.
Expected to be any of the following:
<cite>cv2.INTER_NEAREST</cite>, <cite>cv2.INTER_LINEAR</cite>, <cite>cv2.INTER_AREA</cite>,
<cite>cv2.INTER_CUBIC</cite></li>
<li>If string, then this interpolation will always be used.
Expected to be any of the following:
“nearest”, “linear”, “area”, “cubic”</li>
<li>If list of ints/strings, then a random one of the values will be
picked per image as the interpolation.
If a StochasticParameter, then this parameter will be queried per
image and is expected to return an integer or string.</li>
</ul>
</div></blockquote>
</li>
<li><p class="first"><strong>name</strong> (<em>string, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>deterministic</strong> (<em>bool, optional(default=False)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
<li><p class="first"><strong>random_state</strong> (<em>int or np.random.RandomState or None, optional(default=None)</em>) – See <cite>Augmenter.__init__()</cite></p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
</pre></div>
</div>
<p>scales all images to 32x32 pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>scales all images to 50 percent of their original size.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">((</span><span class="mi">16</span><span class="p">,</span> <span class="mi">22</span><span class="p">))</span>
</pre></div>
</div>
<p>scales all images to a random height and width within the
discrete range 16&lt;=x&lt;=22.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">((</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">))</span>
</pre></div>
</div>
<p>scales all image’s height and width to H*v and W*v, where v is randomly
sampled from the range 0.5&lt;=x&lt;=0.75.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">])</span>
</pre></div>
</div>
<p>scales all images either to 16x16, 32x32 or 64x64 pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">({</span><span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="mi">32</span><span class="p">})</span>
</pre></div>
</div>
<p>scales all images to a height of 32 pixels and keeps the original
width.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">({</span><span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="mi">48</span><span class="p">})</span>
</pre></div>
</div>
<p>scales all images to a height of 32 pixels and a width of 48.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">({</span><span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="s2">&quot;keep-aspect-ratio&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>scales all images to a height of 32 pixels and resizes the x-axis
(width) so that the aspect ratio is maintained.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">({</span><span class="s2">&quot;height&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">),</span> <span class="s2">&quot;width&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">]})</span>
</pre></div>
</div>
<p>scales all images to a height of H*v, where H is the original height
and v is a random value sampled from the range 0.5&lt;=x&lt;=0.75.
The width/x-axis of each image is resized to either 16 or 32 or
64 pixels.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">aug</span> <span class="o">=</span> <span class="n">iaa</span><span class="o">.</span><span class="n">Scale</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>scales all images to 32x32 pixels. Randomly uses either “linear”
or “cubic” interpolation.</p>
<p class="rubric">Methods</p>
<dl class="method">
<dt id="imgaug.augmenters.size.Scale.get_parameters">
<code class="descname">get_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/imgaug/augmenters/size.html#Scale.get_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#imgaug.augmenters.size.Scale.get_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-imgaug">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-imgaug" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="modules.html" class="btn btn-neutral" title="imgaug" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Alexander Jung.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.2.6',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>