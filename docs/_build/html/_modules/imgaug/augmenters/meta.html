

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>imgaug.augmenters.meta &mdash; imgaug 0.2.6 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> imgaug
          

          
          </a>

          
            
            
              <div class="version">
                0.2.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/examples_basics.html">Examples: Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/examples_keypoints.html">Examples: Keypoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/examples_bounding_boxes.html">Examples: Bounding Boxes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/parameters.html">Stochastic Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/alpha.html">Blending/Overlaying images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/augmenters.html">Overview of Augmenters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/modules.html">imgaug</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">imgaug</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>imgaug.augmenters.meta</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for imgaug.augmenters.meta</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Augmenters that don&#39;t apply augmentations themselves, but are needed</span>
<span class="sd">for meta usage.</span>

<span class="sd">Do not import directly from this file, as the categorization is not final.</span>
<span class="sd">Use instead</span>
<span class="sd">    `from imgaug import augmenters as iaa`</span>
<span class="sd">and then e.g.</span>
<span class="sd">    `seq = iaa.Sequential([...])`</span>

<span class="sd">List of augmenters:</span>
<span class="sd">    * Augmenter (base class for all augmenters)</span>
<span class="sd">    * Sequential</span>
<span class="sd">    * SomeOf</span>
<span class="sd">    * OneOf</span>
<span class="sd">    * Sometimes</span>
<span class="sd">    * WithChannels</span>
<span class="sd">    * Noop</span>
<span class="sd">    * Lambda</span>
<span class="sd">    * AssertLambda</span>
<span class="sd">    * AssertShape</span>

<span class="sd">Note that WithColorspace is in `color.py`.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">imgaug</span> <span class="k">as</span> <span class="n">ia</span>
<span class="c1"># TODO replace these imports with iap.XYZ</span>
<span class="kn">from</span> <span class="nn">..parameters</span> <span class="k">import</span> <span class="n">StochasticParameter</span><span class="p">,</span> <span class="n">Binomial</span><span class="p">,</span> <span class="n">DiscreteUniform</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">copy</span> <span class="k">as</span> <span class="nn">copy_module</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">misc</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">six.moves</span> <span class="k">as</span> <span class="nn">sm</span>
<span class="kn">import</span> <span class="nn">warnings</span>


<div class="viewcode-block" id="copy_dtypes_for_restore"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.copy_dtypes_for_restore">[docs]</a><span class="k">def</span> <span class="nf">copy_dtypes_for_restore</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">force_list</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">force_list</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">images</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">images</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span></div>


<div class="viewcode-block" id="restore_augmented_image_dtype_"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.restore_augmented_image_dtype_">[docs]</a><span class="k">def</span> <span class="nf">restore_augmented_image_dtype_</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">orig_dtype</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="restore_augmented_image_dtype"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.restore_augmented_image_dtype">[docs]</a><span class="k">def</span> <span class="nf">restore_augmented_image_dtype</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">orig_dtype</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="restore_augmented_images_dtypes_"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.restore_augmented_images_dtypes_">[docs]</a><span class="k">def</span> <span class="nf">restore_augmented_images_dtypes_</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">orig_dtypes</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_dtypes</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">orig_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span><span class="p">,</span> <span class="n">orig_dtype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">orig_dtypes</span><span class="p">)]</span></div>


<div class="viewcode-block" id="restore_augmented_images_dtypes"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.restore_augmented_images_dtypes">[docs]</a><span class="k">def</span> <span class="nf">restore_augmented_images_dtypes</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">orig_dtypes</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">restore_augmented_images_dtypes_</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">orig_dtypes</span><span class="p">)</span></div>


<div class="viewcode-block" id="clip_augmented_image_"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.clip_augmented_image_">[docs]</a><span class="k">def</span> <span class="nf">clip_augmented_image_</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">clip_augmented_images_</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">)</span></div>


<div class="viewcode-block" id="clip_augmented_image"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.clip_augmented_image">[docs]</a><span class="k">def</span> <span class="nf">clip_augmented_image</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">clip_augmented_images</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">)</span></div>


<div class="viewcode-block" id="clip_augmented_images_"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.clip_augmented_images_">[docs]</a><span class="k">def</span> <span class="nf">clip_augmented_images_</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">images</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span></div>


<div class="viewcode-block" id="clip_augmented_images"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.clip_augmented_images">[docs]</a><span class="k">def</span> <span class="nf">clip_augmented_images</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
        <span class="n">images</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">image</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">clip_augmented_images_</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">minval</span><span class="p">,</span> <span class="n">maxval</span><span class="p">)</span></div>


<div class="viewcode-block" id="handle_children_list"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.handle_children_list">[docs]</a><span class="k">def</span> <span class="nf">handle_children_list</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">augmenter_name</span><span class="p">,</span> <span class="n">lst_name</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">lst</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Sequential</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">augmenter_name</span><span class="p">,</span> <span class="n">lst_name</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">Augmenter</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Augmenter</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">lst</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Sequential</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">augmenter_name</span><span class="p">,</span> <span class="n">lst_name</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Augmenter</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Sequential</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">augmenter_name</span><span class="p">,</span> <span class="n">lst_name</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected None, Augmenter or list/tuple as children list </span><span class="si">%s</span><span class="s2"> for augmenter with name </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lst_name</span><span class="p">,</span> <span class="n">augmenter_name</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">lst</span><span class="p">),))</span></div>


<div class="viewcode-block" id="Augmenter"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter">[docs]</a><span class="nd">@six</span><span class="o">.</span><span class="n">add_metaclass</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Augmenter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span> <span class="c1"># pylint: disable=locally-disabled, unused-variable, line-too-long</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for Augmenter objects.</span>
<span class="sd">    All augmenters derive from this class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new Augmenter instance.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : None or string, optional(default=None)</span>
<span class="sd">            Name given to an Augmenter object. This name is used in print()</span>
<span class="sd">            statements as well as find and remove functions.</span>
<span class="sd">            If None, `UnnamedX` will be used as the name, where X is the</span>
<span class="sd">            Augmenter&#39;s class name.</span>

<span class="sd">        deterministic : bool, optional(default=False)</span>
<span class="sd">            Whether the augmenter instance&#39;s random state will be saved before</span>
<span class="sd">            augmenting images and then reset to that saved state after an</span>
<span class="sd">            augmentation (of multiple images/keypoints) is finished.</span>
<span class="sd">            I.e. if set to True, each batch of images will be augmented in the</span>
<span class="sd">            same way (e.g. first image might always be flipped horizontally,</span>
<span class="sd">            second image will never be flipped etc.).</span>
<span class="sd">            This is useful when you want to transform multiple batches of images</span>
<span class="sd">            in the same way, or when you want to augment images and keypoints</span>
<span class="sd">            on these images.</span>
<span class="sd">            Usually, there is no need to set this variable by hand. Instead,</span>
<span class="sd">            instantiate the augmenter with the defaults and then use</span>
<span class="sd">            `augmenter.to_deterministic()`.</span>

<span class="sd">        random_state : None or int or np.random.RandomState, optional(default=None)</span>
<span class="sd">            The random state to use for this</span>
<span class="sd">            augmenter.</span>
<span class="sd">                * If int, a new np.random.RandomState will be created using this</span>
<span class="sd">                  value as the seed.</span>
<span class="sd">                * If np.random.RandomState instance, the instance will be used directly.</span>
<span class="sd">                * If None, imgaug&#39;s default RandomState will be used, which&#39;s state can</span>
<span class="sd">                  be controlled using imgaug.seed(int).</span>
<span class="sd">            Usually there is no need to set this variable by hand. Instead,</span>
<span class="sd">            instantiate the augmenter with the defaults and then use</span>
<span class="sd">            `augmenter.to_deterministic()`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Unnamed</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="n">deterministic</span>

        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">current_random_state</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">activated</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Augmenter.augment_batches"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.augment_batches">[docs]</a>    <span class="k">def</span> <span class="nf">augment_batches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batches</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augment multiple batches of images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        batches : list</span>
<span class="sd">            List of image batches to augment.</span>
<span class="sd">            The expected input is a list, with each entry having one of the</span>
<span class="sd">            following datatypes:</span>
<span class="sd">                * ia.Batch</span>
<span class="sd">                * []</span>
<span class="sd">                * list of ia.KeypointsOnImage</span>
<span class="sd">                * list of (H,W,C) ndarray</span>
<span class="sd">                * list of (H,W) ndarray</span>
<span class="sd">                * (N,H,W,C) ndarray</span>
<span class="sd">                * (N,H,W) ndarray</span>
<span class="sd">            where N = number of images, H = height, W = width,</span>
<span class="sd">            C = number of channels.</span>
<span class="sd">            Each image is recommended to have dtype uint8 (range 0-255).</span>

<span class="sd">        hooks : None or ia.HooksImages, optional(default=None)</span>
<span class="sd">            HooksImages object to dynamically interfere with the augmentation</span>
<span class="sd">            process.</span>

<span class="sd">        background : bool, optional(default=False)</span>
<span class="sd">            Whether to augment the batches in background processes.</span>
<span class="sd">            If true, hooks can currently not be used as that would require</span>
<span class="sd">            pickling functions.</span>

<span class="sd">        Yields</span>
<span class="sd">        -------</span>
<span class="sd">        augmented_batch : ia.Batch or list of ia.KeypointsOnImage or list of (H,W,C) ndarray or list of (H,W) ndarray or (N,H,W,C) ndarray or (N,H,W) ndarray</span>
<span class="sd">            Augmented images/keypoints.</span>
<span class="sd">            Datatype usually matches the input datatypes per list element.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">batches</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">batches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">background</span><span class="p">:</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">hooks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Hooks can not be used when background augmentation is activated.&quot;</span><span class="p">)</span>

        <span class="n">batches_normalized</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">batches_original_dts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">batches</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="n">ia</span><span class="o">.</span><span class="n">Batch</span><span class="p">):</span>
                <span class="n">batch</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">batch</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="n">batches_normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
                <span class="n">batches_original_dts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;imgaug.Batch&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">batch</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">batch</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="s2">&quot;Expected numpy array to have shape (N, H, W) or (N, H, W, C), got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">batch</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
                <span class="n">batches_normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">Batch</span><span class="p">(</span><span class="n">images</span><span class="o">=</span><span class="n">batch</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
                <span class="n">batches_original_dts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;numpy_array&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">batches_normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">Batch</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
                    <span class="n">batches_original_dts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;empty_list&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">batches_normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">Batch</span><span class="p">(</span><span class="n">images</span><span class="o">=</span><span class="n">batch</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
                    <span class="n">batches_original_dts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;list_of_numpy_arrays&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ia</span><span class="o">.</span><span class="n">KeypointsOnImage</span><span class="p">):</span>
                    <span class="n">batches_normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">Batch</span><span class="p">(</span><span class="n">keypoints</span><span class="o">=</span><span class="n">batch</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
                    <span class="n">batches_original_dts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;list_of_imgaug.KeypointsOnImage&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown datatype in batch[0]. Expected numpy array or imgaug.KeypointsOnImage, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">batch</span><span class="p">[</span><span class="mi">0</span><span class="p">]),))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown datatype of batch. Expected imgaug.Batch or numpy array or list of numpy arrays/imgaug.KeypointsOnImage. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">batch</span><span class="p">),))</span>

        <span class="k">def</span> <span class="nf">unnormalize_batch</span><span class="p">(</span><span class="n">batch_aug</span><span class="p">):</span>
            <span class="c1">#if batch_aug.data is None:</span>
            <span class="c1">#    return batch_aug</span>
            <span class="c1">#else:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">batch_aug</span><span class="o">.</span><span class="n">data</span>
            <span class="c1"># if input was ia.Batch, then .data has content (i, .data)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dt_orig</span> <span class="o">=</span> <span class="n">batches_original_dts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dt_orig</span> <span class="o">==</span> <span class="s2">&quot;imgaug.Batch&quot;</span><span class="p">:</span>
                <span class="n">batch_unnormalized</span> <span class="o">=</span> <span class="n">batch_aug</span>
                <span class="c1"># change (i, .data) back to just .data</span>
                <span class="n">batch_unnormalized</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">batch_unnormalized</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">dt_orig</span> <span class="o">==</span> <span class="s2">&quot;numpy_array&quot;</span><span class="p">:</span>
                <span class="n">batch_unnormalized</span> <span class="o">=</span> <span class="n">batch_aug</span><span class="o">.</span><span class="n">images_aug</span>
            <span class="k">elif</span> <span class="n">dt_orig</span> <span class="o">==</span> <span class="s2">&quot;empty_list&quot;</span><span class="p">:</span>
                <span class="n">batch_unnormalized</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">elif</span> <span class="n">dt_orig</span> <span class="o">==</span> <span class="s2">&quot;list_of_numpy_arrays&quot;</span><span class="p">:</span>
                <span class="n">batch_unnormalized</span> <span class="o">=</span> <span class="n">batch_aug</span><span class="o">.</span><span class="n">images_aug</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">dt_orig</span> <span class="o">==</span> <span class="s2">&quot;list_of_imgaug.KeypointsOnImage&quot;</span><span class="p">)</span>  <span class="c1"># only option left</span>
                <span class="n">batch_unnormalized</span> <span class="o">=</span> <span class="n">batch_aug</span><span class="o">.</span><span class="n">keypoints_aug</span>
            <span class="k">return</span> <span class="n">batch_unnormalized</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">background</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">batch_normalized</span> <span class="ow">in</span> <span class="n">batches_normalized</span><span class="p">:</span>
                <span class="n">batch_augment_images</span> <span class="o">=</span> <span class="n">batch_normalized</span><span class="o">.</span><span class="n">images</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="n">batch_augment_keypoints</span> <span class="o">=</span> <span class="n">batch_normalized</span><span class="o">.</span><span class="n">keypoints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">batch_augment_images</span> <span class="ow">and</span> <span class="n">batch_augment_keypoints</span><span class="p">:</span>
                    <span class="n">augseq_det</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span> <span class="k">else</span> <span class="bp">self</span>
                    <span class="n">batch_normalized</span><span class="o">.</span><span class="n">images_aug</span> <span class="o">=</span> <span class="n">augseq_det</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">batch_normalized</span><span class="o">.</span><span class="n">images</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">)</span>
                    <span class="n">batch_normalized</span><span class="o">.</span><span class="n">keypoints_aug</span> <span class="o">=</span> <span class="n">augseq_det</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span><span class="n">batch_normalized</span><span class="o">.</span><span class="n">keypoints</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">batch_augment_images</span><span class="p">:</span>
                    <span class="n">batch_normalized</span><span class="o">.</span><span class="n">images_aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span><span class="n">batch_normalized</span><span class="o">.</span><span class="n">images</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">batch_augment_keypoints</span><span class="p">:</span>
                    <span class="n">batch_normalized</span><span class="o">.</span><span class="n">keypoints_aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span><span class="n">batch_normalized</span><span class="o">.</span><span class="n">keypoints</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">)</span>
                <span class="n">batch_unnormalized</span> <span class="o">=</span> <span class="n">unnormalize_batch</span><span class="p">(</span><span class="n">batch_normalized</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">batch_unnormalized</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">load_batches</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batches_normalized</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">batch</span>

            <span class="n">batch_loader</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">BatchLoader</span><span class="p">(</span><span class="n">load_batches</span><span class="p">)</span>
            <span class="n">bg_augmenter</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">BackgroundAugmenter</span><span class="p">(</span><span class="n">batch_loader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">batch_aug</span> <span class="o">=</span> <span class="n">bg_augmenter</span><span class="o">.</span><span class="n">get_batch</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">batch_aug</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">batch_unnormalized</span> <span class="o">=</span> <span class="n">unnormalize_batch</span><span class="p">(</span><span class="n">batch_aug</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="n">batch_unnormalized</span>
            <span class="n">batch_loader</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
            <span class="n">bg_augmenter</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Augmenter.augment_image"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.augment_image">[docs]</a>    <span class="k">def</span> <span class="nf">augment_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augment a single image.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image : (H,W,C) ndarray or (H,W) ndarray</span>
<span class="sd">            The image to augment. Should have dtype uint8 (range 0-255).</span>

<span class="sd">        hooks : None or ia.HooksImages, optional(default=None)</span>
<span class="sd">            HooksImages object to dynamically interfere with the augmentation</span>
<span class="sd">            process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        img : ndarray</span>
<span class="sd">            The corresponding augmented image.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;Expected image to have shape (height, width, [channels]), got shape </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">augment_images</span><span class="p">([</span><span class="n">image</span><span class="p">],</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Augmenter.augment_images"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.augment_images">[docs]</a>    <span class="k">def</span> <span class="nf">augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augment multiple images.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        images : (N,H,W,C) ndarray or (N,H,W) ndarray or list of (H,W,C) ndarray or list of (H,W) ndarray</span>
<span class="sd">            Images to augment. The input can be a list of numpy arrays or</span>
<span class="sd">            a single array. Each array is expected to have shape (H, W, C)</span>
<span class="sd">            or (H, W), where H is the height, W is the width and C are the</span>
<span class="sd">            channels. Number of channels may differ between images.</span>
<span class="sd">            If a list is chosen, height and width may differ per between images.</span>
<span class="sd">            Currently the recommended dtype is uint8 (i.e. integer values in</span>
<span class="sd">            the range 0 to 255). Other dtypes are not tested.</span>

<span class="sd">        parents : None or list of Augmenter, optional(default=None)</span>
<span class="sd">            Parent augmenters that have previously been called before the</span>
<span class="sd">            call to this function. Usually you can leave this parameter as None.</span>
<span class="sd">            It is set automatically for child augmenters.</span>

<span class="sd">        hooks : None or ia.HooksImages, optional(default=None)</span>
<span class="sd">            HooksImages object to dynamically interfere with the augmentation</span>
<span class="sd">            process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        images_result : ndarray or list</span>
<span class="sd">            Corresponding augmented images.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">:</span>
            <span class="n">state_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">parents</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">hooks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hooks</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">HooksImages</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">input_type</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
            <span class="n">input_added_axis</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s2">&quot;Expected 3d/4d array of form (N, height, width) or (N, height, width, channels), got shape </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>

            <span class="c1"># copy the input, we don&#39;t want to augment it in-place</span>
            <span class="n">images_copy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">images_copy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">images_copy</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;You provided a numpy array of shape </span><span class="si">%s</span><span class="s2"> as input to augment_images(), &quot;</span>
                              <span class="s2">&quot;which was interpreted as (N, H, W). The last dimension however has &quot;</span>
                              <span class="s2">&quot;value 1 or 3, which indicates that you provided a single image &quot;</span>
                              <span class="s2">&quot;with shape (H, W, C) instead. If that is the case, you should use &quot;</span>
                              <span class="s2">&quot;augment_image(image) or augment_images([image]), otherwise &quot;</span>
                              <span class="s2">&quot;you will not get the expected augmentations.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">images_copy</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>

            <span class="c1"># for 2D input images (i.e. shape (N, H, W)), we add a channel axis (i.e. (N, H, W, 1)),</span>
            <span class="c1"># so that all augmenters can rely on the input having a channel axis and</span>
            <span class="c1"># don&#39;t have to add if/else statements for 2D images</span>
            <span class="k">if</span> <span class="n">images_copy</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">images_copy</span> <span class="o">=</span> <span class="n">images_copy</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">input_added_axis</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="n">input_type</span> <span class="o">=</span> <span class="s2">&quot;list&quot;</span>
            <span class="n">input_added_axis</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">images_copy</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">),</span> <span class="s2">&quot;Expected list of images with each image having shape (height, width) or (height, width, channels), got shapes </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">([</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">],))</span>

                <span class="c1"># copy images and add channel axis for 2D images (see above,</span>
                <span class="c1"># as for list inputs each image can have different shape, it</span>
                <span class="c1"># is done here on a per images basis)</span>
                <span class="n">images_copy</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">input_added_axis</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
                    <span class="n">image_copy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">image_copy</span> <span class="o">=</span> <span class="n">image_copy</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                        <span class="n">input_added_axis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">input_added_axis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">images_copy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image_copy</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected images as one numpy array or list/tuple of numpy arrays, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">images</span><span class="p">),))</span>

        <span class="n">images_copy</span> <span class="o">=</span> <span class="n">hooks</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">images_copy</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">)</span>

        <span class="c1">#if ia.is_np_array(images) != ia.is_np_array(images_copy):</span>
        <span class="c1">#    print(&quot;[WARNING] images vs images_copy&quot;, ia.is_np_array(images), ia.is_np_array(images_copy))</span>
        <span class="c1">#if ia.is_np_array(images):</span>
            <span class="c1">#ia.do_assert(images.shape[0] &gt; 0, images.shape)</span>
        <span class="c1">#    print(&quot;images.shape&quot;, images.shape)</span>
        <span class="c1">#if ia.is_np_array(images_copy):</span>
        <span class="c1">#    print(&quot;images_copy.shape&quot;, images_copy.shape)</span>

        <span class="c1"># the is_activated() call allows to use hooks that selectively</span>
        <span class="c1"># deactivate specific augmenters in previously defined augmentation</span>
        <span class="c1"># sequences</span>
        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_activated</span><span class="p">(</span><span class="n">images_copy</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activated</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">images_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_augment_images</span><span class="p">(</span>
                    <span class="n">images_copy</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">copy_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>
                <span class="c1"># move &quot;forward&quot; the random state, so that the next call to</span>
                <span class="c1"># augment_images() will use different random values</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">forward_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">images_result</span> <span class="o">=</span> <span class="n">images_copy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images_result</span> <span class="o">=</span> <span class="n">images_copy</span>

        <span class="n">images_result</span> <span class="o">=</span> <span class="n">hooks</span><span class="o">.</span><span class="n">postprocess</span><span class="p">(</span><span class="n">images_result</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">)</span>

        <span class="c1"># remove temporarily added channel axis for 2D input images</span>
        <span class="n">output_type</span> <span class="o">=</span> <span class="s2">&quot;list&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images_result</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;array&quot;</span>
        <span class="k">if</span> <span class="n">input_type</span> <span class="o">==</span> <span class="s2">&quot;array&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">input_added_axis</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">output_type</span> <span class="o">==</span> <span class="s2">&quot;array&quot;</span><span class="p">:</span>
                    <span class="n">images_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">images_result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">images_result</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images_result</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># if input_type == &quot;list&quot;:</span>
            <span class="c1"># This test was removed for now because hooks can change the type</span>
            <span class="c1">#ia.do_assert(</span>
            <span class="c1">#    isinstance(images_result, list),</span>
            <span class="c1">#    &quot;INTERNAL ERROR: Input was list, output was expected to be list too &quot;</span>
            <span class="c1">#    &quot;but got %s.&quot; % (type(images_result),)</span>
            <span class="c1">#)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">images_result</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span>
                <span class="s2">&quot;INTERNAL ERROR: Expected number of images to be unchanged after augmentation, &quot;</span>
                <span class="s2">&quot;but was changed from </span><span class="si">%d</span><span class="s2"> to </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">images_result</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images_result</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">input_added_axis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">images_result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">images_result</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">state_orig</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">images_result</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augment multiple images.</span>

<span class="sd">        This is the internal variation of `augment_images()`.</span>
<span class="sd">        It is called from `augment_images()` and should usually not be called</span>
<span class="sd">        directly.</span>
<span class="sd">        It has to be implemented by every augmenter.</span>
<span class="sd">        This method may transform the images in-place.</span>
<span class="sd">        This method does not have to care about determinism or the</span>
<span class="sd">        Augmenter instance&#39;s `random_state` variable. The parameter</span>
<span class="sd">        `random_state` takes care of both of these.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        images : (N,H,W,C) ndarray or list of (H,W,C) ndarray</span>
<span class="sd">            Images to augment.</span>
<span class="sd">            They may be changed in-place.</span>
<span class="sd">            Either a list of (H, W, C) arrays or a single (N, H, W, C) array,</span>
<span class="sd">            where N = number of images, H = height of images, W = width of</span>
<span class="sd">            images, C = number of channels of images.</span>
<span class="sd">            In the case of a list as input, H, W and C may change per image.</span>

<span class="sd">        random_state : np.random.RandomState</span>
<span class="sd">            The random state to use for all sampling tasks during the</span>
<span class="sd">            augmentation.</span>

<span class="sd">        parents : list of Augmenter</span>
<span class="sd">            See augment_images().</span>

<span class="sd">        hooks : ia.HooksImages</span>
<span class="sd">            See augment_images().</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        images : (N,H,W,C) ndarray or list of (H,W,C) ndarray</span>
<span class="sd">            The augmented images.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="Augmenter.augment_keypoints"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.augment_keypoints">[docs]</a>    <span class="k">def</span> <span class="nf">augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augment image keypoints.</span>

<span class="sd">        This is the corresponding function to `augment_images()`, just for</span>
<span class="sd">        keypoints/landmarks (i.e. coordinates on the image).</span>
<span class="sd">        Usually you will want to call `augment_images()` with a list of images,</span>
<span class="sd">        e.g. `augment_images([A, B, C])` and then `augment_keypoints()` with the</span>
<span class="sd">        corresponding list of keypoints on these images, e.g.</span>
<span class="sd">        `augment_keypoints([Ak, Bk, Ck])`, where `Ak` are the keypoints on</span>
<span class="sd">        image `A`.</span>

<span class="sd">        Make sure to first convert the augmenter(s) to deterministic states</span>
<span class="sd">        before augmenting images and their corresponding keypoints,</span>
<span class="sd">        e.g. by</span>
<span class="sd">            &gt;&gt;&gt; seq = iaa.Fliplr(0.5)</span>
<span class="sd">            &gt;&gt;&gt; seq_det = seq.to_deterministic()</span>
<span class="sd">            &gt;&gt;&gt; imgs_aug = seq_det.augment_images([A, B, C])</span>
<span class="sd">            &gt;&gt;&gt; kps_aug = seq_det.augment_keypoints([Ak, Bk, Ck])</span>
<span class="sd">        Otherwise, different random values will be sampled for the image</span>
<span class="sd">        and keypoint augmentations, resulting in different augmentations (e.g.</span>
<span class="sd">        images might be rotated by `30deg` and keypoints by `-10deg`).</span>
<span class="sd">        Also make sure to call `to_deterministic()` again for each new batch,</span>
<span class="sd">        otherwise you would augment all batches in the same way.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keypoints_on_images : list of ia.KeypointsOnImage</span>
<span class="sd">            The keypoints/landmarks to augment.</span>
<span class="sd">            Expected is a list of ia.KeypointsOnImage objects,</span>
<span class="sd">            each containing the keypoints of a single image.</span>

<span class="sd">        parents : None or list of Augmenter, optional(default=None)</span>
<span class="sd">            Parent augmenters that have previously been called before the</span>
<span class="sd">            call to this function. Usually you can leave this parameter as None.</span>
<span class="sd">            It is set automatically for child augmenters.</span>

<span class="sd">        hooks : None or ia.HooksKeypoints, optional(default=None)</span>
<span class="sd">            HooksKeypoints object to dynamically interfere with the</span>
<span class="sd">            augmentation process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        keypoints_on_images_result : list of ia.KeypointsOnImage</span>
<span class="sd">            Augmented keypoints.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">:</span>
            <span class="n">state_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">parents</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">hooks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hooks</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">HooksKeypoints</span><span class="p">()</span>

        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">))</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">keypoints_on_image</span><span class="p">,</span> <span class="n">ia</span><span class="o">.</span><span class="n">KeypointsOnImage</span><span class="p">)</span> <span class="k">for</span> <span class="n">keypoints_on_image</span> <span class="ow">in</span> <span class="n">keypoints_on_images</span><span class="p">]))</span>

        <span class="n">keypoints_on_images_copy</span> <span class="o">=</span> <span class="p">[</span><span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span> <span class="k">for</span> <span class="n">keypoints_on_image</span> <span class="ow">in</span> <span class="n">keypoints_on_images</span><span class="p">]</span>

        <span class="n">keypoints_on_images_copy</span> <span class="o">=</span> <span class="n">hooks</span><span class="o">.</span><span class="n">preprocess</span><span class="p">(</span><span class="n">keypoints_on_images_copy</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_activated</span><span class="p">(</span><span class="n">keypoints_on_images_copy</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">activated</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images_copy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">keypoints_on_images_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_augment_keypoints</span><span class="p">(</span>
                    <span class="n">keypoints_on_images_copy</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">copy_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">),</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">forward_random_state</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">keypoints_on_images_result</span> <span class="o">=</span> <span class="n">keypoints_on_images_copy</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keypoints_on_images_result</span> <span class="o">=</span> <span class="n">keypoints_on_images_copy</span>

        <span class="n">keypoints_on_images_result</span> <span class="o">=</span> <span class="n">hooks</span><span class="o">.</span><span class="n">postprocess</span><span class="p">(</span><span class="n">keypoints_on_images_result</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">state_orig</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">keypoints_on_images_result</span></div>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augment keypoints on multiple images.</span>

<span class="sd">        This is the internal variation of `augment_keypoints()`.</span>
<span class="sd">        It is called from `augment_keypoints()` and should usually not be called</span>
<span class="sd">        directly.</span>
<span class="sd">        It has to be implemented by every augmenter.</span>
<span class="sd">        This method may transform the keypoints in-place.</span>
<span class="sd">        This method does not have to care about determinism or the</span>
<span class="sd">        Augmenter instance&#39;s `random_state` variable. The parameter</span>
<span class="sd">        `random_state` takes care of both of these.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keypoints_on_images : list of ia.KeypointsOnImage</span>
<span class="sd">            Keypoints to augment. They may be changed in-place.</span>

<span class="sd">        random_state : np.random.RandomState</span>
<span class="sd">            The random state to use for all sampling tasks during the</span>
<span class="sd">            augmentation.</span>

<span class="sd">        parents : list of Augmenter</span>
<span class="sd">            See `augment_keypoints()`.</span>

<span class="sd">        hooks : ia.HooksImages</span>
<span class="sd">            See `augment_keypoints()`.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        images : list of ia.KeypointsOnImage</span>
<span class="sd">            The augmented keypoints.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="Augmenter.augment_bounding_boxes"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.augment_bounding_boxes">[docs]</a>    <span class="k">def</span> <span class="nf">augment_bounding_boxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounding_boxes_on_images</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augment image bounding boxes.</span>

<span class="sd">        This is the corresponding function to `augment_keypoints()`, just for</span>
<span class="sd">        bounding boxes.</span>
<span class="sd">        Usually you will want to call `augment_images()` with a list of images,</span>
<span class="sd">        e.g. `augment_images([A, B, C])` and then `augment_bounding_boxes()`</span>
<span class="sd">        with the corresponding list of bounding boxes on these images, e.g.</span>
<span class="sd">        `augment_bounding_boxes([Abb, Bbb, Cbb])`, where `Abb` are the</span>
<span class="sd">        bounding boxes on image `A`.</span>

<span class="sd">        Make sure to first convert the augmenter(s) to deterministic states</span>
<span class="sd">        before augmenting images and their corresponding bounding boxes,</span>
<span class="sd">        e.g. by</span>
<span class="sd">            &gt;&gt;&gt; seq = iaa.Fliplr(0.5)</span>
<span class="sd">            &gt;&gt;&gt; seq_det = seq.to_deterministic()</span>
<span class="sd">            &gt;&gt;&gt; imgs_aug = seq_det.augment_images([A, B, C])</span>
<span class="sd">            &gt;&gt;&gt; bbs_aug = seq_det.augment_keypoints([Abb, Bbb, Cbb])</span>
<span class="sd">        Otherwise, different random values will be sampled for the image</span>
<span class="sd">        and bounding box augmentations, resulting in different augmentations</span>
<span class="sd">        (e.g. images might be rotated by `30deg` and bounding boxes by</span>
<span class="sd">        `-10deg`). Also make sure to call `to_deterministic()` again for each</span>
<span class="sd">        new batch, otherwise you would augment all batches in the same way.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bounding_boxes_on_images : list of ia.BoundingBoxesOnImage</span>
<span class="sd">            The bounding boxes to augment.</span>
<span class="sd">            Expected is a list of ia.BoundingBoxesOnImage objects,</span>
<span class="sd">            each containing the bounding boxes of a single image.</span>

<span class="sd">        hooks : None or ia.HooksKeypoints, optional(default=None)</span>
<span class="sd">            HooksKeypoints object to dynamically interfere with the</span>
<span class="sd">            augmentation process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : list of ia.BoundingBoxesOnImage</span>
<span class="sd">            Augmented bounding boxes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kps_ois</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bbs_oi</span> <span class="ow">in</span> <span class="n">bounding_boxes_on_images</span><span class="p">:</span>
            <span class="n">kps</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">bbs_oi</span><span class="o">.</span><span class="n">bounding_boxes</span><span class="p">:</span>
                <span class="n">kps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bb</span><span class="o">.</span><span class="n">to_keypoints</span><span class="p">())</span>
            <span class="n">kps_ois</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">KeypointsOnImage</span><span class="p">(</span><span class="n">kps</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">bbs_oi</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="n">kps_ois_aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span><span class="n">kps_ois</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">img_idx</span><span class="p">,</span> <span class="n">kps_oi_aug</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kps_ois_aug</span><span class="p">):</span>
            <span class="n">bbs_aug</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kps_oi_aug</span><span class="o">.</span><span class="n">keypoints</span><span class="p">)</span> <span class="o">//</span> <span class="mi">4</span><span class="p">):</span>
                <span class="n">bb_kps</span> <span class="o">=</span> <span class="n">kps_oi_aug</span><span class="o">.</span><span class="n">keypoints</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">kp</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">bb_kps</span><span class="p">])</span>
                <span class="n">x2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">kp</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">bb_kps</span><span class="p">])</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">kp</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">bb_kps</span><span class="p">])</span>
                <span class="n">y2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">kp</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">bb_kps</span><span class="p">])</span>
                <span class="n">bbs_aug</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">bounding_boxes_on_images</span><span class="p">[</span><span class="n">img_idx</span><span class="p">]</span><span class="o">.</span><span class="n">bounding_boxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
                        <span class="n">x1</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span>
                        <span class="n">y1</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span>
                        <span class="n">x2</span><span class="o">=</span><span class="n">x2</span><span class="p">,</span>
                        <span class="n">y2</span><span class="o">=</span><span class="n">y2</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">BoundingBoxesOnImage</span><span class="p">(</span>
                    <span class="n">bbs_aug</span><span class="p">,</span>
                    <span class="n">shape</span><span class="o">=</span><span class="n">kps_oi_aug</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

    <span class="c1"># TODO most of the code of this function could be replaced with ia.draw_grid()</span>
    <span class="c1"># TODO add parameter for handling multiple images ((a) next to each other</span>
    <span class="c1"># in each row or (b) multiply row count by number of images and put each</span>
    <span class="c1"># one in a new row)</span>
    <span class="c1"># TODO &quot;images&quot; parameter deviates from augment_images (3d array is here</span>
    <span class="c1"># treated as one 3d image, in augment_images as (N, H, W))</span>
<div class="viewcode-block" id="Augmenter.draw_grid"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.draw_grid">[docs]</a>    <span class="k">def</span> <span class="nf">draw_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply this augmenter to the given images and return a grid</span>
<span class="sd">        image of the results.</span>
<span class="sd">        Each cell in the grid contains a single augmented variation of</span>
<span class="sd">        an input image.</span>

<span class="sd">        If multiple images are provided, the row count is multiplied by</span>
<span class="sd">        the number of images and each image gets its own row.</span>
<span class="sd">        E.g. for `images = [A, B]`, `rows=2`, `cols=3`::</span>
<span class="sd">            A A A</span>
<span class="sd">            B B B</span>
<span class="sd">            A A A</span>
<span class="sd">            B B B</span>

<span class="sd">        for `images = [A]`, `rows=2`,</span>
<span class="sd">        `cols=3`::</span>
<span class="sd">            A A A</span>
<span class="sd">            A A A</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------</span>
<span class="sd">        images : (N,H,W,3) ndarray or (H,W,3) ndarray or (H,W) ndarray or list of (H,W,3) ndarray or list of (H,W) ndarray</span>
<span class="sd">            List of images of which to show the augmented versions.</span>
<span class="sd">            If a list, then each element is expected to have shape (H, W) or</span>
<span class="sd">            (H, W, 3). If a single array, then it is expected to have</span>
<span class="sd">            shape (N, H, W, 3) or (H, W, 3) or (H, W).</span>

<span class="sd">        rows : int</span>
<span class="sd">            Number of rows in the grid.</span>
<span class="sd">            If N input images are given, this value will automatically be</span>
<span class="sd">            multiplied by N to create rows for each image.</span>

<span class="sd">        cols : int</span>
<span class="sd">            Number of columns in the grid.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        grid : (Hg,Wg,3) ndarray</span>
<span class="sd">            The generated grid image with augmented versions of the input</span>
<span class="sd">            images. Here, Hg and Wg reference the output size of the grid,</span>
<span class="sd">            and *not* the sizes of the input images.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">images</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">images</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unexpected images shape, expected 2-, 3- or 4-dimensional array, got shape </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unexpected image shape at index </span><span class="si">%d</span><span class="s2">, expected 2- or 3-dimensional array, got shape </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,))</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>

        <span class="n">det</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span>
        <span class="n">augs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">:</span>
            <span class="n">augs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">det</span><span class="o">.</span><span class="n">augment_images</span><span class="p">([</span><span class="n">image</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">)))</span>

        <span class="n">augs_flat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">augs</span><span class="p">))</span>
        <span class="n">cell_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">augs_flat</span><span class="p">])</span>
        <span class="n">cell_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">augs_flat</span><span class="p">])</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">cell_width</span> <span class="o">*</span> <span class="n">cols</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">cell_height</span> <span class="o">*</span> <span class="p">(</span><span class="n">rows</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">))</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">row_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">img_idx</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">col_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                    <span class="n">image_aug</span> <span class="o">=</span> <span class="n">augs</span><span class="p">[</span><span class="n">img_idx</span><span class="p">][(</span><span class="n">row_idx</span> <span class="o">*</span> <span class="n">cols</span><span class="p">)</span> <span class="o">+</span> <span class="n">col_idx</span><span class="p">]</span>
                    <span class="n">cell_y1</span> <span class="o">=</span> <span class="n">cell_height</span> <span class="o">*</span> <span class="p">(</span><span class="n">row_idx</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span> <span class="o">+</span> <span class="n">img_idx</span><span class="p">)</span>
                    <span class="n">cell_y2</span> <span class="o">=</span> <span class="n">cell_y1</span> <span class="o">+</span> <span class="n">image_aug</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">cell_x1</span> <span class="o">=</span> <span class="n">cell_width</span> <span class="o">*</span> <span class="n">col_idx</span>
                    <span class="n">cell_x2</span> <span class="o">=</span> <span class="n">cell_x1</span> <span class="o">+</span> <span class="n">image_aug</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">cell_y1</span><span class="p">:</span><span class="n">cell_y2</span><span class="p">,</span> <span class="n">cell_x1</span><span class="p">:</span><span class="n">cell_x2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">image_aug</span>

        <span class="k">return</span> <span class="n">grid</span></div>

    <span class="c1"># TODO test for 2D images</span>
    <span class="c1"># TODO test with C = 1</span>
<div class="viewcode-block" id="Augmenter.show_grid"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.show_grid">[docs]</a>    <span class="k">def</span> <span class="nf">show_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply this augmenter to the given images and show/plot the results as</span>
<span class="sd">        a grid of images.</span>

<span class="sd">        If multiple images are provided, the row count is multiplied by</span>
<span class="sd">        the number of images and each image gets its own row.</span>
<span class="sd">        E.g. for `images = [A, B]`, `rows=2`, `cols=3`::</span>
<span class="sd">            A A A</span>
<span class="sd">            B B B</span>
<span class="sd">            A A A</span>
<span class="sd">            B B B</span>

<span class="sd">        for `images = [A]`, `rows=2`,</span>
<span class="sd">        `cols=3`::</span>
<span class="sd">            A A A</span>
<span class="sd">            A A A</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        images : (N,H,W,3) ndarray or (H,W,3) ndarray or (H,W) ndarray or list of (H,W,3) ndarray or list of (H,W) ndarray</span>
<span class="sd">            List of images of which to show the augmented versions.</span>
<span class="sd">            If a list, then each element is expected to have shape (H, W)</span>
<span class="sd">            or (H, W, 3).</span>
<span class="sd">            If a single array, then it is expected to have shape (N, H, W, 3)</span>
<span class="sd">            or (H, W, 3) or (H, W).</span>

<span class="sd">        rows : int</span>
<span class="sd">            Number of rows in the grid.</span>
<span class="sd">            If N input images are given, this value will automatically be</span>
<span class="sd">            multiplied by N to create rows for each image.</span>

<span class="sd">        cols : int</span>
<span class="sd">            Number of columns in the grid.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_grid</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
        <span class="n">misc</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span></div>

<div class="viewcode-block" id="Augmenter.to_deterministic"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.to_deterministic">[docs]</a>    <span class="k">def</span> <span class="nf">to_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts this augmenter from a stochastic to a deterministic one.</span>

<span class="sd">        A stochastic augmenter samples new values for each parameter per image.</span>
<span class="sd">        Feed a new batch of images into the augmenter and you will get a</span>
<span class="sd">        new set of transformations.</span>
<span class="sd">        A deterministic augmenter also samples new values for each parameter</span>
<span class="sd">        per image, but starts each batch with the same RandomState (i.e. seed).</span>
<span class="sd">        Feed two batches of images into the augmenter and you get the same</span>
<span class="sd">        transformations both times (same number of images assumed; some</span>
<span class="sd">        augmenter&#39;s results are also dependend on image height, width and</span>
<span class="sd">        channel count).</span>

<span class="sd">        Using determinism is useful for keypoint augmentation,</span>
<span class="sd">        as you will usually want to augment images and their corresponding</span>
<span class="sd">        keypoints in the same way (e.g. if an image is rotated by `30deg`, then</span>
<span class="sd">        also rotate its keypoints by `30deg`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : None or int, optional</span>
<span class="sd">            Number of deterministic augmenters to return.</span>
<span class="sd">            If None then only one Augmenter object will be returned.</span>
<span class="sd">            If 1 or higher, then a list containing n Augmenter objects</span>
<span class="sd">            will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        det : Augmenter or list of Augmenter</span>
<span class="sd">            A single Augmenter object if n was None,</span>
<span class="sd">            otherwise a list of Augmenter objects (even if n was 1).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_deterministic</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span></div>

    <span class="k">def</span> <span class="nf">_to_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Augmenter-specific implementation of `to_deterministic()`.</span>
<span class="sd">        This function is expected to return a single new deterministic</span>
<span class="sd">        Augmenter object of this augmenter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        det : Augmenter object</span>
<span class="sd">            Deterministic variation of this Augmenter object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">aug</span>

<div class="viewcode-block" id="Augmenter.reseed"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.reseed">[docs]</a>    <span class="k">def</span> <span class="nf">reseed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic_too</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reseed this augmenter and all of its children (if it has any).</span>

<span class="sd">        This function is useful, when augmentations are run in the</span>
<span class="sd">        background (i.e. on multiple cores).</span>
<span class="sd">        It should be called before sending this Augmenter object to a</span>
<span class="sd">        background worker (i.e., if N workers are used, the function</span>
<span class="sd">        should be called N times). Otherwise, all background workers will</span>
<span class="sd">        use the same seeds and therefore apply the same augmentations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        random_state : None or int or np.random.RandomState, optional</span>
<span class="sd">            A RandomState that is used to sample seeds per augmenter.</span>
<span class="sd">            If int, the parameter will be used as a seed for a new RandomState.</span>
<span class="sd">            If None, a new RandomState will automatically be created.</span>

<span class="sd">        deterministic_too : bool, optional</span>
<span class="sd">            Whether to also change the seed of an augmenter `A`, if `A`</span>
<span class="sd">            is deterministic. This is the case both when this augmenter</span>
<span class="sd">            object is `A` or one of its children is `A`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">deterministic_too</span><span class="p">,</span> <span class="nb">bool</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">current_random_state</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
            <span class="k">pass</span> <span class="c1"># just use the provided random state without change</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span> <span class="ow">or</span> <span class="n">deterministic_too</span><span class="p">:</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children_lists</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="n">aug</span><span class="o">.</span><span class="n">reseed</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span> <span class="n">deterministic_too</span><span class="o">=</span><span class="n">deterministic_too</span><span class="p">)</span></div>

<div class="viewcode-block" id="Augmenter.localize_random_state"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.localize_random_state">[docs]</a>    <span class="k">def</span> <span class="nf">localize_random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts global random states to local ones.</span>
<span class="sd">        See `Augmenter.localize_random_state_()` for more details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recursive : bool, optional(default=True)</span>
<span class="sd">            See `Augmenter.localize_random_state_()`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aug : Augmenter</span>
<span class="sd">            Returns copy of augmenter and children, with localized random</span>
<span class="sd">            states.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">localize_random_state_</span><span class="p">(</span>
            <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">aug</span></div>

<div class="viewcode-block" id="Augmenter.localize_random_state_"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.localize_random_state_">[docs]</a>    <span class="k">def</span> <span class="nf">localize_random_state_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts global random states to local ones.</span>

<span class="sd">        A global random state exists exactly once. Many augmenters can point</span>
<span class="sd">        to it (and thereby use it to sample random numbers).</span>
<span class="sd">        Local random usually exists for exactly one augmenter and are</span>
<span class="sd">        saved within that augmenter.</span>

<span class="sd">        Usually there is no need to change global into local random states.</span>
<span class="sd">        The only noteworthy exceptions are</span>
<span class="sd">            * whenever you want to use determinism (so that the global random</span>
<span class="sd">              state is not accidentally reverted)</span>
<span class="sd">            * whenever you want to copy random states from one augmenter to</span>
<span class="sd">              another. (Copying the global random state doesn&#39;t help very</span>
<span class="sd">              much. If you copy the state from A to B, then execute A and then</span>
<span class="sd">              B, B&#39;s (global) random state has already changed because of A&#39;s</span>
<span class="sd">              sampling.)</span>
<span class="sd">        The case of determinism is handled automatically by to_deterministic().</span>
<span class="sd">        Only when you copy random states (via copy_random_state()), you need</span>
<span class="sd">        to call this function first.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recursive : bool, optional(default=True)</span>
<span class="sd">            Whether to localize the random states of children</span>
<span class="sd">            too.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Augmenter</span>
<span class="sd">            Returns itself (with localized random states).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">current_random_state</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children_lists</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                    <span class="n">child</span><span class="o">.</span><span class="n">localize_random_state_</span><span class="p">(</span><span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Augmenter.copy_random_state"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.copy_random_state">[docs]</a>    <span class="k">def</span> <span class="nf">copy_random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">matching</span><span class="o">=</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="n">matching_tolerant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy_determinism</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the random states from a source augmenter sequence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source : Augmenter</span>
<span class="sd">            See `Augmenter.copy_random_state_()`.</span>

<span class="sd">        recursive : bool, optional(default=True)</span>
<span class="sd">            See `Augmenter.copy_random_state_()`.</span>

<span class="sd">        matching : {&#39;position&#39;, &#39;name&#39;}, optional(default=&#39;position&#39;)</span>
<span class="sd">            See `Augmenter.copy_random_state_()`.</span>

<span class="sd">        matching_tolerant : bool, optional(default=True)</span>
<span class="sd">            See `Augmenter.copy_random_state_()`.</span>

<span class="sd">        copy_determinism : bool, optional(default=False)</span>
<span class="sd">            See `Augmenter.copy_random_state_()`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aug : Augmenter</span>
<span class="sd">            Copy of the augmenter(s) with the same random state(s) as in the</span>
<span class="sd">            source augmenter(s).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">copy_random_state_</span><span class="p">(</span>
            <span class="n">source</span><span class="p">,</span>
            <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">,</span>
            <span class="n">matching</span><span class="o">=</span><span class="n">matching</span><span class="p">,</span>
            <span class="n">matching_tolerant</span><span class="o">=</span><span class="n">matching_tolerant</span><span class="p">,</span>
            <span class="n">copy_determinism</span><span class="o">=</span><span class="n">copy_determinism</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">aug</span></div>

<div class="viewcode-block" id="Augmenter.copy_random_state_"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.copy_random_state_">[docs]</a>    <span class="k">def</span> <span class="nf">copy_random_state_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">matching</span><span class="o">=</span><span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="n">matching_tolerant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">copy_determinism</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the random states from a source augmenter sequence (inplace).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source : Augmenter</span>
<span class="sd">            The source augmenter from where to copy the random_state(s).</span>
<span class="sd">            May have children (e.g. a Sequential).</span>
<span class="sd">            May not use the global random state. This is used by default</span>
<span class="sd">            by all augmenters. Call `localize_random_state_()` once on the</span>
<span class="sd">            source to localize all random states.</span>

<span class="sd">        recursive : bool, optional(default=True)</span>
<span class="sd">            Whether to copy the random states of the source augmenter *and*</span>
<span class="sd">            all of its children (True) or just the source augmenter (False).</span>

<span class="sd">        matching : {&#39;position&#39;, &#39;name&#39;}, optional(default=&#39;position&#39;)</span>
<span class="sd">            Defines the matching mode to use during recursive copy.</span>
<span class="sd">            This is used to associate source augmenters with target augmenters.</span>
<span class="sd">            If &#39;position&#39; then the target and source sequences of augmenters</span>
<span class="sd">            are turned into flattened lists and are associated based on</span>
<span class="sd">            their list indices. If &#39;name&#39; then the target and source augmenters</span>
<span class="sd">            are matched based on their names (i.e. `augmenter.name`).</span>

<span class="sd">        matching_tolerant : bool, optional(default=True)</span>
<span class="sd">            Whether to use tolerant matching between source and target</span>
<span class="sd">            augmenters. If set to False: Name matching will raise an exception</span>
<span class="sd">            for any target augmenter which&#39;s name does not appear among the</span>
<span class="sd">            source augmeters. Position matching will raise an exception if</span>
<span class="sd">            source and target augmenter have an unequal number of children.</span>

<span class="sd">        copy_determinism : bool, optional(default=False)</span>
<span class="sd">            Whether to copy the `deterministic` flags from source to target</span>
<span class="sd">            augmenters too.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : Augmenter</span>
<span class="sd">            Returns itself (after random state copy).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source_augs</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">+</span> <span class="n">source</span><span class="o">.</span><span class="n">get_all_children</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">recursive</span> <span class="k">else</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">target_augs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_all_children</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">recursive</span> <span class="k">else</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>

        <span class="n">global_rs</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">current_random_state</span><span class="p">()</span>
        <span class="n">global_rs_exc_msg</span> <span class="o">=</span> <span class="s2">&quot;You called copy_random_state_() with a source &quot;</span> \
                            <span class="s2">&quot;that uses global random states. Call &quot;</span> \
                            <span class="s2">&quot;localize_random_state_() on the source first &quot;</span> \
                            <span class="s2">&quot;or initialize your augmenters with local random &quot;</span> \
                            <span class="s2">&quot;states, e.g. via Dropout(..., random_state=1234).&quot;</span>

        <span class="k">if</span> <span class="n">matching</span> <span class="o">==</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span>
            <span class="n">source_augs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">aug</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">aug</span> <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="n">source_augs</span><span class="p">}</span>
            <span class="n">target_augs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">aug</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">aug</span> <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="n">target_augs</span><span class="p">}</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_augs_dict</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_augs</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_augs_dict</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_augs</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Matching mode &#39;name&#39; with recursive=True was chosen in copy_random_state_, &quot;</span>
                    <span class="s2">&quot;but either the source or target augmentation sequence contains multiple &quot;</span>
                    <span class="s2">&quot;augmenters with the same name.&quot;</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">target_augs_dict</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">source_augs_dict</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">source_augs_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">random_state</span> <span class="o">==</span> <span class="n">global_rs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">global_rs_exc_msg</span><span class="p">)</span>
                    <span class="n">target_augs_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">copy_random_state</span><span class="p">(</span><span class="n">source_augs_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">copy_determinism</span><span class="p">:</span>
                        <span class="n">target_augs_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="n">source_augs_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">deterministic</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">matching_tolerant</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                        <span class="s2">&quot;Augmenter name &#39;</span><span class="si">%s</span><span class="s2">&#39; not found among source augmenters.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="n">matching</span> <span class="o">==</span> <span class="s2">&quot;position&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_augs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_augs</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">matching_tolerant</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s2">&quot;Source and target augmentation sequences have different lengths.&quot;</span>
                <span class="p">)</span>
            <span class="k">for</span> <span class="n">source_aug</span><span class="p">,</span> <span class="n">target_aug</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">source_augs</span><span class="p">,</span> <span class="n">target_augs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">source_aug</span><span class="o">.</span><span class="n">random_state</span> <span class="o">==</span> <span class="n">global_rs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">global_rs_exc_msg</span><span class="p">)</span>
                <span class="n">target_aug</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">copy_random_state</span><span class="p">(</span><span class="n">source_aug</span><span class="o">.</span><span class="n">random_state</span><span class="p">,</span> <span class="n">force_copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">copy_determinism</span><span class="p">:</span>
                    <span class="n">target_aug</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="n">source_aug</span><span class="o">.</span><span class="n">deterministic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown matching method &#39;</span><span class="si">%s</span><span class="s2">&#39;. Valid options are &#39;name&#39; and &#39;position&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">matching</span><span class="p">,))</span>

        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Augmenter.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.get_parameters">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="Augmenter.get_children_lists"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.get_children_lists">[docs]</a>    <span class="k">def</span> <span class="nf">get_children_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of lists of children of this augmenter.</span>

<span class="sd">        For most augmenters, the result will be a single empty list.</span>
<span class="sd">        For augmenters with children it will often be a list with one sublist containing all</span>
<span class="sd">        children. In some cases the augmenter will contain multiple distinct lists of children,</span>
<span class="sd">        e.g. an if-list and an else-list. This will lead to a result consisting of a single</span>
<span class="sd">        list with multiple sublists, each representing the respective sublist of children.</span>

<span class="sd">        E.g. for an if/else-augmenter that executes the children A1, A2 if a condition is met</span>
<span class="sd">        and otherwise executes the children B1, B2, B3 the result will be [[A1, A2], [B1, B2, B3]].</span>

<span class="sd">        IMPORTANT: While the topmost list may be newly created, each of the sublist must be</span>
<span class="sd">        editable inplace resulting in a changed children list of the augmenter. E.g. if</span>
<span class="sd">        an Augmenter IfElse(condition, [A1, A2], [B1, B2, B3]) returns [[A1, A2], [B1, B2, B3]]</span>
<span class="sd">        for a call to get_children_lists() and A2 is removed inplace from [A1, A2], then the</span>
<span class="sd">        children lists of IfElse(...) must also change to [A1], [B1, B2, B3]. This is used</span>
<span class="sd">        if remove_augmenters_inplace().</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        children: A list of lists of children (i.e. Augmenter instances).</span>
<span class="sd">            May be a single empty list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Augmenter.get_all_children"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.get_all_children">[docs]</a>    <span class="k">def</span> <span class="nf">get_all_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all children of this augmenter as a list.</span>

<span class="sd">        If the augmenter has no children, the returned list is empty.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        flat : bool</span>
<span class="sd">            If set to True, the returned list will be</span>
<span class="sd">            flat.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : list of Augmenter</span>
<span class="sd">            The children as a nested or flat list.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children_lists</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aug</span><span class="p">)</span>
                <span class="n">children</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">get_all_children</span><span class="p">(</span><span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Augmenter.find_augmenters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.find_augmenters">[docs]</a>    <span class="k">def</span> <span class="nf">find_augmenters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find augmenters that match a condition.</span>
<span class="sd">        This function will compare this augmenter and all of its children</span>
<span class="sd">        with a condition. The condition is a lambda function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            A function that receives an Augmenter instance and a list of</span>
<span class="sd">            parent Augmenter instances and must return True, if that</span>
<span class="sd">            augmenter is valid match.</span>

<span class="sd">        parents : None or list of Augmenter, optional</span>
<span class="sd">            List of parent augmenters.</span>
<span class="sd">            Intended for nested calls and can usually be left as None.</span>

<span class="sd">        flat : bool, optional</span>
<span class="sd">            Whether to return the result as a flat list (True)</span>
<span class="sd">            or a nested list (False). In the latter case, the nesting matches</span>
<span class="sd">            each augmenters position among the children.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        augmenters : list of Augmenter</span>
<span class="sd">            Nested list if flat was set to False.</span>
<span class="sd">            Flat list if flat was set to True.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; aug = iaa.Sequential([</span>
<span class="sd">        &gt;&gt;&gt;     nn.Fliplr(0.5, name=&quot;fliplr&quot;),</span>
<span class="sd">        &gt;&gt;&gt;     nn.Flipud(0.5, name=&quot;flipud&quot;)</span>
<span class="sd">        &gt;&gt;&gt; ])</span>
<span class="sd">        &gt;&gt;&gt; print(aug.find_augmenters(lambda a, parents: a.name == &quot;fliplr&quot;))</span>

<span class="sd">        This will return the first child augmenter (Fliplr instance).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parents</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">subparents</span> <span class="o">=</span> <span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children_lists</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">find_augmenters</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">subparents</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">found</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">found</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Augmenter.find_augmenters_by_name"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.find_augmenters_by_name">[docs]</a>    <span class="k">def</span> <span class="nf">find_augmenters_by_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find augmenter(s) by name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of the augmenter(s) to search for.</span>

<span class="sd">        regex : bool, optional</span>
<span class="sd">            Whether `name` parameter is a regular expression.</span>

<span class="sd">        flat : bool, optional</span>
<span class="sd">            See `Augmenter.find_augmenters()`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        augmenters : list of Augmenter objects</span>
<span class="sd">            Nested list if flat was set to False.</span>
<span class="sd">            Flat list if flat was set to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_augmenters_by_names</span><span class="p">([</span><span class="n">name</span><span class="p">],</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span></div>

<div class="viewcode-block" id="Augmenter.find_augmenters_by_names"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.find_augmenters_by_names">[docs]</a>    <span class="k">def</span> <span class="nf">find_augmenters_by_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find augmenter(s) by names.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : list of string</span>
<span class="sd">            Names of the augmenter(s) to search for.</span>

<span class="sd">        regex : bool, optional</span>
<span class="sd">            Whether `names` is a list of regular expressions.</span>

<span class="sd">        flat : boolean, optional</span>
<span class="sd">            See `Augmenter.find_augmenters()`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        augmenters : list of Augmenter</span>
<span class="sd">            Nested list if flat was set to False.</span>
<span class="sd">            Flat list if flat was set to True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">regex</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">comparer</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span> <span class="n">parents</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">aug</span><span class="o">.</span><span class="n">name</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_augmenters</span><span class="p">(</span><span class="n">comparer</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_augmenters</span><span class="p">(</span><span class="k">lambda</span> <span class="n">aug</span><span class="p">,</span> <span class="n">parents</span><span class="p">:</span> <span class="n">aug</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span></div>

<div class="viewcode-block" id="Augmenter.remove_augmenters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.remove_augmenters">[docs]</a>    <span class="k">def</span> <span class="nf">remove_augmenters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">noop_if_topmost</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove this augmenter or its children that match a condition.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            Condition to match per augmenter.</span>
<span class="sd">            The function must expect the augmenter itself and a list of parent</span>
<span class="sd">            augmenters and returns True if that augmenter is to be removed,</span>
<span class="sd">            or False otherwise.</span>
<span class="sd">            E.g. `lambda a, parents: a.name == &quot;fliplr&quot; and len(parents) == 1`</span>
<span class="sd">            removes an augmenter with name &quot;fliplr&quot; if it is the direct child</span>
<span class="sd">            of the augmenter upon which `remove_augmenters()` was initially called.</span>

<span class="sd">        copy : bool, optional</span>
<span class="sd">            Whether to copy this augmenter and all if its children before</span>
<span class="sd">            removing. If False, removal is performed in-place.</span>

<span class="sd">        noop_if_topmost : bool, optional</span>
<span class="sd">            If True and the condition (lambda function) leads to the removal</span>
<span class="sd">            of the topmost augmenter (the one this function is called on</span>
<span class="sd">            initially), then that topmost augmenter will be replaced by a</span>
<span class="sd">            Noop instance (i.e. an object will still knows `augment_images()`,</span>
<span class="sd">            but doesnt change images). If False, None will be returned in</span>
<span class="sd">            these cases.</span>
<span class="sd">            This can only be False if copy is set to True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aug : Augmenter or None</span>
<span class="sd">            This augmenter after the removal was performed.</span>
<span class="sd">            Is None iff condition was matched for the topmost augmenter,</span>
<span class="sd">            copy was set to True and `noop_if_topmost` was set to False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; seq = iaa.Sequential([</span>
<span class="sd">        &gt;&gt;&gt;     iaa.Fliplr(0.5, name=&quot;fliplr&quot;),</span>
<span class="sd">        &gt;&gt;&gt;     iaa.Flipud(0.5, name=&quot;flipud&quot;),</span>
<span class="sd">        &gt;&gt;&gt; ])</span>
<span class="sd">        &gt;&gt;&gt; seq = seq.remove_augmenters(lambda a, parents: a.name == &quot;fliplr&quot;)</span>

<span class="sd">        This removes the augmenter Fliplr from the Sequential object&#39;s children.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Inplace removal of topmost augmenter requested, which is currently not possible.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">noop_if_topmost</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Noop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">()</span>
            <span class="n">aug</span><span class="o">.</span><span class="n">remove_augmenters_inplace</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="p">[])</span>
            <span class="k">return</span> <span class="n">aug</span></div>

<div class="viewcode-block" id="Augmenter.remove_augmenters_inplace"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.remove_augmenters_inplace">[docs]</a>    <span class="k">def</span> <span class="nf">remove_augmenters_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove in-place children of this augmenter that match a condition.</span>

<span class="sd">        This is functionally identical to `remove_augmenters()` with</span>
<span class="sd">        `copy=False`, except that it does not affect the topmost augmenter</span>
<span class="sd">        (the one on which this function is initially called on).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            See `Augmenter.remove_augmenters()`.</span>

<span class="sd">        parents : None or list of Augmenter, optional</span>
<span class="sd">            List of parent Augmenter instances that lead to this</span>
<span class="sd">            Augmenter. If None, an empty list will be used.</span>
<span class="sd">            This parameter can usually be left empty and will be set</span>
<span class="sd">            automatically for children.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; seq = iaa.Sequential([</span>
<span class="sd">        &gt;&gt;&gt;     iaa.Fliplr(0.5, name=&quot;fliplr&quot;),</span>
<span class="sd">        &gt;&gt;&gt;    iaa.Flipud(0.5, name=&quot;flipud&quot;),</span>
<span class="sd">        &gt;&gt;&gt; ])</span>
<span class="sd">        &gt;&gt;&gt; seq.remove_augmenters_inplace(lambda a, parents: a.name == &quot;fliplr&quot;)</span>

<span class="sd">        This removes the augmenter Fliplr from the Sequential object&#39;s children.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">parents</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">parents</span>
        <span class="n">subparents</span> <span class="o">=</span> <span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_children_lists</span><span class="p">():</span>
            <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">aug</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span> <span class="n">subparents</span><span class="p">):</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">aug</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">count_removed</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">aug</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">to_remove</span><span class="p">):</span>
                <span class="c1"># self._remove_augmenters_inplace_from_list(lst, aug, i, i - count_removed)</span>
                <span class="k">del</span> <span class="n">lst</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">count_removed</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                <span class="n">aug</span><span class="o">.</span><span class="n">remove_augmenters_inplace</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">subparents</span><span class="p">)</span></div>

    <span class="c1"># TODO</span>
    <span class="c1"># def to_json(self):</span>
    <span class="c1">#    pass</span>

<div class="viewcode-block" id="Augmenter.copy"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a shallow copy of this Augmenter instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aug : Augmenter</span>
<span class="sd">            Shallow copy of this Augmenter instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy_module</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Augmenter.deepcopy"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Augmenter.deepcopy">[docs]</a>    <span class="k">def</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a deep copy of this Augmenter instance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        aug : Augmenter</span>
<span class="sd">            Deep copy of this Augmenter instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy_module</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameters</span><span class="p">()</span>
        <span class="n">params_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">param</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">])</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(name=</span><span class="si">%s</span><span class="s2">, parameters=[</span><span class="si">%s</span><span class="s2">], deterministic=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">params_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">)</span></div>


<div class="viewcode-block" id="Sequential"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Sequential">[docs]</a><span class="k">class</span> <span class="nc">Sequential</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List augmenter that may contain other augmenters to apply in sequence</span>
<span class="sd">    or random order.</span>

<span class="sd">    NOTE: You are *not* forced to use `Sequential` in order to use other</span>
<span class="sd">    augmenters. Each augmenter can be used on its own, e.g the following</span>
<span class="sd">    defines an augmenter for horizontal flips and then augments a single</span>
<span class="sd">    image::</span>
<span class="sd">        aug = iaa.Fliplr(0.5)</span>
<span class="sd">        image_aug = aug.augment_image(image)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    children : Augmenter or list of Augmenter or None, optional(default=None)</span>
<span class="sd">        The augmenters to apply to images.</span>

<span class="sd">    random_order : bool, optional(default=False)</span>
<span class="sd">        Whether to apply the child augmenters in random order per image.</span>
<span class="sd">        The order is resampled for each image.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; seq = iaa.Sequential([</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(0.5),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Flipud(0.5)</span>
<span class="sd">    &gt;&gt;&gt; ])</span>
<span class="sd">    &gt;&gt;&gt; imgs_aug = seq.augment_images(imgs)</span>

<span class="sd">    Calls always first the horizontal flip augmenter and then the vertical</span>
<span class="sd">    flip augmenter (each having a probability of 50 percent to be used).</span>

<span class="sd">    &gt;&gt;&gt; seq = iaa.Sequential([</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(0.5),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Flipud(0.5)</span>
<span class="sd">    &gt;&gt;&gt; ], random_order=True)</span>
<span class="sd">    &gt;&gt;&gt; imgs_aug = seq.augment_images(imgs)</span>

<span class="sd">    Calls sometimes first the horizontal flip augmenter and sometimes first the</span>
<span class="sd">    vertical flip augmenter (each again with 50 percent probability to be used).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Augmenter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">Augmenter</span><span class="p">):</span>
            <span class="c1"># this must be separate from `list.__init__(self, children)`,</span>
            <span class="c1"># otherwise in `Sequential(OneOf(...))` the OneOf(...) is</span>
            <span class="c1"># interpreted as a list and OneOf&#39;s children become Sequential&#39;s</span>
            <span class="c1"># children</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">children</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">children</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Augmenter</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected None or Augmenter or list of Augmenter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">children</span><span class="p">),))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_order</span> <span class="o">=</span> <span class="n">random_order</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_order</span><span class="p">:</span>
                <span class="c1"># for augmenter in self.children:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                    <span class="n">images</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                        <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">,</span>
                        <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                        <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># for augmenter in self.children:</span>
                <span class="k">for</span> <span class="n">augmenter</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">images</span> <span class="o">=</span> <span class="n">augmenter</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                        <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">,</span>
                        <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                        <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">images</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_order</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                    <span class="n">keypoints_on_images</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                        <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">keypoints_on_images</span><span class="p">,</span>
                        <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                        <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">augmenter</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">keypoints_on_images</span> <span class="o">=</span> <span class="n">augmenter</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                        <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">keypoints_on_images</span><span class="p">,</span>
                        <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                        <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">keypoints_on_images</span>

    <span class="k">def</span> <span class="nf">_to_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">augs</span> <span class="o">=</span> <span class="p">[</span><span class="n">aug</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span> <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">seq</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">augs</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">()</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">seq</span>

<div class="viewcode-block" id="Sequential.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Sequential.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_order</span><span class="p">]</span></div>

<div class="viewcode-block" id="Sequential.add"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Sequential.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">augmenter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an augmenter to the list of child augmenters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        augmenter : Augmenter</span>
<span class="sd">            The augmenter to add.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">augmenter</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sequential.get_children_lists"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Sequential.get_children_lists">[docs]</a>    <span class="k">def</span> <span class="nf">get_children_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">augs_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">aug</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">return</span> <span class="s2">&quot;Sequential(name=</span><span class="si">%s</span><span class="s2">, random_order=</span><span class="si">%s</span><span class="s2">, children=[</span><span class="si">%s</span><span class="s2">], deterministic=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_order</span><span class="p">,</span> <span class="n">augs_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">)</span></div>

<div class="viewcode-block" id="SomeOf"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.SomeOf">[docs]</a><span class="k">class</span> <span class="nc">SomeOf</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    List augmenter that applies only some of its children to images.</span>

<span class="sd">    E.g. this allows to define a list of 20 augmenters, but only apply a</span>
<span class="sd">    random selection of 5 of them to each image.</span>

<span class="sd">    This augmenter currently does not support replacing (i.e. picking the same</span>
<span class="sd">    child multiple times) due to implementation difficulties in connection</span>
<span class="sd">    with deterministic augmenters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int or tuple of two ints or list of ints or StochasticParameter or None, optional(default=None)</span>
<span class="sd">        Count of augmenters to</span>
<span class="sd">        apply.</span>
<span class="sd">            * If int n, then exactly n of the child augmenters are applied to</span>
<span class="sd">              every image.</span>
<span class="sd">            * If tuple of two ints (a, b), then a &lt;= x &lt;= b augmenters are</span>
<span class="sd">              picked and applied to every image. Here, b may be set to None,</span>
<span class="sd">              then it will automatically replaced with the total number of</span>
<span class="sd">              available children.</span>
<span class="sd">            * If StochasticParameter, then N numbers will be sampled for N images.</span>
<span class="sd">              The parameter is expected to be discrete.</span>
<span class="sd">            * If None, then the total number of available children will be</span>
<span class="sd">              used (i.e. all children will be applied).</span>

<span class="sd">    children : Augmenter or list of Augmenter or None, optional(default=None)</span>
<span class="sd">        The augmenters to apply to images.</span>

<span class="sd">    random_order : boolean, optional(default=False)</span>
<span class="sd">        Whether to apply the child augmenters in random order per image.</span>
<span class="sd">        The order is resampled for each image.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; seq = iaa.SomeOf(1, [</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(1.0),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Flipud(1.0)</span>
<span class="sd">    &gt;&gt;&gt; ])</span>
<span class="sd">    &gt;&gt;&gt; imgs_aug = seq.augment_images(imgs)</span>

<span class="sd">    Applies either Fliplr or Flipud to images.</span>

<span class="sd">    &gt;&gt;&gt; seq = iaa.SomeOf((1, 3), [</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(1.0),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Flipud(1.0),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.GaussianBlur(1.0)</span>
<span class="sd">    &gt;&gt;&gt; ])</span>
<span class="sd">    &gt;&gt;&gt; imgs_aug = seq.augment_images(imgs)</span>

<span class="sd">    Applies one to three of the listed augmenters (Fliplr, Flipud,</span>
<span class="sd">    GaussianBlur) to images. They are always applied in the</span>
<span class="sd">    order (1st) Fliplr, (2nd) Flipud, (3rd) GaussianBlur.</span>

<span class="sd">    &gt;&gt;&gt; seq = iaa.SomeOf((1, None), [</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(1.0),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Flipud(1.0),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.GaussianBlur(1.0)</span>
<span class="sd">    &gt;&gt;&gt; ], random_order=True)</span>
<span class="sd">    &gt;&gt;&gt; imgs_aug = seq.augment_images(imgs)</span>

<span class="sd">    Applies one to all of the listed augmenters (Fliplr, Flipud,</span>
<span class="sd">    GaussianBlur) to images. They are applied in random order, i.e.</span>
<span class="sd">    sometimes Blur first, followed by Fliplr, sometimes Fliplr follow by</span>
<span class="sd">    Flipud followed by Blur, sometimes Flipud follow by Blur, etc.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">random_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">Augmenter</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">Augmenter</span><span class="p">):</span>
            <span class="c1"># this must be separate from `list.__init__(self, children)`,</span>
            <span class="c1"># otherwise in `SomeOf(OneOf(...))` the OneOf(...) is</span>
            <span class="c1"># interpreted as a list and OneOf&#39;s children become SomeOf&#39;s</span>
            <span class="c1"># children</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">children</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">children</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Augmenter</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>
            <span class="nb">list</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected None or Augmenter or list of Augmenter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">children</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">=</span> <span class="s2">&quot;deterministic&quot;</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">=</span> <span class="s2">&quot;(int,None)&quot;</span>
            <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">=</span> <span class="s2">&quot;stochastic&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected tuple of (int, None) or (int, int), got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">el</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">n</span><span class="p">],))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">=</span> <span class="s2">&quot;stochastic&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected int, (int, None), (int, int) or StochasticParameter, got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">),))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">random_order</span> <span class="o">=</span> <span class="n">random_order</span>

    <span class="k">def</span> <span class="nf">_get_n</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">==</span> <span class="s2">&quot;deterministic&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb_images</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">==</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nb_images</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">==</span> <span class="s2">&quot;(int,None)&quot;</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span> <span class="o">==</span> <span class="s2">&quot;stochastic&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid n_mode: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_mode</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">_get_augmenter_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_order</span><span class="p">:</span>
            <span class="n">augmenter_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">augmenter_order</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">augmenter_order</span>

    <span class="k">def</span> <span class="nf">_get_augmenter_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_rows</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_n</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        <span class="c1">#if not self.replace:</span>
        <span class="c1">#    nn = [min(n, len(self)) for n in nn]</span>
        <span class="c1">#augmenter_indices = [</span>
        <span class="c1">#    random_state.choice(len(self.children), size=(min(n, len(self)),), replace=False]) for n in nn</span>
        <span class="c1">#]</span>
        <span class="n">nn</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nn</span><span class="p">]</span>
        <span class="n">augmenter_active</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nb_rows</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row_idx</span><span class="p">,</span> <span class="n">n_true</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nn</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n_true</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">augmenter_active</span><span class="p">[</span><span class="n">row_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_true</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">augmenter_active</span><span class="p">:</span>
            <span class="n">random_state</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">augmenter_active</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">input_is_array</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

            <span class="c1"># This must happen before creating the augmenter_active array,</span>
            <span class="c1"># otherwise in case of determinism the number of augmented images</span>
            <span class="c1"># would change the random_state&#39;s state, resulting in the order</span>
            <span class="c1"># being dependent on the number of augmented images (and not be</span>
            <span class="c1"># constant). By doing this first, the random state is always the</span>
            <span class="c1"># same (when determinism is active), so the order is always the</span>
            <span class="c1"># same.</span>
            <span class="n">augmenter_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_augmenter_order</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

            <span class="c1"># create an array of active augmenters per image</span>
            <span class="c1"># e.g.</span>
            <span class="c1">#  [[0, 0, 1],</span>
            <span class="c1">#   [1, 0, 1],</span>
            <span class="c1">#   [1, 0, 0]]</span>
            <span class="c1"># would signal, that augmenter 3 is active for the first image,</span>
            <span class="c1"># augmenter 1 and 3 for the 2nd image and augmenter 1 for the 3rd.</span>
            <span class="n">augmenter_active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_augmenter_active</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="n">random_state</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">augmenter_index</span> <span class="ow">in</span> <span class="n">augmenter_order</span><span class="p">:</span>
                <span class="n">active</span> <span class="o">=</span> <span class="n">augmenter_active</span><span class="p">[:,</span> <span class="n">augmenter_index</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">active</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># pick images to augment, i.e. images for which</span>
                    <span class="c1"># augmenter at current index is active</span>
                    <span class="k">if</span> <span class="n">input_is_array</span><span class="p">:</span>
                        <span class="n">images_to_aug</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">active</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">images_to_aug</span> <span class="o">=</span> <span class="p">[</span><span class="n">images</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">active</span><span class="p">]</span>

                    <span class="c1"># augment the images</span>
                    <span class="n">images_to_aug</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">augmenter_index</span><span class="p">]</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                        <span class="n">images</span><span class="o">=</span><span class="n">images_to_aug</span><span class="p">,</span>
                        <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                        <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                    <span class="p">)</span>
                    <span class="n">output_is_array</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images_to_aug</span><span class="p">)</span>
                    <span class="n">output_all_same_shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">img</span> <span class="ow">in</span> <span class="n">images_to_aug</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span>

                    <span class="c1"># Map them back to their position in the images array/list</span>
                    <span class="c1"># But it can happen that the augmented images have different shape(s) from</span>
                    <span class="c1"># the input image, as well as being suddenly a list instead of a numpy array.</span>
                    <span class="c1"># This is usually the case if a child augmenter has to change shapes, e.g.</span>
                    <span class="c1"># due to cropping (without resize afterwards). So accomodate here for that</span>
                    <span class="c1"># possibility.</span>
                    <span class="k">if</span> <span class="n">input_is_array</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_is_array</span> <span class="ow">and</span> <span class="n">output_all_same_shape</span><span class="p">:</span>
                            <span class="n">images_to_aug</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">images_to_aug</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">images</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                            <span class="n">output_is_array</span> <span class="o">=</span> <span class="kc">True</span>

                        <span class="k">if</span> <span class="n">output_is_array</span> <span class="ow">and</span> <span class="n">images_to_aug</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                            <span class="n">images</span><span class="p">[</span><span class="n">active</span><span class="p">]</span> <span class="o">=</span> <span class="n">images_to_aug</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">images</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">aug_idx</span><span class="p">,</span> <span class="n">original_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active</span><span class="p">):</span>
                                <span class="n">images</span><span class="p">[</span><span class="n">original_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">images_to_aug</span><span class="p">[</span><span class="n">aug_idx</span><span class="p">]</span>
                            <span class="n">input_is_array</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">aug_idx</span><span class="p">,</span> <span class="n">original_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active</span><span class="p">):</span>
                            <span class="n">images</span><span class="p">[</span><span class="n">original_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">images_to_aug</span><span class="p">[</span><span class="n">aug_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">images</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="c1"># This must happen before creating the augmenter_active array,</span>
            <span class="c1"># otherwise in case of determinism the number of augmented images</span>
            <span class="c1"># would change the random_state&#39;s state, resulting in the order</span>
            <span class="c1"># being dependent on the number of augmented images (and not be</span>
            <span class="c1"># constant). By doing this first, the random state is always the</span>
            <span class="c1"># same (when determinism is active), so the order is always the</span>
            <span class="c1"># same.</span>
            <span class="n">augmenter_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_augmenter_order</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>

            <span class="c1"># create an array of active augmenters per image</span>
            <span class="c1"># e.g.</span>
            <span class="c1">#  [[0, 0, 1],</span>
            <span class="c1">#   [1, 0, 1],</span>
            <span class="c1">#   [1, 0, 0]]</span>
            <span class="c1"># would signal, that augmenter 3 is active for the first image,</span>
            <span class="c1"># augmenter 1 and 3 for the 2nd image and augmenter 1 for the 3rd.</span>
            <span class="n">augmenter_active</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_augmenter_active</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">),</span> <span class="n">random_state</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">augmenter_index</span> <span class="ow">in</span> <span class="n">augmenter_order</span><span class="p">:</span>
                <span class="n">active</span> <span class="o">=</span> <span class="n">augmenter_active</span><span class="p">[:,</span> <span class="n">augmenter_index</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">active</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># pick images to augment, i.e. images for which</span>
                    <span class="c1"># augmenter at current index is active</span>
                    <span class="n">koi_to_aug</span> <span class="o">=</span> <span class="p">[</span><span class="n">keypoints_on_images</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">active</span><span class="p">]</span>

                    <span class="c1"># augment the images</span>
                    <span class="n">koi_to_aug</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">augmenter_index</span><span class="p">]</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                        <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">koi_to_aug</span><span class="p">,</span>
                        <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                        <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                    <span class="p">)</span>

                    <span class="c1"># map them back to their position in the images array/list</span>
                    <span class="k">for</span> <span class="n">aug_idx</span><span class="p">,</span> <span class="n">original_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">active</span><span class="p">):</span>
                        <span class="n">keypoints_on_images</span><span class="p">[</span><span class="n">original_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">koi_to_aug</span><span class="p">[</span><span class="n">aug_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">keypoints_on_images</span>

    <span class="k">def</span> <span class="nf">_to_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">augs</span> <span class="o">=</span> <span class="p">[</span><span class="n">aug</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span> <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">seq</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">augs</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">()</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">seq</span>

<div class="viewcode-block" id="SomeOf.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.SomeOf.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="SomeOf.add"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.SomeOf.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">augmenter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add an augmenter to the list of child augmenters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        augmenter : Augmenter</span>
<span class="sd">            The augmenter to add.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">augmenter</span><span class="p">)</span></div>

<div class="viewcode-block" id="SomeOf.get_children_lists"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.SomeOf.get_children_lists">[docs]</a>    <span class="k">def</span> <span class="nf">get_children_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># augs_str = &quot;, &quot;.join([aug.__str__() for aug in self.children])</span>
        <span class="n">augs_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">aug</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="k">for</span> <span class="n">aug</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
        <span class="k">return</span> <span class="s2">&quot;SomeOf(name=</span><span class="si">%s</span><span class="s2">, n=</span><span class="si">%s</span><span class="s2">, random_order=</span><span class="si">%s</span><span class="s2">, augmenters=[</span><span class="si">%s</span><span class="s2">], deterministic=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_order</span><span class="p">),</span> <span class="n">augs_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">)</span></div>

<div class="viewcode-block" id="OneOf"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.OneOf">[docs]</a><span class="k">def</span> <span class="nf">OneOf</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter that always executes exactly one of its children.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    children : list of Augmenter</span>
<span class="sd">        The choices of augmenters to apply.</span>

<span class="sd">    random_order : boolean, optional(default=False)</span>
<span class="sd">        Whether to apply the child augmenters in random order per image.</span>
<span class="sd">        The order is resampled for each image.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; seq = iaa.OneOf([</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(1.0),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Flipud(1.0)</span>
<span class="sd">    &gt;&gt;&gt; ])</span>
<span class="sd">    &gt;&gt;&gt; imgs_aug = seq.augment_images(imgs)</span>

<span class="sd">    flips each image either horizontally or vertically.</span>


<span class="sd">    &gt;&gt;&gt; seq = iaa.OneOf([</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(1.0),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Sequential([</span>
<span class="sd">    &gt;&gt;&gt;         iaa.GaussianBlur(1.0),</span>
<span class="sd">    &gt;&gt;&gt;         iaa.Dropout(0.05),</span>
<span class="sd">    &gt;&gt;&gt;         iaa.AdditiveGaussianNoise(0.1*255)</span>
<span class="sd">    &gt;&gt;&gt;     ]),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Noop()</span>
<span class="sd">    &gt;&gt;&gt; ])</span>
<span class="sd">    &gt;&gt;&gt; imgs_aug = seq.augment_images(imgs)</span>

<span class="sd">    either flips each image horizontally, or ads blur+dropout+noise or does</span>
<span class="sd">    nothing.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">SomeOf</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">children</span><span class="p">,</span> <span class="n">random_order</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sometimes"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Sometimes">[docs]</a><span class="k">class</span> <span class="nc">Sometimes</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augment only p percent of all images with one or more augmenters.</span>

<span class="sd">    Let C be one or more child augmenters given to Sometimes.</span>
<span class="sd">    Let p be the percent of images to augment.</span>
<span class="sd">    Let I be the input images.</span>
<span class="sd">    Then (on average) p percent of all images in I will be augmented using C.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    p : float or StochasticParameter, optional(default=0.5)</span>
<span class="sd">        Sets the probability with which the given augmenters will be applied to</span>
<span class="sd">        input images. E.g. a value of 0.5 will result in 50 percent of all</span>
<span class="sd">        input images being augmented.</span>

<span class="sd">    then_list : None or Augmenter or list of Augmenters, optional(default=None)</span>
<span class="sd">        Augmenter(s) to apply to p percent of all images.</span>

<span class="sd">    else_list : None or Augmenter or list of Augmenters, optional(default=None)</span>
<span class="sd">        Augmenter(s) to apply to (1-p) percent of all images.</span>
<span class="sd">        These augmenters will be applied only when the ones in then_list</span>
<span class="sd">        are NOT applied (either-or-relationship).</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.Sometimes(0.5, iaa.GaussianBlur(0.3))</span>

<span class="sd">    when calling `aug.augment_images()`, only (on average) 50 percent of</span>
<span class="sd">    all images will be blurred.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Sometimes(0.5, iaa.GaussianBlur(0.3), iaa.Fliplr(1.0))</span>

<span class="sd">    when calling `aug.augment_images()`, (on average) 50 percent of all images</span>
<span class="sd">    will be blurred, the other (again, on average) 50 percent will be</span>
<span class="sd">    horizontally flipped.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">then_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">else_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Sometimes</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">Binomial</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float/int in range [0, 1] or StochasticParameter as p, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">),))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">then_list</span> <span class="o">=</span> <span class="n">handle_children_list</span><span class="p">(</span><span class="n">then_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;then&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">else_list</span> <span class="o">=</span> <span class="n">handle_children_list</span><span class="p">(</span><span class="n">else_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;else&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">input_is_np_array</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">input_is_np_array</span><span class="p">:</span>
                <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">dtype</span>

            <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

            <span class="c1"># create lists/arrays of images for if and else lists (one for each)</span>
            <span class="n">indices_then_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">samples</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># np.where returns tuple(array([0, 5, 9, ...])) or tuple(array([]))</span>
            <span class="n">indices_else_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">images_then_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices_then_list</span><span class="p">]</span>
                <span class="n">images_else_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices_else_list</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">images_then_list</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">indices_then_list</span><span class="p">]</span>
                <span class="n">images_else_list</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">indices_else_list</span><span class="p">]</span>

            <span class="c1"># augment according to if and else list</span>
            <span class="n">result_then_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">then_list</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                <span class="n">images</span><span class="o">=</span><span class="n">images_then_list</span><span class="p">,</span>
                <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
            <span class="p">)</span>
            <span class="n">result_else_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_list</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                <span class="n">images</span><span class="o">=</span><span class="n">images_else_list</span><span class="p">,</span>
                <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
            <span class="p">)</span>

            <span class="c1"># map results of if/else lists back to their initial positions (in &quot;images&quot; variable)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx_result_then_list</span><span class="p">,</span> <span class="n">idx_images</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices_then_list</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">idx_images</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_then_list</span><span class="p">[</span><span class="n">idx_result_then_list</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx_result_else_list</span><span class="p">,</span> <span class="n">idx_images</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices_else_list</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">idx_images</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_else_list</span><span class="p">[</span><span class="n">idx_result_else_list</span><span class="p">]</span>

            <span class="c1"># If input was a list, keep the output as a list too,</span>
            <span class="c1"># otherwise it was a numpy array, so make the output a numpy array too.</span>
            <span class="c1"># Note here though that shapes can differ between images, e.g. when using Crop</span>
            <span class="c1"># without resizing. In these cases, the output has to be a list.</span>
            <span class="n">all_same_shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">input_is_np_array</span> <span class="ow">and</span> <span class="n">all_same_shape</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">input_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="c1"># TODO this is mostly copy pasted from _augment_images, make dry</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

            <span class="c1"># create lists/arrays of images for if and else lists (one for each)</span>
            <span class="n">indices_then_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">samples</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># np.where returns tuple(array([0, 5, 9, ...])) or tuple(array([]))</span>
            <span class="n">indices_else_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">samples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">images_then_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">keypoints_on_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices_then_list</span><span class="p">]</span>
            <span class="n">images_else_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">keypoints_on_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices_else_list</span><span class="p">]</span>

            <span class="c1"># augment according to if and else list</span>
            <span class="n">result_then_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">then_list</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">images_then_list</span><span class="p">,</span>
                <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
            <span class="p">)</span>
            <span class="n">result_else_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_list</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">images_else_list</span><span class="p">,</span>
                <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
            <span class="p">)</span>

            <span class="c1"># map results of if/else lists back to their initial positions (in &quot;images&quot; variable)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx_result_then_list</span><span class="p">,</span> <span class="n">idx_images</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices_then_list</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">idx_images</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_then_list</span><span class="p">[</span><span class="n">idx_result_then_list</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx_result_else_list</span><span class="p">,</span> <span class="n">idx_images</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices_else_list</span><span class="p">):</span>
                <span class="n">result</span><span class="p">[</span><span class="n">idx_images</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_else_list</span><span class="p">[</span><span class="n">idx_result_else_list</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_to_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">then_list</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">then_list</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">else_list</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">else_list</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">aug</span>

<div class="viewcode-block" id="Sometimes.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Sometimes.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">]</span></div>

<div class="viewcode-block" id="Sometimes.get_children_lists"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Sometimes.get_children_lists">[docs]</a>    <span class="k">def</span> <span class="nf">get_children_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">then_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_list</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Sometimes(p=</span><span class="si">%s</span><span class="s2">, name=</span><span class="si">%s</span><span class="s2">, then_list=</span><span class="si">%s</span><span class="s2">, else_list=</span><span class="si">%s</span><span class="s2">, deterministic=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">then_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">else_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">)</span></div>

<div class="viewcode-block" id="WithChannels"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.WithChannels">[docs]</a><span class="k">class</span> <span class="nc">WithChannels</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply child augmenters to specific channels.</span>

<span class="sd">    Let C be one or more child augmenters given to this augmenter.</span>
<span class="sd">    Let H be a list of channels.</span>
<span class="sd">    Let I be the input images.</span>
<span class="sd">    Then this augmenter will pick the channels H from each image</span>
<span class="sd">    in I (resulting in new images) and apply C to them.</span>
<span class="sd">    The result of the augmentation will be merged back into the original</span>
<span class="sd">    images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    channels : integer or list of integers or None, optional(default=None)</span>
<span class="sd">        Sets the channels to extract from each image.</span>
<span class="sd">        If None, all channels will be used.</span>

<span class="sd">    children : Augmenter or list of Augmenters or None, optional(default=None)</span>
<span class="sd">        One or more augmenters to apply to images, after the channels</span>
<span class="sd">        are extracted.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.WithChannels([0], iaa.Add(10))</span>

<span class="sd">    assuming input images are RGB, then this augmenter will add 10 only</span>
<span class="sd">    to the first channel, i.e. make images more red.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WithChannels</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="p">[</span><span class="n">channels</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">]),</span> <span class="s2">&quot;Expected integers as channels, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">],))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected None, int or list of ints as channels, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">channels</span><span class="p">),))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">handle_children_list</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;then&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>
        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                    <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
                    <span class="n">images_then_list</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">images_then_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">]</span>

                <span class="n">result_then_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                    <span class="n">images</span><span class="o">=</span><span class="n">images_then_list</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>

                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span>
                    <span class="nb">all</span><span class="p">([</span><span class="n">img_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">img_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">img_out</span><span class="p">,</span> <span class="n">img_in</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">result_then_list</span><span class="p">,</span> <span class="n">result</span><span class="p">)]),</span>
                    <span class="s2">&quot;Heights/widths of images changed in WithChannels from </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">, but expected to be the same.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="nb">str</span><span class="p">([</span><span class="n">img_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">img_in</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]),</span>
                        <span class="nb">str</span><span class="p">([</span><span class="n">img_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">img_out</span> <span class="ow">in</span> <span class="n">result_then_list</span><span class="p">]),</span>
                    <span class="p">)</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_np_array</span><span class="p">(</span><span class="n">images</span><span class="p">):</span>
                    <span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_then_list</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)):</span>
                        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_then_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">keypoints_on_images</span>

    <span class="k">def</span> <span class="nf">_to_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">aug</span>

<div class="viewcode-block" id="WithChannels.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.WithChannels.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]</span></div>

<div class="viewcode-block" id="WithChannels.get_children_lists"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.WithChannels.get_children_lists">[docs]</a>    <span class="k">def</span> <span class="nf">get_children_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;WithChannels(channels=</span><span class="si">%s</span><span class="s2">, name=</span><span class="si">%s</span><span class="s2">, children=</span><span class="si">%s</span><span class="s2">, deterministic=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">deterministic</span><span class="p">)</span></div>

<div class="viewcode-block" id="Noop"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Noop">[docs]</a><span class="k">class</span> <span class="nc">Noop</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter that never changes input images (&quot;no operation&quot;).</span>

<span class="sd">    This augmenter is useful when you just want to use a placeholder augmenter</span>
<span class="sd">    in some situation, so that you can continue to call `augment_images()`,</span>
<span class="sd">    without actually changing them (e.g. when switching from training to test).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#Augmenter.__init__(self, name=name, deterministic=deterministic, random_state=random_state)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Noop</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">images</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">keypoints_on_images</span>

<div class="viewcode-block" id="Noop.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Noop.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span></div></div>


<div class="viewcode-block" id="Lambda"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Lambda">[docs]</a><span class="k">class</span> <span class="nc">Lambda</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter that calls a lambda function for each batch of input image.</span>

<span class="sd">    This is useful to add missing functions to a list of augmenters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func_images : callable,</span>
<span class="sd">        The function to call for each batch of images.</span>
<span class="sd">        It must follow the form</span>

<span class="sd">            ``function(images, random_state, parents, hooks)``</span>

<span class="sd">        and return the changed images (may be transformed in-place).</span>
<span class="sd">        This is essentially the interface of `Augmenter._augment_images()`.</span>

<span class="sd">    func_keypoints : callable,</span>
<span class="sd">        The function to call for each batch of image keypoints.</span>
<span class="sd">        It must follow the form</span>

<span class="sd">            ``function(keypoints_on_images, random_state, parents, hooks)``</span>

<span class="sd">        and return the changed keypoints (may be transformed in-place).</span>
<span class="sd">        This is essentially the interface of `Augmenter._augment_keypoints()`.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; def func_images(images, random_state, parents, hooks):</span>
<span class="sd">    &gt;&gt;&gt;     images[:, ::2, :, :] = 0</span>
<span class="sd">    &gt;&gt;&gt;     return images</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def func_keypoints(keypoints_on_images, random_state, parents, hooks):</span>
<span class="sd">    &gt;&gt;&gt;     return keypoints_on_images</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.Lambda(</span>
<span class="sd">    &gt;&gt;&gt;     func_images=func_images,</span>
<span class="sd">    &gt;&gt;&gt;     func_keypoints=func_keypoints</span>
<span class="sd">    &gt;&gt;&gt; )</span>

<span class="sd">    Replaces every second row in images with black pixels and leaves keypoints</span>
<span class="sd">    unchanged.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_images</span><span class="p">,</span> <span class="n">func_keypoints</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">#Augmenter.__init__(self, name=name, deterministic=deterministic, random_state=random_state)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Lambda</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_images</span> <span class="o">=</span> <span class="n">func_images</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_keypoints</span> <span class="o">=</span> <span class="n">func_keypoints</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_images</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_keypoints</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">)</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">ia</span><span class="o">.</span><span class="n">KeypointsOnImage</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Lambda.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.Lambda.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span></div></div>


<div class="viewcode-block" id="AssertLambda"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.AssertLambda">[docs]</a><span class="k">def</span> <span class="nf">AssertLambda</span><span class="p">(</span><span class="n">func_images</span><span class="p">,</span> <span class="n">func_keypoints</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter that runs an assert on each batch of input images</span>
<span class="sd">    using a lambda function as condition.</span>

<span class="sd">    This is useful to make generic assumption about the input images and error</span>
<span class="sd">    out early if they aren&#39;t met.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func_images : callable,</span>
<span class="sd">        The function to call for each batch of images.</span>
<span class="sd">        It must follow the form</span>
<span class="sd">            ``function(images, random_state, parents, hooks)``</span>
<span class="sd">        and return either True (valid input) or False (invalid input).</span>
<span class="sd">        It essentially reuses the interface of Augmenter._augment_images().</span>

<span class="sd">    func_keypoints : callable,</span>
<span class="sd">        The function to call for each batch of keypoints.</span>
<span class="sd">        It must follow the form</span>
<span class="sd">            ``function(keypoints_on_images, random_state, parents, hooks)``</span>
<span class="sd">        and return either True (valid input) or False (invalid input).</span>
<span class="sd">        It essentially reuses the interface of Augmenter._augment_keypoints().</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">func_images_assert</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">func_images</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">),</span> <span class="s2">&quot;Input images did not fulfill user-defined assertion in AssertLambda.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">images</span>
    <span class="k">def</span> <span class="nf">func_keypoints_assert</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">func_keypoints</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span><span class="p">),</span> <span class="s2">&quot;Input keypoints did not fulfill user-defined assertion in AssertLambda.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keypoints_on_images</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;UnnamedAssertLambda&quot;</span>
    <span class="k">return</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">func_images_assert</span><span class="p">,</span> <span class="n">func_keypoints_assert</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span></div>


<div class="viewcode-block" id="AssertShape"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.meta.AssertShape">[docs]</a><span class="k">def</span> <span class="nf">AssertShape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">check_images</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">check_keypoints</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter to make assumptions about the shape of input image(s)</span>
<span class="sd">    and keypoints.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple with each entry being None or tuple of two ints or list of ints</span>
<span class="sd">        The expected shape. Given as a tuple. The number of entries in the tuple</span>
<span class="sd">        must match the number of dimensions, i.e. usually four entries for</span>
<span class="sd">        (N, H, W, C).</span>
<span class="sd">            * If an entry is None, any value for that dimensions is accepted.</span>
<span class="sd">            * If an entry is int, exactly that integer value will be accepted</span>
<span class="sd">              or no other value.</span>
<span class="sd">            * If an entry is a tuple of two ints with values a and b, only a</span>
<span class="sd">              value x with a &lt;= x &lt; b will be accepted for the dimension.</span>
<span class="sd">            * If an entry is a list of ints, only a value for the dimension</span>
<span class="sd">              will be accepted which is contained in the list.</span>

<span class="sd">    check_images : bool, optional(default=True)</span>
<span class="sd">        Whether to validate input images via the given shape.</span>

<span class="sd">    check_keypoints : bool, optional(default=True)</span>
<span class="sd">        Whether to validate input keypoints via the given shape.</span>
<span class="sd">        The number of keypoints will be checked and for each KeypointsOnImage</span>
<span class="sd">        instance its image&#39;s shape, i.e. KeypointsOnImage.shape.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; seq = iaa.Sequential([</span>
<span class="sd">    &gt;&gt;&gt;     iaa.AssertShape((None, 32, 32, 3)),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(0.5)</span>
<span class="sd">    &gt;&gt;&gt; ])</span>

<span class="sd">    will first check for each image batch, if it contains a variable number of</span>
<span class="sd">    32x32 images with 3 channels each. Only if that check succeeds, the</span>
<span class="sd">    horizontal flip will be executed (otherwise an assertion error will be</span>
<span class="sd">    thrown).</span>

<span class="sd">    &gt;&gt;&gt; seq = iaa.Sequential([</span>
<span class="sd">    &gt;&gt;&gt;     iaa.AssertShape((None, (32, 64), 32, [1, 3])),</span>
<span class="sd">    &gt;&gt;&gt;     iaa.Fliplr(0.5)</span>
<span class="sd">    &gt;&gt;&gt; ])</span>

<span class="sd">    like above, but now the height may be in the range 32 &lt;= H &lt; 64 and</span>
<span class="sd">    the number of channels may be either 1 or 3.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;Expected shape to have length 4, got </span><span class="si">%d</span><span class="s2"> with shape: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">shape</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">image_index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">expected</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">expected</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">observed</span> <span class="o">==</span> <span class="n">expected</span><span class="p">,</span> <span class="s2">&quot;Expected dim </span><span class="si">%d</span><span class="s2"> (entry index: </span><span class="si">%s</span><span class="s2">) to have value </span><span class="si">%d</span><span class="s2">, got </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">observed</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">expected</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">expected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">observed</span> <span class="o">&lt;</span> <span class="n">expected</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Expected dim </span><span class="si">%d</span><span class="s2"> (entry index: </span><span class="si">%s</span><span class="s2">) to have value in range [</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">), got </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">image_index</span><span class="p">,</span> <span class="n">expected</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expected</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">observed</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">any</span><span class="p">([</span><span class="n">observed</span> <span class="o">==</span> <span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">expected</span><span class="p">]),</span> <span class="s2">&quot;Expected dim </span><span class="si">%d</span><span class="s2"> (entry index: </span><span class="si">%s</span><span class="s2">) to have any value of </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="n">image_index</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">expected</span><span class="p">),</span> <span class="n">observed</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid datatype for shape entry </span><span class="si">%d</span><span class="s2">, expected each entry to be an integer, a tuple (with two entries) or a list, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dimension</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">expected</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">func_images</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">check_images</span><span class="p">:</span>
            <span class="c1">#ia.do_assert(is_np_array(images), &quot;AssertShape can currently only handle numpy arrays, got &quot;)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">compare</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">),</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ALL&quot;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)):</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Expected image number </span><span class="si">%d</span><span class="s2"> to have a shape of length 3, got </span><span class="si">%d</span><span class="s2"> (shape: </span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">expected</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">observed</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">compare</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;Expected image&#39;s shape to have length 4, got </span><span class="si">%d</span><span class="s2"> (shape: </span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                    <span class="n">expected</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">observed</span> <span class="o">=</span> <span class="n">images</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">compare</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;ALL&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">images</span>

    <span class="k">def</span> <span class="nf">func_keypoints</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">check_keypoints</span><span class="p">:</span>
            <span class="c1">#ia.do_assert(is_np_array(images), &quot;AssertShape can currently only handle numpy arrays, got &quot;)</span>
            <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">compare</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">),</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ALL&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">)):</span>
                <span class="n">keypoints_on_image</span> <span class="o">=</span> <span class="n">keypoints_on_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])):</span>
                    <span class="n">expected</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">observed</span> <span class="o">=</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">compare</span><span class="p">(</span><span class="n">observed</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keypoints_on_images</span>

    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;UnnamedAssertShape&quot;</span>

    <span class="k">return</span> <span class="n">Lambda</span><span class="p">(</span><span class="n">func_images</span><span class="p">,</span> <span class="n">func_keypoints</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Alexander Jung.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.2.6',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>