

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>imgaug.augmenters.overlay &mdash; imgaug 0.2.6 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> imgaug
          

          
          </a>

          
            
            
              <div class="version">
                0.2.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/examples_basics.html">Examples: Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/数据预处理.html">数据预处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/数据预处理.html#field-objects">Field objects</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">imgaug</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>imgaug.augmenters.overlay</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for imgaug.augmenters.overlay</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Augmenters that overlay two images with each other.</span>

<span class="sd">Do not import directly from this file, as the categorization is not final.</span>
<span class="sd">Use instead</span>
<span class="sd">    `from imgaug import augmenters as iaa`</span>
<span class="sd">and then e.g. ::</span>

<span class="sd">    seq = iaa.Sequential([</span>
<span class="sd">        iaa.Alpha(0.5, iaa.Add((-5, 5)))</span>
<span class="sd">    ])</span>

<span class="sd">List of augmenters:</span>
<span class="sd">    * Alpha</span>
<span class="sd">    * AlphaElementwise</span>
<span class="sd">    * SimplexNoiseAlpha</span>
<span class="sd">    * FrequencyNoiseAlpha</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">imgaug</span> <span class="k">as</span> <span class="n">ia</span>
<span class="c1"># TODO replace these imports with iap.XYZ</span>
<span class="kn">from</span> <span class="nn">..parameters</span> <span class="k">import</span> <span class="n">StochasticParameter</span><span class="p">,</span> <span class="n">Deterministic</span><span class="p">,</span> <span class="n">Binomial</span><span class="p">,</span> <span class="n">Uniform</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">parameters</span> <span class="k">as</span> <span class="n">iap</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">six.moves</span> <span class="k">as</span> <span class="nn">sm</span>

<span class="kn">from</span> <span class="nn">.meta</span> <span class="k">import</span> <span class="n">Augmenter</span><span class="p">,</span> <span class="n">Sequential</span><span class="p">,</span> <span class="n">handle_children_list</span>

<span class="c1"># TODO tests</span>
<div class="viewcode-block" id="Alpha"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.overlay.Alpha">[docs]</a><span class="k">class</span> <span class="nc">Alpha</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span> <span class="c1"># pylint: disable=locally-disabled, unused-variable, line-too-long</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter to overlay two image sources with each other using an</span>
<span class="sd">    alpha/transparency value.</span>

<span class="sd">    The image sources can be imagined as branches.</span>
<span class="sd">    If a source is not given, it is automatically the same as the input.</span>
<span class="sd">    Let A be the first branch and B be the second branch.</span>
<span class="sd">    Then the result images are defined as</span>
<span class="sd">        factor * A + (1-factor) * B,</span>
<span class="sd">    where `factor` is an overlay factor.</span>

<span class="sd">    For keypoint augmentation this augmenter will pick the keypoints either</span>
<span class="sd">    from the first or the second branch. The first one is picked if</span>
<span class="sd">    `factor &gt;= 0.5` is true (per image). It is recommended to *not* use</span>
<span class="sd">    augmenters that change keypoint positions with this class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    factor : int or float or iterable of two floats or StochasticParameter, optional(default=0)</span>
<span class="sd">        Weighting of the results of the first branch. Values close to 0 mean</span>
<span class="sd">        that the results from the second branch (see parameter `second`)</span>
<span class="sd">        make up most of the final image.</span>
<span class="sd">            * If float, then that value will be used for all images.</span>
<span class="sd">            * If tuple (a, b), then a random value from range a &lt;= x &lt;= b will</span>
<span class="sd">              be sampled per image.</span>
<span class="sd">            * If StochasticParameter, then that parameter will be used to</span>
<span class="sd">              sample a value per image.</span>

<span class="sd">    first : None or Augmenter or iterable of Augmenter, optional(default=None)</span>
<span class="sd">        Augmenter(s) that make up the first of the two</span>
<span class="sd">        branches.</span>
<span class="sd">            * If None, then the input images will be reused as the output</span>
<span class="sd">              of the first branch.</span>
<span class="sd">            * If Augmenter, then that augmenter will be used as the branch.</span>
<span class="sd">            * If iterable of Augmenter, then that iterable will be converted</span>
<span class="sd">              into a Sequential and used as the augmenter.</span>

<span class="sd">    second : None or Augmenter or iterable of Augmenter, optional(default=None)</span>
<span class="sd">        Augmenter(s) that make up the second of the two</span>
<span class="sd">        branches.</span>
<span class="sd">            * If None, then the input images will be reused as the output</span>
<span class="sd">              of the second branch.</span>
<span class="sd">            * If Augmenter, then that augmenter will be used as the branch.</span>
<span class="sd">            * If iterable of Augmenter, then that iterable will be converted</span>
<span class="sd">              into a Sequential and used as the augmenter.</span>

<span class="sd">    per_channel : bool or float, optional(default=False)</span>
<span class="sd">        Whether to use the same factor for all channels (False)</span>
<span class="sd">        or to sample a new value for each channel (True).</span>
<span class="sd">        If this value is a float p, then for p percent of all images</span>
<span class="sd">        `per_channel` will be treated as True, otherwise as False.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.Alpha(0.5, iaa.Grayscale(1.0))</span>

<span class="sd">    Converts each image to grayscale and overlays it by 50 percent with the</span>
<span class="sd">    original image, thereby removing about 50 percent of all color. This</span>
<span class="sd">    is equivalent to iaa.Grayscale(0.5).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Alpha((0.0, 1.0), iaa.Grayscale(1.0))</span>

<span class="sd">    Converts each image to grayscale and overlays it by a random percentage</span>
<span class="sd">    (sampled per image) with the original image, thereby removing a random</span>
<span class="sd">    percentage of all colors. This is equivalent to iaa.Grayscale((0.0, 1.0)).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Alpha((0.0, 1.0), iaa.Affine(rotate=(-20, 20)), per_channel=0.5)</span>

<span class="sd">    Rotates each image by a random degree from the range [-20, 20]. Then</span>
<span class="sd">    overlays that new image with the original one by a random factor from the</span>
<span class="sd">    range [0.0, 1.0]. In 50 percent of all cases, the overlay happens</span>
<span class="sd">    channel-wise and the factor is sampled independently per channel. As a</span>
<span class="sd">    result, e.g. the red channel may look visible rotated (factor near 1.0),</span>
<span class="sd">    while the green and blue channels may not look rotated (factors near 0.0).</span>
<span class="sd">    NOTE: It is not recommended to use Alpha with augmenters that change the</span>
<span class="sd">    positions of pixels if you *also* want to augment keypoints, as it is</span>
<span class="sd">    unclear which of the two keypoint results (first or second branch) should</span>
<span class="sd">    be used as the final result.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Alpha((0.0, 1.0), first=iaa.Add(10), second=iaa.Multiply(0.8))</span>

<span class="sd">    (A) Adds 10 to each image and (B) multiplies each image by 0.8. Then per</span>
<span class="sd">    image an overlay factor is sampled from the range [0.0, 1.0]. If it is</span>
<span class="sd">    close to 1.0, the results from (A) are mostly used, otherwise the ones</span>
<span class="sd">    from (B). This is equivalent to</span>
<span class="sd">    `iaa.Sequential([iaa.Multiply(0.8), iaa.Alpha((0.0, 1.0), iaa.Add(10))])`.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Alpha(iap.Choice([0.25, 0.75]), iaa.MedianBlur((3, 7)))</span>

<span class="sd">    Applies a random median blur to each image and overlays the result with</span>
<span class="sd">    the original image by either 25 or 75 percent strength.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Alpha</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">factor</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;Expected factor to have range [0, 1.0], got value </span><span class="si">%.2f</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">factor</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">factor</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">factor</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">factor</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="n">factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float or int, tuple/list with 2 entries or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">factor</span><span class="p">),))</span>

        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">second</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Expected &#39;first&#39; and/or &#39;second&#39; to not be None (i.e. at least one Augmenter), but got two None values.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">handle_children_list</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;first&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">handle_children_list</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;second&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">per_channel</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">per_channel</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">per_channel</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">per_channel</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">per_channel</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">per_channel</span> <span class="o">=</span> <span class="n">Binomial</span><span class="p">(</span><span class="n">per_channel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected per_channel to be boolean or number or StochasticParameter&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.01</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">nb_images</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">images_first</span> <span class="o">=</span> <span class="n">images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">images_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                    <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">images_second</span> <span class="o">=</span> <span class="n">images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">images_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                    <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images_first</span> <span class="o">=</span> <span class="n">images</span>
            <span class="n">images_second</span> <span class="o">=</span> <span class="n">images</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">image_first</span> <span class="o">=</span> <span class="n">images_first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">image_second</span> <span class="o">=</span> <span class="n">images_second</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rs_image</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">per_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_channel</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">rs_image</span><span class="p">)</span>
            <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="n">per_channel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">nb_channels</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_channels</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rs_image</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">sample</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">samples</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sample</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="c1"># if the value is nearly 1.0 or 0.0 skip the computation</span>
                    <span class="c1"># and just use only the first/second image</span>
                    <span class="k">if</span> <span class="n">sample</span> <span class="o">&gt;=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
                        <span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_first</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">sample</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
                        <span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_second</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span> <span class="o">*</span> <span class="n">image_first</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sample</span><span class="p">)</span> <span class="o">*</span> <span class="n">image_second</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                <span class="c1"># TODO change this to meta.clip_* and meta.restore_*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">rs_image</span><span class="p">)</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sample</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span>
                <span class="c1"># if the value is nearly 1.0 or 0.0 skip the computation</span>
                <span class="c1"># and just use only the first/second image</span>
                <span class="k">if</span> <span class="n">sample</span> <span class="o">&gt;=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image_first</span>
                <span class="k">elif</span> <span class="n">sample</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">epsilon</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">image_second</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="n">sample</span> <span class="o">*</span> <span class="n">image_first</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sample</span><span class="p">)</span> <span class="o">*</span> <span class="n">image_second</span>
                <span class="c1"># TODO change this to meta.clip_* and meta.restore_*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">)</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">nb_images</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kps_ois_first</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kps_ois_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                    <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">keypoints_on_images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kps_ois_second</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kps_ois_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                    <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">keypoints_on_images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kps_ois_first</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
            <span class="n">kps_ois_second</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">kps_oi_first</span> <span class="o">=</span> <span class="n">kps_ois_first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">kps_oi_second</span> <span class="o">=</span> <span class="n">kps_ois_second</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">rs_image</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># keypoint augmentation also works channel-wise, even though</span>
            <span class="c1"># keypoints do not have channels, in order to keep the random</span>
            <span class="c1"># values properly synchronized with the image augmentation</span>
            <span class="n">per_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_channel</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">rs_image</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">per_channel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">nb_channels</span> <span class="o">=</span> <span class="n">keypoints_on_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_channels</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rs_image</span><span class="p">)</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">rs_image</span><span class="p">)</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">sample</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="c1"># We cant choose &quot;just a bit&quot; of one keypoint augmentation result</span>
            <span class="c1"># without messing up the positions (interpolation doesn&#39;t make much</span>
            <span class="c1"># sense here),</span>
            <span class="c1"># so if the alpha is &gt;= 0.5 (branch A is more visible than</span>
            <span class="c1"># branch B), the result of branch A, otherwise branch B.</span>
            <span class="k">if</span> <span class="n">sample</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kps_oi_first</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kps_oi_second</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_to_deterministic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span> <span class="k">if</span> <span class="n">aug</span><span class="o">.</span><span class="n">first</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">aug</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">to_deterministic</span><span class="p">()</span> <span class="k">if</span> <span class="n">aug</span><span class="o">.</span><span class="n">second</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">deterministic</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">aug</span>

<div class="viewcode-block" id="Alpha.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.overlay.Alpha.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_channel</span><span class="p">]</span></div>

<div class="viewcode-block" id="Alpha.get_children_lists"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.overlay.Alpha.get_children_lists">[docs]</a>    <span class="k">def</span> <span class="nf">get_children_lists</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="AlphaElementwise"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.overlay.AlphaElementwise">[docs]</a><span class="k">class</span> <span class="nc">AlphaElementwise</span><span class="p">(</span><span class="n">Alpha</span><span class="p">):</span> <span class="c1"># pylint: disable=locally-disabled, unused-variable, line-too-long</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter to overlay two image sources with each other using pixelwise</span>
<span class="sd">    alpha values.</span>

<span class="sd">    This is the same as `Alpha`, except that the transparency factor is</span>
<span class="sd">    sampled per pixel instead of once per image (or a few times per image, if</span>
<span class="sd">    per_channel is True).</span>

<span class="sd">    See `Alpha` for more description.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    factor : float or iterable of two floats or StochasticParameter, optional(default=0)</span>
<span class="sd">        Weighting of the results of the first branch. Values close to 0 mean</span>
<span class="sd">        that the results from the second branch (see parameter `second`)</span>
<span class="sd">        make up most of the final image.</span>
<span class="sd">            * If float, then that value will be used for all images.</span>
<span class="sd">            * If tuple (a, b), then a random value from range a &lt;= x &lt;= b will</span>
<span class="sd">              be sampled per image.</span>
<span class="sd">            * If StochasticParameter, then that parameter will be used to</span>
<span class="sd">              sample a value per image.</span>

<span class="sd">    first : None or Augmenter or iterable of Augmenter, optional(default=None)</span>
<span class="sd">        Augmenter(s) that make up the first of the two</span>
<span class="sd">        branches.</span>
<span class="sd">            * If None, then the input images will be reused as the output</span>
<span class="sd">              of the first branch.</span>
<span class="sd">            * If Augmenter, then that augmenter will be used as the branch.</span>
<span class="sd">            * If iterable of Augmenter, then that iterable will be converted</span>
<span class="sd">              into a Sequential and used as the augmenter.</span>

<span class="sd">    second : None or Augmenter or iterable of Augmenter, optional(default=None)</span>
<span class="sd">        Augmenter(s) that make up the second of the two</span>
<span class="sd">        branches.</span>
<span class="sd">            * If None, then the input images will be reused as the output</span>
<span class="sd">              of the second branch.</span>
<span class="sd">            * If Augmenter, then that augmenter will be used as the branch.</span>
<span class="sd">            * If iterable of Augmenter, then that iterable will be converted</span>
<span class="sd">              into a Sequential and used as the augmenter.</span>

<span class="sd">    per_channel : bool or float, optional(default=False)</span>
<span class="sd">        Whether to use the same factor for all channels (False)</span>
<span class="sd">        or to sample a new value for each channel (True).</span>
<span class="sd">        If this value is a float p, then for p percent of all images</span>
<span class="sd">        `per_channel` will be treated as True, otherwise as False.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.AlphaElementwise(0.5, iaa.Grayscale(1.0))</span>

<span class="sd">    Converts each image to grayscale and overlays it by 50 percent with the</span>
<span class="sd">    original image, thereby removing about 50 percent of all color. This</span>
<span class="sd">    is equivalent to iaa.Grayscale(0.5). This is also equivalent to</span>
<span class="sd">    iaa.Alpha(0.5, iaa.Grayscale(1.0)), as the transparency factor is the</span>
<span class="sd">    same for all pixels.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AlphaElementwise((0, 1.0), iaa.Grayscale(1.0))</span>

<span class="sd">    Converts each image to grayscale and overlays it by a random percentage</span>
<span class="sd">    (sampled per pixel) with the original image, thereby removing a random</span>
<span class="sd">    percentage of all colors per pixel.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AlphaElementwise((0.0, 1.0), iaa.Affine(rotate=(-20, 20)), per_channel=0.5)</span>

<span class="sd">    Rotates each image by a random degree from the range [-20, 20]. Then</span>
<span class="sd">    overlays that new image with the original one by a random factor from the</span>
<span class="sd">    range [0.0, 1.0], sampled per pixel. In 50 percent of all cases, the</span>
<span class="sd">    overlay happens channel-wise and the factor is sampled independently per</span>
<span class="sd">    channel. As a result, e.g. the red channel may look visible rotated (factor</span>
<span class="sd">    near 1.0), while the green and blue channels may not look rotated (factors</span>
<span class="sd">    near 0.0). NOTE: It is not recommended to use Alpha with augmenters that</span>
<span class="sd">    change the positions of pixels if you *also* want to augment keypoints, as</span>
<span class="sd">    it is unclear which of the two keypoint results (first or second branch)</span>
<span class="sd">    should be used as the final result.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AlphaElementwise((0.0, 1.0), first=iaa.Add(10), second=iaa.Multiply(0.8))</span>

<span class="sd">    (A) Adds 10 to each image and (B) multiplies each image by 0.8. Then per</span>
<span class="sd">    pixel an overlay factor is sampled from the range [0.0, 1.0]. If it is</span>
<span class="sd">    close to 1.0, the results from (A) are mostly used, otherwise the ones</span>
<span class="sd">    from (B).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AlphaElementwise(iap.Choice([0.25, 0.75]), iaa.MedianBlur((3, 7)))</span>

<span class="sd">    Applies a random median blur to each image and overlays the result with</span>
<span class="sd">    the original image by either 25 or 75 percent strength (sampled per pixel).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AlphaElementwise</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">factor</span><span class="o">=</span><span class="n">factor</span><span class="p">,</span>
            <span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="p">,</span>
            <span class="n">second</span><span class="o">=</span><span class="n">second</span><span class="p">,</span>
            <span class="n">per_channel</span><span class="o">=</span><span class="n">per_channel</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span>
            <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">nb_images</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">images_first</span> <span class="o">=</span> <span class="n">images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">images_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                    <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">images_second</span> <span class="o">=</span> <span class="n">images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">images_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">augment_images</span><span class="p">(</span>
                    <span class="n">images</span><span class="o">=</span><span class="n">images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">images_first</span> <span class="o">=</span> <span class="n">images</span>
            <span class="n">images_second</span> <span class="o">=</span> <span class="n">images</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">nb_channels</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">image_first</span> <span class="o">=</span> <span class="n">images_first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">image_second</span> <span class="o">=</span> <span class="n">images_second</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">per_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_channel</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">input_dtype</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="n">per_channel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_channels</span><span class="p">):</span>
                    <span class="n">samples_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">c</span><span class="p">))</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">samples_c</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="c1"># validate only first value</span>
                    <span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_c</span> <span class="o">*</span> <span class="n">image_first</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">samples_c</span><span class="p">)</span> <span class="o">*</span> <span class="n">image_second</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
                <span class="c1"># TODO change this to meta.clip_* and meta.restore_*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">samples</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb_channels</span><span class="p">))</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">samples</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span>

                <span class="n">image</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">*</span> <span class="n">image_first</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">samples</span><span class="p">)</span> <span class="o">*</span> <span class="n">image_second</span>
                <span class="c1"># TODO change this to meta.clip_* and meta.restore_*</span>
                <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">image</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">input_dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">)</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">nb_images</span><span class="p">,))</span>

        <span class="k">if</span> <span class="n">hooks</span><span class="o">.</span><span class="n">is_propagating</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">augmenter</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="n">parents</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kps_ois_first</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kps_ois_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                    <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">keypoints_on_images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kps_ois_second</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kps_ois_second</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second</span><span class="o">.</span><span class="n">augment_keypoints</span><span class="p">(</span>
                    <span class="n">keypoints_on_images</span><span class="o">=</span><span class="n">keypoints_on_images</span><span class="p">,</span>
                    <span class="n">parents</span><span class="o">=</span><span class="n">parents</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="p">],</span>
                    <span class="n">hooks</span><span class="o">=</span><span class="n">hooks</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kps_ois_first</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
            <span class="n">kps_ois_second</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>

        <span class="c1"># FIXME this is essentially the same behaviour as Alpha, requires inclusion of (x, y)</span>
        <span class="c1"># coordinates to estimate new keypoint coordinates</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">kps_oi_first</span> <span class="o">=</span> <span class="n">kps_ois_first</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">kps_oi_second</span> <span class="o">=</span> <span class="n">kps_ois_second</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#rs_image = ia.new_random_state(seeds[i])</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">kps_oi_first</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span>
                <span class="s2">&quot;Keypoint augmentation in AlphaElementwise requires &quot;</span> \
                <span class="s2">&quot;KeypointsOnImage.shape to have channel information (i.e. &quot;</span> \
                <span class="s2">&quot;tuple with 3 entries), which you did not provide (input &quot;</span> \
                <span class="s2">&quot;shape: </span><span class="si">%s</span><span class="s2">). The channels must match the corresponding &quot;</span> \
                <span class="s2">&quot;image channels.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">kps_oi_first</span><span class="o">.</span><span class="n">shape</span><span class="p">,)</span>
            <span class="p">)</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">nb_channels</span> <span class="o">=</span> <span class="n">kps_oi_first</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

            <span class="c1"># keypoint augmentation also works channel-wise, even though</span>
            <span class="c1"># keypoints do not have channels, in order to keep the random</span>
            <span class="c1"># values properly synchronized with the image augmentation</span>
            <span class="n">per_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">per_channel</span><span class="o">.</span><span class="n">draw_sample</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">per_channel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1">#samples = self.factor.draw_samples((h, w, nb_channels,), random_state=rs_image)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">nb_channels</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_channels</span><span class="p">):</span>
                    <span class="n">samples_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">c</span><span class="p">))</span>
                    <span class="n">samples</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples_c</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mf">0.0</span> <span class="o">&lt;=</span> <span class="n">samples</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>

            <span class="c1"># We cant choose &quot;just a bit&quot; of one keypoint augmentation result</span>
            <span class="c1"># without messing up the positions (interpolation doesn&#39;t make much</span>
            <span class="c1"># sense here),</span>
            <span class="c1"># so if the alpha is &gt;= 0.5 (branch A is more visible than</span>
            <span class="c1"># branch B), the result of branch A, otherwise branch B.</span>
            <span class="k">if</span> <span class="n">sample</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kps_oi_first</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kps_oi_second</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="SimplexNoiseAlpha"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.overlay.SimplexNoiseAlpha">[docs]</a><span class="k">def</span> <span class="nf">SimplexNoiseAlpha</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">size_px_max</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">upscale_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">iterations</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">aggregation_method</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">,</span>
                      <span class="n">sigmoid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sigmoid_thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter to overlay two image sources with each other using alpha values</span>
<span class="sd">    that follow noisy patterns.</span>

<span class="sd">    The alpha masks are sampled using a simplex noise method, roughly creating</span>
<span class="sd">    connected blobs of 1s surrounded by 0s. If nearest neighbour upsampling</span>
<span class="sd">    is used, these blobs can be rectangular with sharp edges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    first : None or Augmenter or iterable of Augmenter, optional(default=None)</span>
<span class="sd">        Augmenter(s) that make up the first of the two</span>
<span class="sd">        branches.</span>
<span class="sd">            * If None, then the input images will be reused as the output</span>
<span class="sd">              of the first branch.</span>
<span class="sd">            * If Augmenter, then that augmenter will be used as the branch.</span>
<span class="sd">            * If iterable of Augmenter, then that iterable will be converted</span>
<span class="sd">              into a Sequential and used as the augmenter.</span>

<span class="sd">    second : None or Augmenter or iterable of Augmenter, optional(default=None)</span>
<span class="sd">        Augmenter(s) that make up the second of the two</span>
<span class="sd">        branches.</span>
<span class="sd">            * If None, then the input images will be reused as the output</span>
<span class="sd">              of the second branch.</span>
<span class="sd">            * If Augmenter, then that augmenter will be used as the branch.</span>
<span class="sd">            * If iterable of Augmenter, then that iterable will be converted</span>
<span class="sd">              into a Sequential and used as the augmenter.</span>

<span class="sd">    per_channel : bool or float, optional(default=False)</span>
<span class="sd">        Whether to use the same factor for all channels (False)</span>
<span class="sd">        or to sample a new value for each channel (True).</span>
<span class="sd">        If this value is a float p, then for p percent of all images</span>
<span class="sd">        `per_channel` will be treated as True, otherwise as False.</span>

<span class="sd">    size_px_max : int or tuple of ints or list of ints or StochasticParameter, optional(default=(2, 16))</span>
<span class="sd">        The simplex noise is always generated in a low resolution environment.</span>
<span class="sd">        This parameter defines the maximum size of that environment (in</span>
<span class="sd">        pixels). The environment is initialized at the same size as the input</span>
<span class="sd">        image and then downscaled, so that no side exceeds `size_px_max`</span>
<span class="sd">        (aspect ratio is kept).</span>
<span class="sd">            * If int, then that number will be used as the size for all</span>
<span class="sd">              iterations.</span>
<span class="sd">            * If tuple of two ints (a, b), then a value will be sampled</span>
<span class="sd">              per iteration from the discrete range [a..b].</span>
<span class="sd">            * If a list of ints, then a value will be picked per iteration at</span>
<span class="sd">              random from that list.</span>
<span class="sd">            * If a StochasticParameter, then a value will be sampled from</span>
<span class="sd">              that parameter per iteration.</span>

<span class="sd">    upscale_method : None or ia.ALL or string or list of string or StochasticParameter, optional(default=None)</span>
<span class="sd">        After generating the noise maps in low resolution environments, they</span>
<span class="sd">        have to be upscaled to the input image size. This parameter controls</span>
<span class="sd">        the upscaling method.</span>
<span class="sd">            * If None, then either &#39;nearest&#39; or &#39;linear&#39; or &#39;cubic&#39; is picked.</span>
<span class="sd">              Most weight is put on linear, followed by cubic.</span>
<span class="sd">            * If ia.ALL, then either &#39;nearest&#39; or &#39;linear&#39; or &#39;area&#39; or &#39;cubic&#39;</span>
<span class="sd">              is picked per iteration (all same probability).</span>
<span class="sd">            * If string, then that value will be used as the method (must be</span>
<span class="sd">              &#39;nearest&#39; or &#39;linear&#39; or &#39;area&#39; or &#39;cubic&#39;).</span>
<span class="sd">            * If list of string, then a random value will be picked from that</span>
<span class="sd">              list per iteration.</span>
<span class="sd">            * If StochasticParameter, then a random value will be sampled</span>
<span class="sd">              from that parameter per iteration.</span>

<span class="sd">    iterations : int or tuple of ints or list of ints or StochasticParameter, optional(default=(1, 3))</span>
<span class="sd">        How often to repeat the simplex noise generation process per</span>
<span class="sd">        image.</span>
<span class="sd">            * If int, then that number will be used as the iterations for all</span>
<span class="sd">              images.</span>
<span class="sd">            * If tuple of two ints (a, b), then a value will be sampled</span>
<span class="sd">              per image from the discrete range [a..b].</span>
<span class="sd">            * If a list of ints, then a value will be picked per image at</span>
<span class="sd">              random from that list.</span>
<span class="sd">            * If a StochasticParameter, then a value will be sampled from</span>
<span class="sd">              that parameter per image.</span>

<span class="sd">    aggregation_method : ia.ALL or string or list of string or StochasticParameter, optional(default=&quot;max&quot;)</span>
<span class="sd">        The noise maps (from each iteration) are combined to one noise map</span>
<span class="sd">        using an aggregation process. This parameter defines the method used</span>
<span class="sd">        for that process. Valid methods are &#39;min&#39;, &#39;max&#39; or &#39;avg&#39;,</span>
<span class="sd">        where &#39;min&#39; combines the noise maps by taking the (elementwise) minimum</span>
<span class="sd">        over all iteration&#39;s results, &#39;max&#39; the (elementwise) maximum and</span>
<span class="sd">        &#39;avg&#39; the (elemtwise) average.</span>
<span class="sd">            * If ia.ALL, then a random value will be picked per image from the</span>
<span class="sd">              valid ones.</span>
<span class="sd">            * If a string, then that value will always be used as the method.</span>
<span class="sd">            * If a list of string, then a random value will be picked from</span>
<span class="sd">              that list per image.</span>
<span class="sd">            * If a StochasticParameter, then a random value will be sampled</span>
<span class="sd">              from that paramter per image.</span>

<span class="sd">    sigmoid : bool or number, optional(default=True)</span>
<span class="sd">        Whether to apply a sigmoid function to the final noise maps, resulting</span>
<span class="sd">        in maps that have more extreme values (close to 0.0 or 1.0).</span>
<span class="sd">            * If bool, then a sigmoid will always (True) or never (False) be</span>
<span class="sd">              applied.</span>
<span class="sd">            * If a number p with 0&lt;=p&lt;=1, then a sigmoid will be applied to</span>
<span class="sd">              p percent of all final noise maps.</span>

<span class="sd">    sigmoid_thresh : None or number or tuple of number or StochasticParameter, optional(default=None)</span>
<span class="sd">        Threshold of the sigmoid, when applied. Thresholds above zero</span>
<span class="sd">        (e.g. 5.0) will move the saddle point towards the right, leading to</span>
<span class="sd">        more values close to 0.0.</span>
<span class="sd">            * If None, then Normal(0, 5.0) will be used.</span>
<span class="sd">            * If number, then that threshold will be used for all images.</span>
<span class="sd">            * If tuple of two numbers (a, b), then a random value will</span>
<span class="sd">              be sampled per image from the range [a, b].</span>
<span class="sd">            * If StochasticParameter, then a random value will be sampled from</span>
<span class="sd">              that parameter per image.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0))</span>

<span class="sd">    Detects per image all edges, marks them in a black and white image and</span>
<span class="sd">    then overlays the result with the original image using simplex noise masks.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0), upscale_method=&quot;linear&quot;)</span>

<span class="sd">    Same as the first example, but uses only (smooth) linear upscaling to</span>
<span class="sd">    scale the simplex noise masks to the final image sizes, i.e. no nearest</span>
<span class="sd">    neighbour upsampling is used, which would result in rectangles with hard</span>
<span class="sd">    edges.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.SimplexNoiseAlpha(iaa.EdgeDetect(1.0), sigmoid_thresh=iap.Normal(10.0, 5.0))</span>

<span class="sd">    Same as the first example, but uses a threshold for the sigmoid function</span>
<span class="sd">    that is further to the right. This is more conservative, i.e. the generated</span>
<span class="sd">    noise masks will be mostly black (values around 0.0), which means that</span>
<span class="sd">    most of the original images (parameter/branch `second`) will be kept,</span>
<span class="sd">    rather than using the results of the augmentation (parameter/branch</span>
<span class="sd">    `first`).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">upscale_method_default</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">Choice</span><span class="p">([</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">])</span>
    <span class="n">sigmoid_thresh_default</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>

    <span class="n">noise</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">SimplexNoise</span><span class="p">(</span>
        <span class="n">size_px_max</span><span class="o">=</span><span class="n">size_px_max</span><span class="p">,</span>
        <span class="n">upscale_method</span><span class="o">=</span><span class="n">upscale_method</span> <span class="k">if</span> <span class="n">upscale_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">upscale_method_default</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">iterations</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">IterativeNoiseAggregator</span><span class="p">(</span>
            <span class="n">noise</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
            <span class="n">aggregation_method</span><span class="o">=</span><span class="n">aggregation_method</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">sigmoid</span> <span class="o">!=</span> <span class="kc">False</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">sigmoid</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sigmoid</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">):</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">Sigmoid</span><span class="o">.</span><span class="n">create_for_noise</span><span class="p">(</span>
            <span class="n">noise</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">sigmoid_thresh</span> <span class="k">if</span> <span class="n">sigmoid_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sigmoid_thresh_default</span><span class="p">,</span>
            <span class="n">activated</span><span class="o">=</span><span class="n">sigmoid</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">AlphaElementwise</span><span class="p">(</span>
        <span class="n">factor</span><span class="o">=</span><span class="n">noise</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="n">second</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="n">per_channel</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
    <span class="p">)</span></div>

<div class="viewcode-block" id="FrequencyNoiseAlpha"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.overlay.FrequencyNoiseAlpha">[docs]</a><span class="k">def</span> <span class="nf">FrequencyNoiseAlpha</span><span class="p">(</span><span class="n">exponent</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                        <span class="n">first</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">size_px_max</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">upscale_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">iterations</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">aggregation_method</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;avg&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">],</span> <span class="c1"># pylint: disable=locally-disabled, dangerous-default-value, line-too-long</span>
                        <span class="n">sigmoid</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">sigmoid_thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter to overlay two image sources with each other using alpha values</span>
<span class="sd">    that follow noisy patterns.</span>

<span class="sd">    The alpha masks are sampled using frequency noise of varying scales,</span>
<span class="sd">    which can sometimes create large connected blobs of 1s surrounded by 0s</span>
<span class="sd">    and other times results in smaller patterns. If nearest neighbour</span>
<span class="sd">    upsampling is used, these blobs can be rectangular with sharp edges.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    exponent : number or tuple of numbers of list of numbers or StochasticParameter, optional(default=(-4, 4))</span>
<span class="sd">        Exponent to use when scaling in the frequency domain.</span>
<span class="sd">        Sane values are in the range -4 (large blobs) to 4 (small patterns).</span>
<span class="sd">        To generate cloud-like structures, use roughly -2.</span>
<span class="sd">            * If number, then that number will be used as the exponent for all</span>
<span class="sd">              iterations.</span>
<span class="sd">            * If tuple of two numbers (a, b), then a value will be sampled</span>
<span class="sd">              per iteration from the range [a, b].</span>
<span class="sd">            * If a list of numbers, then a value will be picked per iteration</span>
<span class="sd">              at random from that list.</span>
<span class="sd">            * If a StochasticParameter, then a value will be sampled from</span>
<span class="sd">              that parameter per iteration.</span>

<span class="sd">    first : None or Augmenter or iterable of Augmenter, optional(default=None)</span>
<span class="sd">        Augmenter(s) that make up the first of the two</span>
<span class="sd">        branches.</span>
<span class="sd">            * If None, then the input images will be reused as the output</span>
<span class="sd">              of the first branch.</span>
<span class="sd">            * If Augmenter, then that augmenter will be used as the branch.</span>
<span class="sd">            * If iterable of Augmenter, then that iterable will be converted</span>
<span class="sd">              into a Sequential and used as the augmenter.</span>

<span class="sd">    second : None or Augmenter or iterable of Augmenter, optional(default=None)</span>
<span class="sd">        Augmenter(s) that make up the second of the two</span>
<span class="sd">        branches.</span>
<span class="sd">            * If None, then the input images will be reused as the output</span>
<span class="sd">              of the second branch.</span>
<span class="sd">            * If Augmenter, then that augmenter will be used as the branch.</span>
<span class="sd">            * If iterable of Augmenter, then that iterable will be converted</span>
<span class="sd">              into a Sequential and used as the augmenter.</span>

<span class="sd">    per_channel : bool or float, optional(default=False)</span>
<span class="sd">        Whether to use the same factor for all channels (False)</span>
<span class="sd">        or to sample a new value for each channel (True).</span>
<span class="sd">        If this value is a float p, then for p percent of all images</span>
<span class="sd">        `per_channel` will be treated as True, otherwise as False.</span>

<span class="sd">    size_px_max : int or tuple of ints or list of ints or StochasticParameter, optional(default=(4, 16))</span>
<span class="sd">        The noise is generated in a low resolution environment.</span>
<span class="sd">        This parameter defines the maximum size of that environment (in</span>
<span class="sd">        pixels). The environment is initialized at the same size as the input</span>
<span class="sd">        image and then downscaled, so that no side exceeds `size_px_max`</span>
<span class="sd">        (aspect ratio is kept).</span>
<span class="sd">            * If int, then that number will be used as the size for all</span>
<span class="sd">              iterations.</span>
<span class="sd">            * If tuple of two ints (a, b), then a value will be sampled</span>
<span class="sd">              per iteration from the discrete range [a..b].</span>
<span class="sd">            * If a list of ints, then a value will be picked per iteration at</span>
<span class="sd">              random from that list.</span>
<span class="sd">            * If a StochasticParameter, then a value will be sampled from</span>
<span class="sd">              that parameter per iteration.</span>

<span class="sd">    upscale_method : None or ia.ALL or string or list of string or StochasticParameter, optional(default=None)</span>
<span class="sd">        After generating the noise maps in low resolution environments, they</span>
<span class="sd">        have to be upscaled to the input image size. This parameter controls</span>
<span class="sd">        the upscaling method.</span>
<span class="sd">            * If None, then either &#39;nearest&#39; or &#39;linear&#39; or &#39;cubic&#39; is picked.</span>
<span class="sd">              Most weight is put on linear, followed by cubic.</span>
<span class="sd">            * If ia.ALL, then either &#39;nearest&#39; or &#39;linear&#39; or &#39;area&#39; or &#39;cubic&#39;</span>
<span class="sd">              is picked per iteration (all same probability).</span>
<span class="sd">            * If string, then that value will be used as the method (must be</span>
<span class="sd">              &#39;nearest&#39; or &#39;linear&#39; or &#39;area&#39; or &#39;cubic&#39;).</span>
<span class="sd">            * If list of string, then a random value will be picked from that</span>
<span class="sd">              list per iteration.</span>
<span class="sd">            * If StochasticParameter, then a random value will be sampled</span>
<span class="sd">              from that parameter per iteration.</span>

<span class="sd">    iterations : int or tuple of ints or list of ints or StochasticParameter, optional(default=(1, 3))</span>
<span class="sd">        How often to repeat the simplex noise generation process per</span>
<span class="sd">        image.</span>
<span class="sd">            * If int, then that number will be used as the iterations for all</span>
<span class="sd">              images.</span>
<span class="sd">            * If tuple of two ints (a, b), then a value will be sampled</span>
<span class="sd">              per image from the discrete range [a..b].</span>
<span class="sd">            * If a list of ints, then a value will be picked per image at</span>
<span class="sd">              random from that list.</span>
<span class="sd">            * If a StochasticParameter, then a value will be sampled from</span>
<span class="sd">              that parameter per image.</span>

<span class="sd">    aggregation_method : ia.ALL or string or list of string or StochasticParameter, optional(default=[&quot;avg&quot;, &quot;max&quot;])</span>
<span class="sd">        The noise maps (from each iteration) are combined to one noise map</span>
<span class="sd">        using an aggregation process. This parameter defines the method used</span>
<span class="sd">        for that process. Valid methods are &#39;min&#39;, &#39;max&#39; or &#39;avg&#39;,</span>
<span class="sd">        where &#39;min&#39; combines the noise maps by taking the (elementwise) minimum</span>
<span class="sd">        over all iteration&#39;s results, &#39;max&#39; the (elementwise) maximum and</span>
<span class="sd">        &#39;avg&#39; the (elemtwise) average.</span>
<span class="sd">            * If ia.ALL, then a random value will be picked per image from the</span>
<span class="sd">              valid ones.</span>
<span class="sd">            * If a string, then that value will always be used as the method.</span>
<span class="sd">            * If a list of string, then a random value will be picked from</span>
<span class="sd">              that list per image.</span>
<span class="sd">            * If a StochasticParameter, then a random value will be sampled</span>
<span class="sd">              from that paramter per image.</span>

<span class="sd">    sigmoid : bool or number, optional(default=0.5)</span>
<span class="sd">        Whether to apply a sigmoid function to the final noise maps, resulting</span>
<span class="sd">        in maps that have more extreme values (close to 0.0 or 1.0).</span>
<span class="sd">            * If bool, then a sigmoid will always (True) or never (False) be</span>
<span class="sd">              applied.</span>
<span class="sd">            * If a number p with 0&lt;=p&lt;=1, then a sigmoid will be applied to</span>
<span class="sd">              p percent of all final noise maps.</span>

<span class="sd">    sigmoid_thresh : None or number or tuple of number or StochasticParameter, optional(default=None)</span>
<span class="sd">        Threshold of the sigmoid, when applied. Thresholds above zero</span>
<span class="sd">        (e.g. 5.0) will move the saddle point towards the right, leading to</span>
<span class="sd">        more values close to 0.0.</span>
<span class="sd">            * If None, then Normal(0, 5.0) will be used.</span>
<span class="sd">            * If number, then that threshold will be used for all images.</span>
<span class="sd">            * If tuple of two numbers (a, b), then a random value will</span>
<span class="sd">              be sampled per image from the range [a, b].</span>
<span class="sd">            * If StochasticParameter, then a random value will be sampled from</span>
<span class="sd">              that parameter per image.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0))</span>

<span class="sd">    Detects per image all edges, marks them in a black and white image and</span>
<span class="sd">    then overlays the result with the original image using frequency noise</span>
<span class="sd">    masks.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), upscale_method=&quot;linear&quot;)</span>

<span class="sd">    Same as the first example, but uses only (smooth) linear upscaling to</span>
<span class="sd">    scale the frequency noise masks to the final image sizes, i.e. no nearest</span>
<span class="sd">    neighbour upsampling is used, which would result in rectangles with hard</span>
<span class="sd">    edges.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), upscale_method=&quot;linear&quot;, exponent=-2, sigmoid=False)</span>

<span class="sd">    Same as the previous example, but also limits the exponent to -2 and</span>
<span class="sd">    deactivates the sigmoid, resulting in cloud-like patterns without sharp</span>
<span class="sd">    edges.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.FrequencyNoiseAlpha(first=iaa.EdgeDetect(1.0), sigmoid_thresh=iap.Normal(10.0, 5.0))</span>

<span class="sd">    Same as the first example, but uses a threshold for the sigmoid function</span>
<span class="sd">    that is further to the right. This is more conservative, i.e. the generated</span>
<span class="sd">    noise masks will be mostly black (values around 0.0), which means that</span>
<span class="sd">    most of the original images (parameter/branch `second`) will be kept,</span>
<span class="sd">    rather than using the results of the augmentation (parameter/branch</span>
<span class="sd">    `first`).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">upscale_method_default</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">Choice</span><span class="p">([</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">])</span>
    <span class="n">sigmoid_thresh_default</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">Normal</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">)</span>

    <span class="n">noise</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">FrequencyNoise</span><span class="p">(</span>
        <span class="n">exponent</span><span class="o">=</span><span class="n">exponent</span><span class="p">,</span>
        <span class="n">size_px_max</span><span class="o">=</span><span class="n">size_px_max</span><span class="p">,</span>
        <span class="n">upscale_method</span><span class="o">=</span><span class="n">upscale_method</span> <span class="k">if</span> <span class="n">upscale_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">upscale_method_default</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">iterations</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">IterativeNoiseAggregator</span><span class="p">(</span>
            <span class="n">noise</span><span class="p">,</span>
            <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
            <span class="n">aggregation_method</span><span class="o">=</span><span class="n">aggregation_method</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">sigmoid</span> <span class="o">!=</span> <span class="kc">False</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">sigmoid</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sigmoid</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">):</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">iap</span><span class="o">.</span><span class="n">Sigmoid</span><span class="o">.</span><span class="n">create_for_noise</span><span class="p">(</span>
            <span class="n">noise</span><span class="p">,</span>
            <span class="n">threshold</span><span class="o">=</span><span class="n">sigmoid_thresh</span> <span class="k">if</span> <span class="n">sigmoid_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sigmoid_thresh_default</span><span class="p">,</span>
            <span class="n">activated</span><span class="o">=</span><span class="n">sigmoid</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">AlphaElementwise</span><span class="p">(</span>
        <span class="n">factor</span><span class="o">=</span><span class="n">noise</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="n">second</span><span class="p">,</span> <span class="n">per_channel</span><span class="o">=</span><span class="n">per_channel</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
    <span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Alexander Jung.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.2.6',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>