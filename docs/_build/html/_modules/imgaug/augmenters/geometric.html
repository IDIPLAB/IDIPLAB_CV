

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>imgaug.augmenters.geometric &mdash; imgaug 0.2.6 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> imgaug
          

          
          </a>

          
            
            
              <div class="version">
                0.2.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../source/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/examples_basics.html">Examples: Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/examples_keypoints.html">Examples: Keypoints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/examples_bounding_boxes.html">Examples: Bounding Boxes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/parameters.html">Stochastic Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/alpha.html">Blending/Overlaying images</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/augmenters.html">Overview of Augmenters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../source/modules.html">imgaug</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">imgaug</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>imgaug.augmenters.geometric</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for imgaug.augmenters.geometric</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Augmenters that apply affine transformations or other similar augmentations.</span>

<span class="sd">Do not import directly from this file, as the categorization is not final.</span>
<span class="sd">Use instead</span>
<span class="sd">    `from imgaug import augmenters as iaa`</span>
<span class="sd">and then e.g. ::</span>

<span class="sd">    seq = iaa.Sequential([</span>
<span class="sd">        iaa.Affine(...),</span>
<span class="sd">        iaa.PerspectiveTransform(...)</span>
<span class="sd">    ])</span>

<span class="sd">List of augmenters:</span>
<span class="sd">    * Affine</span>
<span class="sd">    * PiecewiseAffine</span>
<span class="sd">    * PerspectiveTransform</span>
<span class="sd">    * ElasticTransformation</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">imgaug</span> <span class="k">as</span> <span class="n">ia</span>
<span class="c1"># TODO replace these imports with iap.XYZ</span>
<span class="kn">from</span> <span class="nn">..parameters</span> <span class="k">import</span> <span class="n">StochasticParameter</span><span class="p">,</span> <span class="n">Deterministic</span><span class="p">,</span> <span class="n">Choice</span><span class="p">,</span> <span class="n">DiscreteUniform</span><span class="p">,</span> <span class="n">Normal</span><span class="p">,</span> <span class="n">Uniform</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="k">import</span> <span class="n">transform</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">six.moves</span> <span class="k">as</span> <span class="nn">sm</span>

<span class="kn">from</span> <span class="nn">.meta</span> <span class="k">import</span> <span class="n">Augmenter</span>

<div class="viewcode-block" id="Affine"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.Affine">[docs]</a><span class="k">class</span> <span class="nc">Affine</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter to apply affine transformations to images.</span>

<span class="sd">    This is mostly a wrapper around skimage&#39;s AffineTransform class and</span>
<span class="sd">    warp function.</span>

<span class="sd">    Affine transformations</span>
<span class="sd">    involve:</span>
<span class="sd">        - Translation (&quot;move&quot; image on the x-/y-axis)</span>
<span class="sd">        - Rotation</span>
<span class="sd">        - Scaling (&quot;zoom&quot; in/out)</span>
<span class="sd">        - Shear (move one side of the image, turning a square into a trapezoid)</span>

<span class="sd">    All such transformations can create &quot;new&quot; pixels in the image without a</span>
<span class="sd">    defined content, e.g. if the image is translated to the left, pixels</span>
<span class="sd">    are created on the right.</span>
<span class="sd">    A method has to be defined to deal with these pixel values. The</span>
<span class="sd">    parameters `cval` and `mode` of this class deal with this.</span>

<span class="sd">    Some transformations involve interpolations between several pixels</span>
<span class="sd">    of the input image to generate output pixel values. The parameter `order`</span>
<span class="sd">    deals with the method of interpolation used for this.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scale : float or tuple of two floats or StochasticParameter or dict {&quot;x&quot;: float/tuple/StochasticParameter, &quot;y&quot;: float/tuple/StochasticParameter}, optional(default=1.0)</span>
<span class="sd">        Scaling factor to use, where 1.0 represents no change and 0.5 is</span>
<span class="sd">        zoomed out to 50 percent of the original size.</span>
<span class="sd">            * If a single float, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled from the range</span>
<span class="sd">              a &lt;= x &lt;= b per image. That value will be used identically for</span>
<span class="sd">              both x- and y-axis.</span>
<span class="sd">            * If a StochasticParameter, then from that parameter a value will</span>
<span class="sd">              be sampled per image (again, used for both x- and y-axis).</span>
<span class="sd">            * If a dictionary, then it is expected to have the keys &quot;x&quot; and/or &quot;y&quot;.</span>
<span class="sd">              Each of these keys can have the same values as described before</span>
<span class="sd">              for this whole parameter (`scale`). Using a dictionary allows to</span>
<span class="sd">              set different values for the axis. If they are set to the same</span>
<span class="sd">              ranges, different values may still be sampled per axis.</span>

<span class="sd">    translate_percent : float or tuple of two floats or StochasticParameter or dict {&quot;x&quot;: float/tuple/StochasticParameter, &quot;y&quot;: float/tuple/StochasticParameter}, optional(default=1.0)</span>
<span class="sd">        Translation in percent relative to the image</span>
<span class="sd">        height/width (x-translation, y-translation) to use,</span>
<span class="sd">        where 0 represents no change and 0.5 is half of the image</span>
<span class="sd">        height/width.</span>
<span class="sd">            * If a single float, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled from the range</span>
<span class="sd">              a &lt;= x &lt;= b per image. That percent value will be used identically</span>
<span class="sd">              for both x- and y-axis.</span>
<span class="sd">            * If a StochasticParameter, then from that parameter a value will</span>
<span class="sd">              be sampled per image (again, used for both x- and y-axis).</span>
<span class="sd">            * If a dictionary, then it is expected to have the keys &quot;x&quot; and/or &quot;y&quot;.</span>
<span class="sd">              Each of these keys can have the same values as described before</span>
<span class="sd">              for this whole parameter (`translate_percent`).</span>
<span class="sd">              Using a dictionary allows to set different values for the axis.</span>
<span class="sd">              If they are set to the same ranges, different values may still</span>
<span class="sd">              be sampled per axis.</span>

<span class="sd">    translate_px : int or tuple of two ints or StochasticParameter or dict {&quot;x&quot;: int/tuple/StochasticParameter, &quot;y&quot;: int/tuple/StochasticParameter}, optional(default=1.0)</span>
<span class="sd">        Translation in</span>
<span class="sd">        pixels.</span>
<span class="sd">            * If a single int, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled from the discrete</span>
<span class="sd">              range [a .. b] per image. That number will be used identically</span>
<span class="sd">              for both x- and y-axis.</span>
<span class="sd">            * If a StochasticParameter, then from that parameter a value will</span>
<span class="sd">              be sampled per image (again, used for both x- and y-axis).</span>
<span class="sd">            * If a dictionary, then it is expected to have the keys &quot;x&quot; and/or &quot;y&quot;.</span>
<span class="sd">              Each of these keys can have the same values as described before</span>
<span class="sd">              for this whole parameter (`translate_px`).</span>
<span class="sd">              Using a dictionary allows to set different values for the axis.</span>
<span class="sd">              If they are set to the same ranges, different values may still</span>
<span class="sd">              be sampled per axis.</span>

<span class="sd">    rotate : float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)</span>
<span class="sd">        Rotation in degrees (NOT radians), i.e. expected value range is</span>
<span class="sd">        0 to 360 for positive rotations (may also be negative).</span>
<span class="sd">            * If a float/int, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled per image from the</span>
<span class="sd">              range a &lt;= x &lt;= b and be used as the rotation value.</span>
<span class="sd">            * If a StochasticParameter, then this parameter will be used to</span>
<span class="sd">              sample the rotation value per image.</span>

<span class="sd">    shear : float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)</span>
<span class="sd">        Shear in degrees (NOT radians), i.e. expected value range is</span>
<span class="sd">        0 to 360 for positive shear (may also be negative).</span>
<span class="sd">            * If a float/int, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled per image from the</span>
<span class="sd">              range a &lt;= x &lt;= b and be used as the rotation value.</span>
<span class="sd">            * If a StochasticParameter, then this parameter will be used to</span>
<span class="sd">              sample the shear value per image.</span>

<span class="sd">    order : int or iterable of int or ia.ALL or StochasticParameter, optional(default=1)</span>
<span class="sd">        Interpolation order to use. Same meaning as in</span>
<span class="sd">        skimage:</span>
<span class="sd">            * 0: Nearest-neighbor</span>
<span class="sd">            * 1: Bi-linear (default)</span>
<span class="sd">            * 2: Bi-quadratic (not recommended by skimage)</span>
<span class="sd">            * 3: Bi-cubic</span>
<span class="sd">            * 4: Bi-quartic</span>
<span class="sd">            * 5: Bi-quintic</span>
<span class="sd">        Method 0 and 1 are fast, 3 is a bit slower, 4 and 5 are very</span>
<span class="sd">        slow.</span>
<span class="sd">        If the backend is `cv2`, the mapping to opencv&#39;s interpolation modes</span>
<span class="sd">        is as follows:</span>
<span class="sd">            * 0 -&gt; cv2.INTER_NEAREST</span>
<span class="sd">            * 1 -&gt; cv2.INTER_LINEAR</span>
<span class="sd">            * 2 -&gt; cv2.INTER_CUBIC</span>
<span class="sd">            * 3 -&gt; cv2.INTER_CUBIC</span>
<span class="sd">            * 4 -&gt; cv2.INTER_CUBIC</span>
<span class="sd">        As datatypes this parameter</span>
<span class="sd">        accepts:</span>
<span class="sd">            * If a single int, then that order will be used for all images.</span>
<span class="sd">            * If an iterable, then for each image a random value will be sampled</span>
<span class="sd">              from that iterable (i.e. list of allowed order values).</span>
<span class="sd">            * If ia.ALL, then equivalant to list [0, 1, 3, 4, 5].</span>
<span class="sd">            * If StochasticParameter, then that parameter is queried per image</span>
<span class="sd">              to sample the order value to use.</span>

<span class="sd">    cval : number or tuple of two number or ia.ALL or StochasticParameter, optional(default=0)</span>
<span class="sd">        The constant value used for skimage&#39;s transform function.</span>
<span class="sd">        This is the value used to fill up pixels in the result image that</span>
<span class="sd">        didn&#39;t exist in the input image (e.g. when translating to the left,</span>
<span class="sd">        some new pixels are created at the right). Such a fill-up with a</span>
<span class="sd">        constant value only happens, when `mode` is &quot;constant&quot;.</span>
<span class="sd">        For standard uint8 images (value range 0-255), this value may also</span>
<span class="sd">        come from the range 0-255. It may be a float value, even for</span>
<span class="sd">        integer image dtypes.</span>
<span class="sd">            * If this is a single int or float, then that value will be used</span>
<span class="sd">              (e.g. 0 results in black pixels).</span>
<span class="sd">            * If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b</span>
<span class="sd">              is picked per image.</span>
<span class="sd">            * If ia.ALL, a value from the discrete range [0 .. 255] will be</span>
<span class="sd">              sampled per image.</span>
<span class="sd">            * If a StochasticParameter, a new value will be sampled from the</span>
<span class="sd">              parameter per image.</span>

<span class="sd">    mode : string or list of string or ia.ALL or StochasticParameter, optional(default=&quot;constant&quot;)</span>
<span class="sd">        Parameter that defines the handling of newly created pixels.</span>
<span class="sd">        Same meaning as in skimage (and numpy.pad):</span>
<span class="sd">            * &quot;constant&quot;: Pads with a constant value</span>
<span class="sd">            * &quot;edge&quot;: Pads with the edge values of array</span>
<span class="sd">            * &quot;symmetric&quot;: Pads with the reflection of the vector mirrored</span>
<span class="sd">              along the edge of the array.</span>
<span class="sd">            * &quot;reflect&quot;: Pads with the reflection of the vector mirrored on</span>
<span class="sd">              the first and last values of the vector along each axis.</span>
<span class="sd">            * &quot;wrap&quot;: Pads with the wrap of the vector along the axis.</span>
<span class="sd">              The first values are used to pad the end and the end values</span>
<span class="sd">              are used to pad the beginning.</span>
<span class="sd">        If `cv2` is chosen as the backend the mapping is as</span>
<span class="sd">        follows:</span>
<span class="sd">            * &quot;constant&quot; -&gt; cv2.BORDER_CONSTANT</span>
<span class="sd">            * &quot;edge&quot; -&gt; cv2.BORDER_REPLICATE</span>
<span class="sd">            * &quot;symmetric&quot; -&gt; cv2.BORDER_REFLECT</span>
<span class="sd">            * &quot;reflect&quot; -&gt; cv2.BORDER_REFLECT_101</span>
<span class="sd">            * &quot;wrap&quot; -&gt; cv2.BORDER_WRAP</span>
<span class="sd">        The datatype of the parameter may</span>
<span class="sd">        be:</span>
<span class="sd">            * If a single string, then that mode will be used for all images.</span>
<span class="sd">            * If a list of strings, then per image a random mode will be picked</span>
<span class="sd">              from that list.</span>
<span class="sd">            * If ia.ALL, then a random mode from all possible modes will be</span>
<span class="sd">              picked.</span>
<span class="sd">            * If StochasticParameter, then the mode will be sampled from that</span>
<span class="sd">              parameter per image, i.e. it must return only the above mentioned</span>
<span class="sd">              strings.</span>

<span class="sd">    backend : string, optional(default=&quot;auto&quot;)</span>
<span class="sd">        Framework to use as a backend. Valid values are `auto`, `skimage`</span>
<span class="sd">        (scikit-image&#39;s warp) and `cv2` (opencv&#39;s warp).</span>
<span class="sd">        If `auto` is used, the augmenter will automatically try</span>
<span class="sd">        to use cv2 where possible (order must be in [0, 1, 3] and</span>
<span class="sd">        image&#39;s dtype uint8, otherwise skimage is chosen). It will</span>
<span class="sd">        silently fall back to skimage if order/dtype is not supported by cv2.</span>
<span class="sd">        cv2 is generally faster than skimage. It also supports RGB cvals,</span>
<span class="sd">        while skimage will resort to intensity cvals (i.e. 3x the same value</span>
<span class="sd">        as RGB). If `cv2` is chosen and order is 2 or 4, it will automatically</span>
<span class="sd">        fall back to order 3.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(scale=2.0)</span>

<span class="sd">    zooms all images by a factor of 2.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(translate_px=16)</span>

<span class="sd">    translates all images on the x- and y-axis by 16 pixels (to the</span>
<span class="sd">    right/top), fills up any new pixels with zero (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(translate_percent=0.1)</span>

<span class="sd">    translates all images on the x- and y-axis by 10 percent of their</span>
<span class="sd">    width/height (to the right/top), fills up any new pixels with zero</span>
<span class="sd">    (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(rotate=35)</span>

<span class="sd">    rotates all images by 35 degrees, fills up any new pixels with zero</span>
<span class="sd">    (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(shear=15)</span>

<span class="sd">    rotates all images by 15 degrees, fills up any new pixels with zero</span>
<span class="sd">    (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(translate_px=(-16, 16))</span>

<span class="sd">    translates all images on the x- and y-axis by a random value</span>
<span class="sd">    between -16 and 16 pixels (to the right/top) (same for both axis, i.e.</span>
<span class="sd">    sampled once per image), fills up any new pixels with zero (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(translate_px={&quot;x&quot;: (-16, 16), &quot;y&quot;: (-4, 4)})</span>

<span class="sd">    translates all images on the x-axis by a random value</span>
<span class="sd">    between -16 and 16 pixels (to the right) and on the y-axis by a</span>
<span class="sd">    random value between -4 and 4 pixels to the top. Even if both ranges</span>
<span class="sd">    were the same, both axis could use different samples.</span>
<span class="sd">    Fills up any new pixels with zero (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(scale=2.0, order=[0, 1])</span>

<span class="sd">    same as previously, but uses (randomly) either nearest neighbour</span>
<span class="sd">    interpolation or linear interpolation.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(translate_px=16, cval=(0, 255))</span>

<span class="sd">    same as previously, but fills up any new pixels with a random</span>
<span class="sd">    brightness (same for the whole image).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.Affine(translate_px=16, mode=[&quot;constant&quot;, &quot;edge&quot;])</span>

<span class="sd">    same as previously, but fills up the new pixels in only 50 percent</span>
<span class="sd">    of all images with black values. In the other 50 percent of all cases,</span>
<span class="sd">    the value of the nearest edge is used.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">translate_percent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">translate_px</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">rotate</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
                 <span class="n">backend</span><span class="o">=</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Affine</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">backend</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;auto&quot;</span><span class="p">,</span> <span class="s2">&quot;skimage&quot;</span><span class="p">,</span> <span class="s2">&quot;cv2&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span>

        <span class="c1"># skimage | cv2</span>
        <span class="c1"># 0       | cv2.INTER_NEAREST</span>
        <span class="c1"># 1       | cv2.INTER_LINEAR</span>
        <span class="c1"># 2       | -</span>
        <span class="c1"># 3       | cv2.INTER_CUBIC</span>
        <span class="c1"># 4       | -</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order_map_skimage_cv2</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">0</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_NEAREST</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_CUBIC</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_CUBIC</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_CUBIC</span>
        <span class="p">}</span>
        <span class="c1"># Peformance in skimage:</span>
        <span class="c1">#  1.0x order 0</span>
        <span class="c1">#  1.5x order 1</span>
        <span class="c1">#  3.0x order 3</span>
        <span class="c1"># 30.0x order 4</span>
        <span class="c1"># 60.0x order 5</span>
        <span class="c1"># measurement based on 256x256x3 batches, difference is smaller</span>
        <span class="c1"># on smaller images (seems to grow more like exponentially with image</span>
        <span class="c1"># size)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span> <span class="ow">or</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;cv2&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span> <span class="c1"># dont use order=2 (bi-quadratic) because that is apparently currently not recommended (and throws a warning)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Expected order&#39;s integer value to be in range 0 &lt;= x &lt;= 5, got </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">order</span><span class="p">,))</span>
            <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;cv2&quot;</span><span class="p">:</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">order</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),</span> <span class="s2">&quot;Expected order list to only contain integers, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),</span> <span class="s2">&quot;Expected all of order&#39;s integer values to be in range 0 &lt;= x &lt;= 5, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>
            <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;cv2&quot;</span><span class="p">:</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected order to be imgaug.ALL, int, list of int or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">cval</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span> <span class="c1"># skimage transform expects float</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">cval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># skimage transform expects float</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cval</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">cval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected cval to be imgaug.ALL, int, float or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cval</span><span class="p">),))</span>

        <span class="c1"># constant, edge, symmetric, reflect, wrap</span>
        <span class="c1"># skimage   | cv2</span>
        <span class="c1"># constant  | cv2.BORDER_CONSTANT</span>
        <span class="c1"># edge      | cv2.BORDER_REPLICATE</span>
        <span class="c1"># symmetric | cv2.BORDER_REFLECT</span>
        <span class="c1"># reflect   | cv2.BORDER_REFLECT_101</span>
        <span class="c1"># wrap      | cv2.BORDER_WRAP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_map_skimage_cv2</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;constant&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_CONSTANT</span><span class="p">,</span>
            <span class="s2">&quot;edge&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span><span class="p">,</span>
            <span class="s2">&quot;symmetric&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT</span><span class="p">,</span>
            <span class="s2">&quot;reflect&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT_101</span><span class="p">,</span>
            <span class="s2">&quot;wrap&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_WRAP</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="s2">&quot;wrap&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected mode to be imgaug.ALL, a string, a list of strings or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mode</span><span class="p">),))</span>

        <span class="c1"># scale</span>
        <span class="c1"># float | (float, float) | [float, float] | StochasticParameter</span>
        <span class="k">def</span> <span class="nf">scale_handle_param</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">allow_dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">param</span>
            <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">param</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;Expected scale to have range (0, inf), got value </span><span class="si">%.4f</span><span class="s2">. Note: The value to _not_ change the scale of images is 1.0, not 0.0.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">param</span><span class="p">,))</span>
                <span class="k">return</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected scale tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;Expected scale tuple/list to have values in range (0, inf), got values </span><span class="si">%.4f</span><span class="s2"> and </span><span class="si">%.4f</span><span class="s2">. Note: The value to _not_ change the scale of images is 1.0, not 0.0.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">allow_dict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">param</span> <span class="ow">or</span> <span class="s2">&quot;y&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>

                <span class="k">return</span> <span class="p">(</span><span class="n">scale_handle_param</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">scale_handle_param</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int, tuple/list with 2 entries or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale_handle_param</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># translate</span>
        <span class="k">if</span> <span class="n">translate_percent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">translate_px</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">translate_px</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">translate_percent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">translate_px</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">translate_percent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># translate by percent</span>
            <span class="k">def</span> <span class="nf">translate_handle_param</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">allow_dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">Deterministic</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected translate_percent tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
                    <span class="n">all_numbers</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">])</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">all_numbers</span><span class="p">,</span> <span class="s2">&quot;Expected translate_percent tuple/list to contain only numbers, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">]),))</span>
                    <span class="c1">#ia.do_assert(param[0] &gt; 0.0 and param[1] &gt; 0.0, &quot;Expected translate_percent tuple/list to have values in range (0, inf), got values %.4f and %.4f.&quot; % (param[0], param[1]))</span>
                    <span class="k">return</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">allow_dict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">param</span> <span class="ow">or</span> <span class="s2">&quot;y&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">)</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>

                    <span class="k">return</span> <span class="p">(</span><span class="n">translate_handle_param</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">translate_handle_param</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">param</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int or tuple/list with 2 entries of both floats or ints or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate_handle_param</span><span class="p">(</span><span class="n">translate_percent</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># translate by pixels</span>
            <span class="k">def</span> <span class="nf">translate_handle_param</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">allow_dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected translate_px tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
                    <span class="n">all_integer</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">])</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">all_integer</span><span class="p">,</span> <span class="s2">&quot;Expected translate_px tuple/list to contain only integers, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">]),))</span>
                    <span class="k">return</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">allow_dict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">param</span> <span class="ow">or</span> <span class="s2">&quot;y&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">)</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>

                    <span class="k">return</span> <span class="p">(</span><span class="n">translate_handle_param</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">translate_handle_param</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">param</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected int or tuple/list with 2 ints or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate_handle_param</span><span class="p">(</span><span class="n">translate_px</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># rotate</span>
        <span class="c1"># StochasticParameter | float | int | (float or int, float or int) | [float or int, float or int]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotate</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span> <span class="o">=</span> <span class="n">rotate</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">rotate</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">rotate</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">rotate</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rotate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected rotate tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rotate</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">rotate</span><span class="p">]),</span> <span class="s2">&quot;Expected floats/ints in rotate tuple/list&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int, tuple/list with 2 entries or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rotate</span><span class="p">),))</span>

        <span class="c1"># shear</span>
        <span class="c1"># StochasticParameter | float | int | (float or int, float or int) | [float or int, float or int]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">shear</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">shear</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">shear</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected rotate tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shear</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">shear</span><span class="p">]),</span> <span class="s2">&quot;Expected floats/ints in shear tuple/list.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int, tuple/list with 2 entries or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">shear</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="c1">#images = images if isinstance(images, list) else [images]</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="c1">#result = [None] * nb_images</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>

        <span class="n">scale_samples</span><span class="p">,</span> <span class="n">translate_samples</span><span class="p">,</span> <span class="n">rotate_samples</span><span class="p">,</span> <span class="n">shear_samples</span><span class="p">,</span> <span class="n">cval_samples</span><span class="p">,</span> <span class="n">mode_samples</span><span class="p">,</span> <span class="n">order_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_samples</span><span class="p">(</span><span class="n">nb_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span> <span class="o">=</span> <span class="n">scale_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">scale_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">translate_x</span><span class="p">,</span> <span class="n">translate_y</span> <span class="o">=</span> <span class="n">translate_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">translate_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#ia.do_assert(isinstance(translate_x, (float, int)))</span>
            <span class="c1">#ia.do_assert(isinstance(translate_y, (float, int)))</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">translate_y</span><span class="p">):</span>
                <span class="n">translate_y_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">translate_y</span> <span class="o">*</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translate_y_px</span> <span class="o">=</span> <span class="n">translate_y</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">translate_x</span><span class="p">):</span>
                <span class="n">translate_x_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">translate_x</span> <span class="o">*</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translate_x_px</span> <span class="o">=</span> <span class="n">translate_x</span>
            <span class="n">rotate</span> <span class="o">=</span> <span class="n">rotate_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">shear_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cval</span> <span class="o">=</span> <span class="n">cval_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">mode_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">scale_x</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">scale_y</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">translate_x_px</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">translate_y_px</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rotate</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">shear</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cv2_bad_order</span> <span class="o">=</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">cv2_bad_dtype</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]</span>
                <span class="n">cv2_bad_shape</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">4</span>
                <span class="n">cv2_impossible</span> <span class="o">=</span> <span class="n">cv2_bad_order</span> <span class="ow">or</span> <span class="n">cv2_bad_dtype</span> <span class="ow">or</span> <span class="n">cv2_bad_shape</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;skimage&quot;</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span> <span class="ow">and</span> <span class="n">cv2_impossible</span><span class="p">):</span>
                    <span class="c1"># cval contains 3 values as cv2 can handle 3, but skimage only 1</span>
                    <span class="n">cval</span> <span class="o">=</span> <span class="n">cval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># skimage does not clip automatically</span>
                    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
                        <span class="n">cval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">cval</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
                    <span class="n">image_warped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warp_skimage</span><span class="p">(</span>
                        <span class="n">image</span><span class="p">,</span>
                        <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">,</span>
                        <span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">,</span>
                        <span class="n">rotate</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span>
                        <span class="n">cval</span><span class="p">,</span>
                        <span class="n">mode</span><span class="p">,</span> <span class="n">order</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="ow">not</span> <span class="n">cv2_bad_dtype</span><span class="p">,</span> <span class="s2">&quot;cv2 backend can only handle images of dtype uint8, float32 and float64, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,))</span>
                    <span class="c1"># opencv seems to support arrays of three cvals (ie RGB)</span>
                    <span class="c1"># in python2, but for some reason not in python3, so</span>
                    <span class="c1"># we chose one cval here</span>
                    <span class="c1">#cval = cval[0]</span>
                    <span class="c1">#print(cval, type(cval), int(cval), type(int(cval)))</span>
                    <span class="n">image_warped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warp_cv2</span><span class="p">(</span>
                        <span class="n">image</span><span class="p">,</span>
                        <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">,</span>
                        <span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">,</span>
                        <span class="n">rotate</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span>
                        <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cval</span><span class="p">]),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mode_map_skimage_cv2</span><span class="p">[</span><span class="n">mode</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">order_map_skimage_cv2</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
                    <span class="p">)</span>

                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_warped</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">)</span>
        <span class="n">scale_samples</span><span class="p">,</span> <span class="n">translate_samples</span><span class="p">,</span> <span class="n">rotate_samples</span><span class="p">,</span> <span class="n">shear_samples</span><span class="p">,</span> <span class="n">_cval_samples</span><span class="p">,</span> <span class="n">_mode_samples</span><span class="p">,</span> <span class="n">_order_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_samples</span><span class="p">(</span><span class="n">nb_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">keypoints_on_image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">):</span>
            <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">width</span>
            <span class="n">shift_x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">shift_y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span> <span class="o">=</span> <span class="n">scale_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">scale_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">translate_x</span><span class="p">,</span> <span class="n">translate_y</span> <span class="o">=</span> <span class="n">translate_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">translate_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#ia.do_assert(isinstance(translate_x, (float, int)))</span>
            <span class="c1">#ia.do_assert(isinstance(translate_y, (float, int)))</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">translate_y</span><span class="p">):</span>
                <span class="n">translate_y_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">translate_y</span> <span class="o">*</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translate_y_px</span> <span class="o">=</span> <span class="n">translate_y</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">translate_x</span><span class="p">):</span>
                <span class="n">translate_x_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">translate_x</span> <span class="o">*</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translate_x_px</span> <span class="o">=</span> <span class="n">translate_x</span>
            <span class="n">rotate</span> <span class="o">=</span> <span class="n">rotate_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">shear_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#cval = cval_samples[i]</span>
            <span class="c1">#mode = mode_samples[i]</span>
            <span class="c1">#order = order_samples[i]</span>
            <span class="k">if</span> <span class="n">scale_x</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">scale_y</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">translate_x_px</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">translate_y_px</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rotate</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">shear</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">matrix_to_topleft</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">shift_x</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_y</span><span class="p">])</span>
                <span class="n">matrix_transforms</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">(</span>
                    <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">),</span>
                    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">),</span>
                    <span class="n">rotation</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">rotate</span><span class="p">),</span>
                    <span class="n">shear</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">matrix_to_center</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="n">shift_x</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">])</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix_to_topleft</span> <span class="o">+</span> <span class="n">matrix_transforms</span> <span class="o">+</span> <span class="n">matrix_to_center</span><span class="p">)</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">get_coords_array</span><span class="p">()</span>
                <span class="c1">#print(&quot;coords&quot;, coords)</span>
                <span class="c1">#print(&quot;matrix&quot;, matrix.params)</span>
                <span class="n">coords_aug</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                <span class="c1">#print(&quot;coords before&quot;, coords)</span>
                <span class="c1">#print(&quot;coordsa ftre&quot;, coords_aug, np.around(coords_aug).astype(np.int32))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">KeypointsOnImage</span><span class="o">.</span><span class="n">from_coords_array</span><span class="p">(</span><span class="n">coords_aug</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keypoints_on_image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Affine.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.Affine.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_draw_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">scale_samples</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">20</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">30</span><span class="p">))</span>
            <span class="n">scale_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale_samples</span><span class="p">,</span> <span class="n">scale_samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">translate_samples</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">50</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">translate_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">60</span><span class="p">))</span>
            <span class="n">translate_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">translate_samples</span><span class="p">,</span> <span class="n">translate_samples</span><span class="p">)</span>

        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">translate_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">translate_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>

        <span class="n">rotate_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">70</span><span class="p">))</span>
        <span class="n">shear_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">80</span><span class="p">))</span>

        <span class="n">cval_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">90</span><span class="p">))</span>
        <span class="n">mode_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">100</span><span class="p">))</span>
        <span class="n">order_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">110</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">scale_samples</span><span class="p">,</span> <span class="n">translate_samples</span><span class="p">,</span> <span class="n">rotate_samples</span><span class="p">,</span> <span class="n">shear_samples</span><span class="p">,</span> <span class="n">cval_samples</span><span class="p">,</span> <span class="n">mode_samples</span><span class="p">,</span> <span class="n">order_samples</span>

    <span class="k">def</span> <span class="nf">_warp_skimage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">,</span> <span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">,</span> <span class="n">rotate</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">shift_x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="n">shift_y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>

        <span class="n">matrix_to_topleft</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">shift_x</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_y</span><span class="p">])</span>
        <span class="n">matrix_transforms</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">(</span>
            <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">),</span>
            <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">),</span>
            <span class="n">rotation</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">rotate</span><span class="p">),</span>
            <span class="n">shear</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">matrix_to_center</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="n">shift_x</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">])</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix_to_topleft</span> <span class="o">+</span> <span class="n">matrix_transforms</span> <span class="o">+</span> <span class="n">matrix_to_center</span><span class="p">)</span>
        <span class="n">image_warped</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span>
            <span class="n">matrix</span><span class="o">.</span><span class="n">inverse</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span>
            <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="c1"># warp changes uint8 to float64, making this necessary</span>
        <span class="k">if</span> <span class="n">image_warped</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="n">image_warped</span> <span class="o">=</span> <span class="n">image_warped</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image_warped</span>

    <span class="k">def</span> <span class="nf">_warp_cv2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span> <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">,</span> <span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">,</span> <span class="n">rotate</span><span class="p">,</span> <span class="n">shear</span><span class="p">,</span> <span class="n">cval</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">shift_x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="n">shift_y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>

        <span class="n">matrix_to_topleft</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">shift_x</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_y</span><span class="p">])</span>
        <span class="n">matrix_transforms</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">(</span>
            <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">),</span>
            <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">),</span>
            <span class="n">rotation</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">rotate</span><span class="p">),</span>
            <span class="n">shear</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">matrix_to_center</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="n">shift_x</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">])</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix_to_topleft</span> <span class="o">+</span> <span class="n">matrix_transforms</span> <span class="o">+</span> <span class="n">matrix_to_center</span><span class="p">)</span>

        <span class="n">image_warped</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpAffine</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span>
            <span class="n">matrix</span><span class="o">.</span><span class="n">params</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
            <span class="c1">#np.zeros((2, 3)),</span>
            <span class="n">dsize</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span>
            <span class="n">flags</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">borderMode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">borderValue</span><span class="o">=</span><span class="n">cval</span>
        <span class="p">)</span>

        <span class="c1"># cv2 warp drops last axis if shape is (H, W, 1)</span>
        <span class="k">if</span> <span class="n">image_warped</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">image_warped</span> <span class="o">=</span> <span class="n">image_warped</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">image_warped</span></div>

<div class="viewcode-block" id="AffineCv2"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.AffineCv2">[docs]</a><span class="k">class</span> <span class="nc">AffineCv2</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter to apply affine transformations to images using cv2 (i.e. opencv)</span>
<span class="sd">    backend.</span>

<span class="sd">    NOTE: This augmenter will likely be removed in the future as Affine() already</span>
<span class="sd">    offers a cv2 backend (use `backend=&quot;cv2&quot;`).</span>

<span class="sd">    Affine transformations</span>
<span class="sd">    involve:</span>
<span class="sd">        - Translation (&quot;move&quot; image on the x-/y-axis)</span>
<span class="sd">        - Rotation</span>
<span class="sd">        - Scaling (&quot;zoom&quot; in/out)</span>
<span class="sd">        - Shear (move one side of the image, turning a square into a trapezoid)</span>

<span class="sd">    All such transformations can create &quot;new&quot; pixels in the image without a</span>
<span class="sd">    defined content, e.g. if the image is translated to the left, pixels</span>
<span class="sd">    are created on the right.</span>
<span class="sd">    A method has to be defined to deal with these pixel values. The</span>
<span class="sd">    parameters `cval` and `mode` of this class deal with this.</span>

<span class="sd">    Some transformations involve interpolations between several pixels</span>
<span class="sd">    of the input image to generate output pixel values. The parameter `order`</span>
<span class="sd">    deals with the method of interpolation used for this.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scale : float or tuple of two floats or StochasticParameter or dict {&quot;x&quot;: float/tuple/StochasticParameter, &quot;y&quot;: float/tuple/StochasticParameter}, optional(default=1.0)</span>
<span class="sd">        Scaling factor to use, where 1.0 represents no change and 0.5 is</span>
<span class="sd">        zoomed out to 50 percent of the original size.</span>
<span class="sd">            * If a single float, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled from the range</span>
<span class="sd">              a &lt;= x &lt;= b per image. That value will be used identically for</span>
<span class="sd">              both x- and y-axis.</span>
<span class="sd">            * If a StochasticParameter, then from that parameter a value will</span>
<span class="sd">              be sampled per image (again, used for both x- and y-axis).</span>
<span class="sd">            * If a dictionary, then it is expected to have the keys &quot;x&quot; and/or &quot;y&quot;.</span>
<span class="sd">              Each of these keys can have the same values as described before</span>
<span class="sd">              for this whole parameter (`scale`). Using a dictionary allows to</span>
<span class="sd">              set different values for the axis. If they are set to the same</span>
<span class="sd">              ranges, different values may still be sampled per axis.</span>

<span class="sd">    translate_percent : float or tuple of two floats or StochasticParameter or dict {&quot;x&quot;: float/tuple/StochasticParameter, &quot;y&quot;: float/tuple/StochasticParameter}, optional(default=1.0)</span>
<span class="sd">        Translation in percent relative to the image</span>
<span class="sd">        height/width (x-translation, y-translation) to use,</span>
<span class="sd">        where 0 represents no change and 0.5 is half of the image</span>
<span class="sd">        height/width.</span>
<span class="sd">            * If a single float, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled from the range</span>
<span class="sd">              a &lt;= x &lt;= b per image. That percent value will be used identically</span>
<span class="sd">              for both x- and y-axis.</span>
<span class="sd">            * If a StochasticParameter, then from that parameter a value will</span>
<span class="sd">              be sampled per image (again, used for both x- and y-axis).</span>
<span class="sd">            * If a dictionary, then it is expected to have the keys &quot;x&quot; and/or &quot;y&quot;.</span>
<span class="sd">              Each of these keys can have the same values as described before</span>
<span class="sd">              for this whole parameter (`translate_percent`).</span>
<span class="sd">              Using a dictionary allows to set different values for the axis.</span>
<span class="sd">              If they are set to the same ranges, different values may still</span>
<span class="sd">              be sampled per axis.</span>

<span class="sd">    translate_px : int or tuple of two ints or StochasticParameter or dict {&quot;x&quot;: int/tuple/StochasticParameter, &quot;y&quot;: int/tuple/StochasticParameter}, optional(default=1.0)</span>
<span class="sd">        Translation in</span>
<span class="sd">        pixels.</span>
<span class="sd">            * If a single int, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled from the discrete</span>
<span class="sd">              range [a .. b] per image. That number will be used identically</span>
<span class="sd">              for both x- and y-axis.</span>
<span class="sd">            * If a StochasticParameter, then from that parameter a value will</span>
<span class="sd">              be sampled per image (again, used for both x- and y-axis).</span>
<span class="sd">            * If a dictionary, then it is expected to have the keys &quot;x&quot; and/or &quot;y&quot;.</span>
<span class="sd">              Each of these keys can have the same values as described before</span>
<span class="sd">              for this whole parameter (`translate_px`).</span>
<span class="sd">              Using a dictionary allows to set different values for the axis.</span>
<span class="sd">              If they are set to the same ranges, different values may still</span>
<span class="sd">              be sampled per axis.</span>

<span class="sd">    rotate : float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)</span>
<span class="sd">        Rotation in degrees (NOT radians), i.e. expected value range is</span>
<span class="sd">        0 to 360 for positive rotations (may also be negative).</span>
<span class="sd">            * If a float/int, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled per image from the</span>
<span class="sd">              range a &lt;= x &lt;= b and be used as the rotation value.</span>
<span class="sd">            * If a StochasticParameter, then this parameter will be used to</span>
<span class="sd">              sample the rotation value per image.</span>

<span class="sd">    shear : float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)</span>
<span class="sd">        Shear in degrees (NOT radians), i.e. expected value range is</span>
<span class="sd">        0 to 360 for positive shear (may also be negative).</span>
<span class="sd">            * If a float/int, then that value will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a value will be sampled per image from the</span>
<span class="sd">              range a &lt;= x &lt;= b and be used as the rotation value.</span>
<span class="sd">            * If a StochasticParameter, then this parameter will be used to</span>
<span class="sd">              sample the shear value per image.</span>

<span class="sd">    order : int or iterable of int or string or iterable of string or ia.ALL or StochasticParameter, optional(default=1)</span>
<span class="sd">        Interpolation order to use. Allowed are:</span>
<span class="sd">            * cv2.INTER_NEAREST - a nearest-neighbor interpolation</span>
<span class="sd">            * cv2.INTER_LINEAR - a bilinear interpolation (used by default)</span>
<span class="sd">            * cv2.INTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhood</span>
<span class="sd">            * cv2.INTER_LANCZOS4</span>
<span class="sd">            * &quot;nearest&quot;</span>
<span class="sd">            * &quot;linear&quot;</span>
<span class="sd">            * &quot;cubic&quot;,</span>
<span class="sd">            * &quot;lanczos4&quot;</span>
<span class="sd">        The first four are OpenCV constants, the other four are strings that</span>
<span class="sd">        are automatically replaced by the OpenCV constants.</span>
<span class="sd">        INTER_NEAREST (nearest neighbour interpolation) and INTER_NEAREST</span>
<span class="sd">        (linear interpolation) are the fastest.</span>
<span class="sd">            * If a single int, then that order will be used for all images.</span>
<span class="sd">            * If a string, then it must be one of: &quot;nearest&quot;, &quot;linear&quot;, &quot;cubic&quot;,</span>
<span class="sd">              &quot;lanczos4&quot;.</span>
<span class="sd">            * If an iterable of int/string, then for each image a random value</span>
<span class="sd">              will be sampled from that iterable (i.e. list of allowed order</span>
<span class="sd">              values).</span>
<span class="sd">            * If ia.ALL, then equivalant to list [cv2.INTER_NEAREST,</span>
<span class="sd">              cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_LANCZOS4].</span>
<span class="sd">            * If StochasticParameter, then that parameter is queried per image</span>
<span class="sd">              to sample the order value to use.</span>

<span class="sd">    cval : number or tuple of two number or ia.ALL or StochasticParameter, optional(default=0)</span>
<span class="sd">        The constant value used for skimage&#39;s transform function.</span>
<span class="sd">        This is the value used to fill up pixels in the result image that</span>
<span class="sd">        didn&#39;t exist in the input image (e.g. when translating to the left,</span>
<span class="sd">        some new pixels are created at the right). Such a fill-up with a</span>
<span class="sd">        constant value only happens, when `mode` is &quot;constant&quot;.</span>
<span class="sd">        For standard uint8 images (value range 0-255), this value may also</span>
<span class="sd">        come from the range 0-255. It may be a float value, even for</span>
<span class="sd">        integer image dtypes.</span>
<span class="sd">            * If this is a single int or float, then that value will be used</span>
<span class="sd">              (e.g. 0 results in black pixels).</span>
<span class="sd">            * If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b</span>
<span class="sd">              is picked per image.</span>
<span class="sd">            * If ia.ALL, a value from the discrete range [0 .. 255] will be</span>
<span class="sd">              sampled per image.</span>
<span class="sd">            * If a StochasticParameter, a new value will be sampled from the</span>
<span class="sd">              parameter per image.</span>

<span class="sd">    mode : int or string or list of string or list of ints or ia.ALL or StochasticParameter, optional(default=&quot;constant&quot;)</span>
<span class="sd">        Parameter that defines the handling of newly created pixels.</span>
<span class="sd">        Same meaning as in opencv&#39;s border mode. Let `abcdefgh` be an image</span>
<span class="sd">        content and `|` be an image boundary, then:</span>
<span class="sd">            * `cv2.BORDER_REPLICATE`: `aaaaaa|abcdefgh|hhhhhhh`</span>
<span class="sd">            * `cv2.BORDER_REFLECT`: `fedcba|abcdefgh|hgfedcb`</span>
<span class="sd">            * `cv2.BORDER_REFLECT_101`: `gfedcb|abcdefgh|gfedcba`</span>
<span class="sd">            * `cv2.BORDER_WRAP`: `cdefgh|abcdefgh|abcdefg`</span>
<span class="sd">            * `cv2.BORDER_CONSTANT`: `iiiiii|abcdefgh|iiiiiii`, where `i` is</span>
<span class="sd">              the defined cval.</span>
<span class="sd">            * &quot;replicate&quot;: Same as cv2.BORDER_REPLICATE.</span>
<span class="sd">            * &quot;reflect&quot;: Same as cv2.BORDER_REFLECT.</span>
<span class="sd">            * &quot;reflect_101&quot;: Same as cv2.BORDER_REFLECT_101.</span>
<span class="sd">            * &quot;wrap&quot;: Same as cv2.BORDER_WRAP.</span>
<span class="sd">            * &quot;constant&quot;: Same as cv2.BORDER_CONSTANT.</span>
<span class="sd">        The datatype of the parameter may</span>
<span class="sd">        be:</span>
<span class="sd">            * If a single int, then it must be one of `cv2.BORDER_*`.</span>
<span class="sd">            * If a single string, then it must be one of: &quot;replicate&quot;,</span>
<span class="sd">              &quot;reflect&quot;, &quot;reflect_101&quot;, &quot;wrap&quot;, &quot;constant&quot;.</span>
<span class="sd">            * If a list of ints/strings, then per image a random mode will be</span>
<span class="sd">              picked from that list.</span>
<span class="sd">            * If ia.ALL, then a random mode from all possible modes will be</span>
<span class="sd">              picked.</span>
<span class="sd">            * If StochasticParameter, then the mode will be sampled from that</span>
<span class="sd">              parameter per image, i.e. it must return only the above mentioned</span>
<span class="sd">              strings.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(scale=2.0)</span>

<span class="sd">    zooms all images by a factor of 2.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(translate_px=16)</span>

<span class="sd">    translates all images on the x- and y-axis by 16 pixels (to the</span>
<span class="sd">    right/top), fills up any new pixels with zero (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(translate_percent=0.1)</span>

<span class="sd">    translates all images on the x- and y-axis by 10 percent of their</span>
<span class="sd">    width/height (to the right/top), fills up any new pixels with zero</span>
<span class="sd">    (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(rotate=35)</span>

<span class="sd">    rotates all images by 35 degrees, fills up any new pixels with zero</span>
<span class="sd">    (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(shear=15)</span>

<span class="sd">    rotates all images by 15 degrees, fills up any new pixels with zero</span>
<span class="sd">    (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(translate_px=(-16, 16))</span>

<span class="sd">    translates all images on the x- and y-axis by a random value</span>
<span class="sd">    between -16 and 16 pixels (to the right/top) (same for both axis, i.e.</span>
<span class="sd">    sampled once per image), fills up any new pixels with zero (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(translate_px={&quot;x&quot;: (-16, 16), &quot;y&quot;: (-4, 4)})</span>

<span class="sd">    translates all images on the x-axis by a random value</span>
<span class="sd">    between -16 and 16 pixels (to the right) and on the y-axis by a</span>
<span class="sd">    random value between -4 and 4 pixels to the top. Even if both ranges</span>
<span class="sd">    were the same, both axis could use different samples.</span>
<span class="sd">    Fills up any new pixels with zero (black values).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(scale=2.0, order=[0, 1])</span>

<span class="sd">    same as previously, but uses (randomly) either nearest neighbour</span>
<span class="sd">    interpolation or linear interpolation.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(translate_px=16, cval=(0, 255))</span>

<span class="sd">    same as previously, but fills up any new pixels with a random</span>
<span class="sd">    brightness (same for the whole image).</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.AffineCv2(translate_px=16, mode=[&quot;constant&quot;, &quot;replicate&quot;])</span>

<span class="sd">    same as previously, but fills up the new pixels in only 50 percent</span>
<span class="sd">    of all images with black values. In the other 50 percent of all cases,</span>
<span class="sd">    the value of the closest edge is used.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">translate_percent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">translate_px</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">rotate</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">shear</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_CONSTANT</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AffineCv2</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="n">available_orders</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">INTER_NEAREST</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_CUBIC</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LANCZOS4</span><span class="p">]</span>
        <span class="n">available_orders_str</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="s2">&quot;cubic&quot;</span><span class="p">,</span> <span class="s2">&quot;lanczos4&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">available_orders</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">order</span> <span class="ow">in</span> <span class="n">available_orders</span><span class="p">,</span> <span class="s2">&quot;Expected order&#39;s integer value to be in </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">available_orders</span><span class="p">),</span> <span class="n">order</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">order</span> <span class="ow">in</span> <span class="n">available_orders_str</span><span class="p">,</span> <span class="s2">&quot;Expected order to be in </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">available_orders_str</span><span class="p">),</span> <span class="n">order</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),</span> <span class="s2">&quot;Expected order list to only contain integers/strings, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">val</span> <span class="ow">in</span> <span class="n">available_orders</span> <span class="o">+</span> <span class="n">available_orders_str</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),</span> <span class="s2">&quot;Expected all order values to be in </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">available_orders</span> <span class="o">+</span> <span class="n">available_orders_str</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected order to be imgaug.ALL, int, string, a list of int/string or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">cval</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="n">cval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cval</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">cval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected cval to be imgaug.ALL, int, float or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cval</span><span class="p">),))</span>

        <span class="n">available_modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT_101</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_WRAP</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_CONSTANT</span><span class="p">]</span>
        <span class="n">available_modes_str</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;replicate&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect_101&quot;</span><span class="p">,</span> <span class="s2">&quot;wrap&quot;</span><span class="p">,</span> <span class="s2">&quot;constant&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">available_modes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">mode</span> <span class="ow">in</span> <span class="n">available_modes</span><span class="p">,</span> <span class="s2">&quot;Expected mode to be in </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">available_modes</span><span class="p">),</span> <span class="n">mode</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">mode</span> <span class="ow">in</span> <span class="n">available_modes_str</span><span class="p">,</span> <span class="s2">&quot;Expected mode to be in </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">available_modes_str</span><span class="p">),</span> <span class="n">mode</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">]),</span> <span class="s2">&quot;Expected mode list to only contain integers/strings, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">]),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">val</span> <span class="ow">in</span> <span class="n">available_modes</span> <span class="o">+</span> <span class="n">available_modes_str</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">]),</span> <span class="s2">&quot;Expected all mode values to be in </span><span class="si">%s</span><span class="s2">, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">available_modes</span> <span class="o">+</span> <span class="n">available_modes_str</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected mode to be imgaug.ALL, an int, a string, a list of int/strings or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mode</span><span class="p">),))</span>

        <span class="c1"># scale</span>
        <span class="c1"># float | (float, float) | [float, float] | StochasticParameter</span>
        <span class="k">def</span> <span class="nf">scale_handle_param</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">allow_dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">param</span>
            <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">param</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;Expected scale to have range (0, inf), got value </span><span class="si">%.4f</span><span class="s2">. Note: The value to _not_ change the scale of images is 1.0, not 0.0.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">param</span><span class="p">,))</span>
                <span class="k">return</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected scale tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;Expected scale tuple/list to have values in range (0, inf), got values </span><span class="si">%.4f</span><span class="s2"> and </span><span class="si">%.4f</span><span class="s2">. Note: The value to _not_ change the scale of images is 1.0, not 0.0.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">return</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">allow_dict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">param</span> <span class="ow">or</span> <span class="s2">&quot;y&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>

                <span class="k">return</span> <span class="p">(</span><span class="n">scale_handle_param</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">scale_handle_param</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int, tuple/list with 2 entries or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale_handle_param</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># translate</span>
        <span class="k">if</span> <span class="n">translate_percent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">translate_px</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">translate_px</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">translate_percent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">translate_px</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">translate_percent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># translate by percent</span>
            <span class="k">def</span> <span class="nf">translate_handle_param</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">allow_dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">Deterministic</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">param</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected translate_percent tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
                    <span class="n">all_numbers</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">])</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">all_numbers</span><span class="p">,</span> <span class="s2">&quot;Expected translate_percent tuple/list to contain only numbers, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">]),))</span>
                    <span class="c1">#ia.do_assert(param[0] &gt; 0.0 and param[1] &gt; 0.0, &quot;Expected translate_percent tuple/list to have values in range (0, inf), got values %.4f and %.4f.&quot; % (param[0], param[1]))</span>
                    <span class="k">return</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">allow_dict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">param</span> <span class="ow">or</span> <span class="s2">&quot;y&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">)</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>

                    <span class="k">return</span> <span class="p">(</span><span class="n">translate_handle_param</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">translate_handle_param</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">param</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int or tuple/list with 2 entries of both floats or ints or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate_handle_param</span><span class="p">(</span><span class="n">translate_percent</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># translate by pixels</span>
            <span class="k">def</span> <span class="nf">translate_handle_param</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">allow_dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected translate_px tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
                    <span class="n">all_integer</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">])</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">all_integer</span><span class="p">,</span> <span class="s2">&quot;Expected translate_px tuple/list to contain only integers, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param</span><span class="p">]),))</span>
                    <span class="k">return</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">allow_dict</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="s2">&quot;x&quot;</span> <span class="ow">in</span> <span class="n">param</span> <span class="ow">or</span> <span class="s2">&quot;y&quot;</span> <span class="ow">in</span> <span class="n">param</span><span class="p">)</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>

                    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>

                    <span class="k">return</span> <span class="p">(</span><span class="n">translate_handle_param</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span> <span class="n">translate_handle_param</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">param</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected int or tuple/list with 2 ints or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">param</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">translate</span> <span class="o">=</span> <span class="n">translate_handle_param</span><span class="p">(</span><span class="n">translate_px</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># rotate</span>
        <span class="c1"># StochasticParameter | float | int | (float or int, float or int) | [float or int, float or int]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rotate</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span> <span class="o">=</span> <span class="n">rotate</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">rotate</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">rotate</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">rotate</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rotate</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected rotate tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rotate</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">rotate</span><span class="p">]),</span> <span class="s2">&quot;Expected floats/ints in rotate tuple/list&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int, tuple/list with 2 entries or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rotate</span><span class="p">),))</span>

        <span class="c1"># shear</span>
        <span class="c1"># StochasticParameter | float | int | (float or int, float or int) | [float or int, float or int]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shear</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">shear</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">shear</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">shear</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected rotate tuple/list with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shear</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">shear</span><span class="p">]),</span> <span class="s2">&quot;Expected floats/ints in shear tuple/list.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shear</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">shear</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shear</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int, tuple/list with 2 entries or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">shear</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">order_str_to_int</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;nearest&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_NEAREST</span><span class="p">,</span>
            <span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LINEAR</span><span class="p">,</span>
            <span class="s2">&quot;cubic&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_CUBIC</span><span class="p">,</span>
            <span class="s2">&quot;lanczos4&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">INTER_LANCZOS4</span>
        <span class="p">}</span>
        <span class="n">mode_str_to_int</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;replicate&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span><span class="p">,</span>
            <span class="s2">&quot;reflect&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT</span><span class="p">,</span>
            <span class="s2">&quot;reflect_101&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_REFLECT_101</span><span class="p">,</span>
            <span class="s2">&quot;wrap&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_WRAP</span><span class="p">,</span>
            <span class="s2">&quot;constant&quot;</span><span class="p">:</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BORDER_CONSTANT</span>
        <span class="p">}</span>

        <span class="c1">#images = images if isinstance(images, list) else [images]</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="c1">#result = [None] * nb_images</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>

        <span class="n">scale_samples</span><span class="p">,</span> <span class="n">translate_samples</span><span class="p">,</span> <span class="n">rotate_samples</span><span class="p">,</span> <span class="n">shear_samples</span><span class="p">,</span> <span class="n">cval_samples</span><span class="p">,</span> <span class="n">mode_samples</span><span class="p">,</span> <span class="n">order_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_samples</span><span class="p">(</span><span class="n">nb_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">shift_x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">shift_y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span> <span class="o">=</span> <span class="n">scale_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">scale_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">translate_x</span><span class="p">,</span> <span class="n">translate_y</span> <span class="o">=</span> <span class="n">translate_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">translate_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#ia.do_assert(isinstance(translate_x, (float, int)))</span>
            <span class="c1">#ia.do_assert(isinstance(translate_y, (float, int)))</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">translate_y</span><span class="p">):</span>
                <span class="n">translate_y_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">translate_y</span> <span class="o">*</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translate_y_px</span> <span class="o">=</span> <span class="n">translate_y</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">translate_x</span><span class="p">):</span>
                <span class="n">translate_x_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">translate_x</span> <span class="o">*</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translate_x_px</span> <span class="o">=</span> <span class="n">translate_x</span>
            <span class="n">rotate</span> <span class="o">=</span> <span class="n">rotate_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">shear_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cval</span> <span class="o">=</span> <span class="n">cval_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#if ia.is_single_number(cval) or (ia.is_np_array(cval) and cval.shape == (1,)):</span>
            <span class="c1">#    cval = [cval, cval, cval]</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">mode_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span> <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="k">else</span> <span class="n">mode_str_to_int</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order</span> <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="k">else</span> <span class="n">order_str_to_int</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">scale_x</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">scale_y</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">translate_x_px</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">translate_y_px</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rotate</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">shear</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">matrix_to_topleft</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">shift_x</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_y</span><span class="p">])</span>
                <span class="n">matrix_transforms</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">(</span>
                    <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">),</span>
                    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">),</span>
                    <span class="n">rotation</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">rotate</span><span class="p">),</span>
                    <span class="n">shear</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">matrix_to_center</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="n">shift_x</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">])</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix_to_topleft</span> <span class="o">+</span> <span class="n">matrix_transforms</span> <span class="o">+</span> <span class="n">matrix_to_center</span><span class="p">)</span>

                <span class="n">image_warped</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpAffine</span><span class="p">(</span>
                    <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">matrix</span><span class="o">.</span><span class="n">params</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span>
                    <span class="c1">#np.zeros((2, 3)),</span>
                    <span class="n">dsize</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span>
                    <span class="n">flags</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                    <span class="n">borderMode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
                    <span class="n">borderValue</span><span class="o">=</span><span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cval</span><span class="p">])</span>
                <span class="p">)</span>

                <span class="c1"># cv2 warp drops last axis if shape is (H, W, 1)</span>
                <span class="k">if</span> <span class="n">image_warped</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">image_warped</span> <span class="o">=</span> <span class="n">image_warped</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

                <span class="c1"># warp changes uint8 to float64, making this necessary</span>
                <span class="c1">#if image_warped.dtype != images[i].dtype:</span>
                <span class="c1">#    image_warped = image_warped.astype(images[i].dtype, copy=False)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_warped</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">)</span>
        <span class="n">scale_samples</span><span class="p">,</span> <span class="n">translate_samples</span><span class="p">,</span> <span class="n">rotate_samples</span><span class="p">,</span> <span class="n">shear_samples</span><span class="p">,</span> <span class="n">_cval_samples</span><span class="p">,</span> <span class="n">_mode_samples</span><span class="p">,</span> <span class="n">_order_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_samples</span><span class="p">(</span><span class="n">nb_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">keypoints_on_image</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">):</span>
            <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">width</span>
            <span class="n">shift_x</span> <span class="o">=</span> <span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">shift_y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">-</span> <span class="mf">0.5</span>
            <span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span> <span class="o">=</span> <span class="n">scale_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">scale_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">translate_x</span><span class="p">,</span> <span class="n">translate_y</span> <span class="o">=</span> <span class="n">translate_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">translate_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#ia.do_assert(isinstance(translate_x, (float, int)))</span>
            <span class="c1">#ia.do_assert(isinstance(translate_y, (float, int)))</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">translate_y</span><span class="p">):</span>
                <span class="n">translate_y_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">translate_y</span> <span class="o">*</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translate_y_px</span> <span class="o">=</span> <span class="n">translate_y</span>
            <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_float</span><span class="p">(</span><span class="n">translate_x</span><span class="p">):</span>
                <span class="n">translate_x_px</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">translate_x</span> <span class="o">*</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translate_x_px</span> <span class="o">=</span> <span class="n">translate_x</span>
            <span class="n">rotate</span> <span class="o">=</span> <span class="n">rotate_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">shear</span> <span class="o">=</span> <span class="n">shear_samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#cval = cval_samples[i]</span>
            <span class="c1">#mode = mode_samples[i]</span>
            <span class="c1">#order = order_samples[i]</span>
            <span class="k">if</span> <span class="n">scale_x</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">scale_y</span> <span class="o">!=</span> <span class="mf">1.0</span> <span class="ow">or</span> <span class="n">translate_x_px</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">translate_y_px</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">rotate</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">shear</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">matrix_to_topleft</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">shift_x</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_y</span><span class="p">])</span>
                <span class="n">matrix_transforms</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">AffineTransform</span><span class="p">(</span>
                    <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="n">scale_x</span><span class="p">,</span> <span class="n">scale_y</span><span class="p">),</span>
                    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="n">translate_x_px</span><span class="p">,</span> <span class="n">translate_y_px</span><span class="p">),</span>
                    <span class="n">rotation</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">rotate</span><span class="p">),</span>
                    <span class="n">shear</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">shear</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">matrix_to_center</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">[</span><span class="n">shift_x</span><span class="p">,</span> <span class="n">shift_y</span><span class="p">])</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix_to_topleft</span> <span class="o">+</span> <span class="n">matrix_transforms</span> <span class="o">+</span> <span class="n">matrix_to_center</span><span class="p">)</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">get_coords_array</span><span class="p">()</span>
                <span class="c1">#print(&quot;coords&quot;, coords)</span>
                <span class="c1">#print(&quot;matrix&quot;, matrix.params)</span>
                <span class="n">coords_aug</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">matrix_transform</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                <span class="c1">#print(&quot;coords before&quot;, coords)</span>
                <span class="c1">#print(&quot;coordsa ftre&quot;, coords_aug, np.around(coords_aug).astype(np.int32))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ia</span><span class="o">.</span><span class="n">KeypointsOnImage</span><span class="o">.</span><span class="n">from_coords_array</span><span class="p">(</span><span class="n">coords_aug</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">keypoints_on_image</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="AffineCv2.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.AffineCv2.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_draw_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nb_samples</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">scale_samples</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">20</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scale_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">30</span><span class="p">))</span>
            <span class="n">scale_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">scale_samples</span><span class="p">,</span> <span class="n">scale_samples</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">translate_samples</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">40</span><span class="p">)),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">50</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">translate_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">60</span><span class="p">))</span>
            <span class="n">translate_samples</span> <span class="o">=</span> <span class="p">(</span><span class="n">translate_samples</span><span class="p">,</span> <span class="n">translate_samples</span><span class="p">)</span>

        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">translate_samples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">translate_samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">])</span>

        <span class="n">rotate_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">70</span><span class="p">))</span>
        <span class="n">shear_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shear</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">80</span><span class="p">))</span>

        <span class="n">cval_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">90</span><span class="p">))</span>
        <span class="n">mode_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">100</span><span class="p">))</span>
        <span class="n">order_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_samples</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">110</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">scale_samples</span><span class="p">,</span> <span class="n">translate_samples</span><span class="p">,</span> <span class="n">rotate_samples</span><span class="p">,</span> <span class="n">shear_samples</span><span class="p">,</span> <span class="n">cval_samples</span><span class="p">,</span> <span class="n">mode_samples</span><span class="p">,</span> <span class="n">order_samples</span></div>

<div class="viewcode-block" id="PiecewiseAffine"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.PiecewiseAffine">[docs]</a><span class="k">class</span> <span class="nc">PiecewiseAffine</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter that places a regular grid of points on an image and randomly</span>
<span class="sd">    moves the neighbourhood of these point around via affine transformations.</span>
<span class="sd">    This leads to local distortions.</span>

<span class="sd">    This is mostly a wrapper around scikit-image&#39;s PiecewiseAffine.</span>
<span class="sd">    See also the Affine augmenter for a similar technique.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scale : float or tuple of two floats or StochasticParameter, optional(default=0)</span>
<span class="sd">        Each point on the regular grid is moved around via a normal</span>
<span class="sd">        distribution. This scale factor is equivalent to the normal</span>
<span class="sd">        distribution&#39;s sigma. Note that the jitter (how far each point is</span>
<span class="sd">        moved in which direction) is multiplied by the height/width of the</span>
<span class="sd">        image if `absolute_scale=False` (default), so this scale can be</span>
<span class="sd">        the same for different sized images.</span>
<span class="sd">        Recommended values are in the range 0.01 to 0.05 (weak to strong</span>
<span class="sd">        augmentations).</span>
<span class="sd">            * If a single float, then that value will always be used as the</span>
<span class="sd">              scale.</span>
<span class="sd">            * If a tuple (a, b) of floats, then a random value will be picked</span>
<span class="sd">              from the interval (a, b) (per image).</span>
<span class="sd">            * If a list, then a random value will be sampled from that list</span>
<span class="sd">              per image.</span>
<span class="sd">            * If a StochasticParameter, then that parameter will be queried to</span>
<span class="sd">              draw one value per image.</span>

<span class="sd">    nb_rows : int or tuple of ints or StochasticParameter, optional(default=4)</span>
<span class="sd">        Number of rows of points that the regular grid should have.</span>
<span class="sd">        Must be at least 2. For large images, you might want to pick a</span>
<span class="sd">        higher value than 4. You might have to then adjust scale to lower</span>
<span class="sd">        values.</span>
<span class="sd">            * If a single int, then that value will always be used as the</span>
<span class="sd">              number of rows.</span>
<span class="sd">            * If a tuple (a, b), then a value from the discrete interval [a..b]</span>
<span class="sd">              will be sampled per image.</span>
<span class="sd">            * If a list, then a random value will be sampled from that list</span>
<span class="sd">              per image.</span>
<span class="sd">            * If a StochasticParameter, then that parameter will be queried to</span>
<span class="sd">              draw one value per image.</span>

<span class="sd">    nb_cols : int or tuple of ints or StochasticParameter, optional(default=4)</span>
<span class="sd">        Number of columns. See `nb_rows`.</span>

<span class="sd">    order : int or iterable of int or ia.ALL or StochasticParameter, optional(default=1)</span>
<span class="sd">        See Affine.__init__().</span>

<span class="sd">    cval : int or float or tuple of two floats or ia.ALL or StochasticParameter, optional(default=0)</span>
<span class="sd">        See Affine.__init__().</span>

<span class="sd">    mode : string or list of string or ia.ALL or StochasticParameter, optional(default=&quot;constant&quot;)</span>
<span class="sd">        See Affine.__init__().</span>

<span class="sd">    absolute_scale : bool, optional(default=False)</span>
<span class="sd">        Take `scale` as an absolute value rather than a relative value.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.PiecewiseAffine(scale=(0.01, 0.05))</span>

<span class="sd">    Puts a grid of points on each image and then randomly moves each point</span>
<span class="sd">    around by 1 to 5 percent (with respect to the image height/width). Pixels</span>
<span class="sd">    between these points will be moved accordingly.</span>

<span class="sd">    &gt;&gt;&gt; aug = iaa.PiecewiseAffine(scale=(0.01, 0.05), nb_rows=8, nb_cols=8)</span>

<span class="sd">    Same as the previous example, but uses a denser grid of 8x8 points (default</span>
<span class="sd">    is 4x4). This can be useful for large images.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nb_rows</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">nb_cols</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">absolute_scale</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PiecewiseAffine</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple/list with 2 entries for argument &#39;scale&#39;, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected float, int, tuple/list with 2 entries or StochasticParameter for argument &#39;scale&#39;. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">scale</span><span class="p">),))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">jitter</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">nb_rows</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_rows</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple/list with 2 entries for argument &#39;nb_rows&#39;, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_rows</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nb_rows</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">nb_rows</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_rows</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_rows</span> <span class="o">=</span> <span class="n">nb_rows</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected int, tuple of two ints or StochasticParameter as nb_rows, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">nb_cols</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_cols</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple/list with 2 entries for argument &#39;nb_cols&#39;, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_cols</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nb_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">val</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">nb_cols</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_cols</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nb_cols</span> <span class="o">=</span> <span class="n">nb_cols</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected int, tuple of two ints or StochasticParameter as nb_cols, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">),))</span>

        <span class="c1"># --------------</span>
        <span class="c1"># order, mode, cval</span>
        <span class="c1"># TODO these are the same as in class Affine, make DRY</span>
        <span class="c1"># --------------</span>

        <span class="c1"># Peformance:</span>
        <span class="c1">#  1.0x order 0</span>
        <span class="c1">#  1.5x order 1</span>
        <span class="c1">#  3.0x order 3</span>
        <span class="c1"># 30.0x order 4</span>
        <span class="c1"># 60.0x order 5</span>
        <span class="c1"># measurement based on 256x256x3 batches, difference is smaller</span>
        <span class="c1"># on smaller images (seems to grow more like exponentially with image</span>
        <span class="c1"># size)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="c1"># self.order = DiscreteUniform(0, 5)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span> <span class="c1"># dont use order=2 (bi-quadratic) because that is apparently currently not recommended (and throws a warning)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Expected order&#39;s integer value to be in range 0 &lt;= x &lt;= 5, got </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">order</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),</span> <span class="s2">&quot;Expected order list to only contain integers, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">5</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),</span> <span class="s2">&quot;Expected all of order&#39;s integer values to be in range 0 &lt;= x &lt;= 5, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected order to be imgaug.ALL, int or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">cval</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">255</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="n">cval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">([</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">255</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">cval</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cval</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">cval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected cval to be imgaug.ALL, int, float or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cval</span><span class="p">),))</span>

        <span class="c1"># constant, edge, symmetric, reflect, wrap</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="s2">&quot;wrap&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected mode to be imgaug.ALL, a string, a list of strings or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mode</span><span class="p">),))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">absolute_scale</span> <span class="o">=</span> <span class="n">absolute_scale</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>

        <span class="n">seeds</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">copy_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">nb_images</span><span class="o">+</span><span class="mi">1</span><span class="p">,))</span>

        <span class="n">seed</span> <span class="o">=</span> <span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nb_rows_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_rows</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">nb_cols_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cols</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">cval_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">mode_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">order_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">5</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">rs_image</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">transformer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_transformer</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">nb_rows_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nb_cols_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rs_image</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">transformer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#print(&quot;transformer vertices img&quot;, transformer._tesselation.vertices)</span>
                <span class="n">image_warped</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span>
                    <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">transformer</span><span class="p">,</span>
                    <span class="n">order</span><span class="o">=</span><span class="n">order_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">mode_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">cval</span><span class="o">=</span><span class="n">cval_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">output_shape</span><span class="o">=</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
                <span class="p">)</span>

                <span class="c1"># warp changes uint8 to float64, making this necessary</span>
                <span class="k">if</span> <span class="n">image_warped</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                    <span class="n">image_warped</span> <span class="o">=</span> <span class="n">image_warped</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

                <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">image_warped</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keypoints_on_images</span><span class="p">)</span>

        <span class="n">seeds</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">copy_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">nb_images</span><span class="o">+</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">seed</span> <span class="o">=</span> <span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nb_rows_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_rows</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">nb_cols_samples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cols</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">rs_image</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">kpsoi</span> <span class="o">=</span> <span class="n">keypoints_on_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">kpsoi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">transformer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_transformer</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">nb_rows_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nb_cols_samples</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rs_image</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">transformer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpsoi</span><span class="o">.</span><span class="n">keypoints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpsoi</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#print(&quot;transformer vertices kp&quot;, transformer._tesselation.vertices)</span>

                <span class="c1"># Augmentation routine that only modifies keypoint coordinates</span>
                <span class="c1"># This is efficient (coordinates of all other locations in the</span>
                <span class="c1"># image are ignored). The code below should usually work, but</span>
                <span class="c1"># for some reason augmented coordinates are often wildly off</span>
                <span class="c1"># for large scale parameters (lots of jitter/distortion).</span>
                <span class="c1"># The reason for that is unknown.</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                coords = keypoints_on_images[i].get_coords_array()</span>
<span class="sd">                coords_aug = transformer.inverse(coords)</span>
<span class="sd">                result.append(</span>
<span class="sd">                    ia.KeypointsOnImage.from_coords_array(</span>
<span class="sd">                        coords_aug,</span>
<span class="sd">                        shape=keypoints_on_images[i].shape</span>
<span class="sd">                    )</span>
<span class="sd">                )</span>
<span class="sd">                &quot;&quot;&quot;</span>


                <span class="c1"># Image based augmentation routine. Draws the keypoints on</span>
                <span class="c1"># the image plane (black and white, only keypoint marked),</span>
                <span class="c1"># then augments these images, then searches for the new</span>
                <span class="c1"># (visual) location of the keypoints.</span>
                <span class="c1"># Much slower than directly augmenting the coordinates, but</span>
                <span class="c1"># here the only method that reliably works.</span>
                <span class="n">kp_image</span> <span class="o">=</span> <span class="n">kpsoi</span><span class="o">.</span><span class="n">to_keypoint_image</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># size=1 sometimes leads to dropped/lost keypoints</span>
                <span class="n">kp_image_warped</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span>
                    <span class="n">kp_image</span><span class="p">,</span>
                    <span class="n">transformer</span><span class="p">,</span>
                    <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">output_shape</span><span class="o">=</span><span class="p">(</span><span class="n">kpsoi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kpsoi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpsoi</span><span class="o">.</span><span class="n">keypoints</span><span class="p">))</span>
                <span class="p">)</span>

                <span class="n">kps_aug</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">KeypointsOnImage</span><span class="o">.</span><span class="n">from_keypoint_image</span><span class="p">(</span>
                    <span class="n">kp_image_warped</span><span class="p">,</span>
                    <span class="n">if_not_found_coords</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">},</span>
                    <span class="n">nb_channels</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpsoi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">kpsoi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># TODO is this still necessary after nb_channels was added to</span>
                <span class="c1"># from_keypoint_image() ?</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpsoi</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">kps_aug</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">kps_aug</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="n">kps_aug</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">kpsoi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="p">)</span>

                <span class="c1"># Keypoints that were outside of the image plane before the</span>
                <span class="c1"># augmentation will be replaced with (-1, -1) by default (as</span>
                <span class="c1"># they can&#39;t be drawn on the keypoint images). They are now</span>
                <span class="c1"># replaced by their old coordinates values.</span>
                <span class="n">ooi</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">kp</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="ow">or</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">kp</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">kpsoi</span><span class="o">.</span><span class="n">keypoints</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">kp_idx</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">kps_aug</span><span class="o">.</span><span class="n">keypoints</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">ooi</span><span class="p">[</span><span class="n">kp_idx</span><span class="p">]:</span>
                        <span class="n">kp_unaug</span> <span class="o">=</span> <span class="n">kpsoi</span><span class="o">.</span><span class="n">keypoints</span><span class="p">[</span><span class="n">kp_idx</span><span class="p">]</span>
                        <span class="n">kps_aug</span><span class="o">.</span><span class="n">keypoints</span><span class="p">[</span><span class="n">kp_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">kp_unaug</span>

                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kps_aug</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_get_transformer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">nb_rows</span><span class="p">,</span> <span class="n">nb_cols</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="c1">#cell_height = h / self.rows</span>
        <span class="c1">#cell_width = w / self.cols</span>
        <span class="c1">#cell_height_h = cell_height / 2</span>
        <span class="c1">#cell_width_h = cell_width / 2</span>

        <span class="c1"># get coords on y and x axis of points to move around</span>
        <span class="c1"># these coordinates are supposed to be at the centers of each cell</span>
        <span class="c1"># (otherwise the first coordinate would be at (0, 0) and could hardly</span>
        <span class="c1"># be moved around before leaving the image),</span>
        <span class="c1"># so we use here (half cell height/width to H/W minus half height/width)</span>
        <span class="c1"># instead of (0, H/W)</span>
        <span class="c1">#y = np.linspace(cell_height_h, h - cell_height_h, self.rows)</span>
        <span class="c1">#x = np.linspace(cell_width_h, w - cell_width_h, self.cols)</span>

        <span class="n">nb_rows</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nb_rows</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">nb_cols</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nb_cols</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">nb_rows</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">nb_cols</span><span class="p">)</span>

        <span class="n">xx_src</span><span class="p">,</span> <span class="n">yy_src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="c1"># (H, W) and (H, W) for H=rows, W=cols</span>
        <span class="n">points_src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">yy_src</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">xx_src</span><span class="o">.</span><span class="n">flat</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># (1, HW, 2) =&gt; (HW, 2) for H=rows, W=cols</span>
        <span class="c1">#print(&quot;nb_rows&quot;, nb_rows, &quot;nb_cols&quot;, nb_cols, &quot;x&quot;, x, &quot;y&quot;, y, &quot;xx_src&quot;, xx_src.shape, &quot;yy_src&quot;, yy_src.shape, &quot;points_src&quot;, np.dstack([yy_src.flat, xx_src.flat]).shape)</span>

        <span class="n">jitter_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jitter</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">(</span><span class="n">points_src</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="n">nb_nonzero</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">jitter_img</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">nb_nonzero</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_scale</span><span class="p">:</span>
                <span class="n">jitter_img</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">jitter_img</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span>
                <span class="n">jitter_img</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">jitter_img</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span>
            <span class="n">points_dest</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">points_src</span><span class="p">)</span>
            <span class="n">points_dest</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points_dest</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">jitter_img</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">points_dest</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">points_dest</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">jitter_img</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Restrict all destination points to be inside the image plane.</span>
            <span class="c1"># This is necessary, as otherwise keypoints could be augmented</span>
            <span class="c1"># outside of the image plane and these would be replaced by</span>
            <span class="c1"># (-1, -1), which would not conform with the behaviour of the</span>
            <span class="c1"># other augmenters.</span>
            <span class="n">points_dest</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">points_dest</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">points_dest</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">points_dest</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">w</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#print(&quot;points_src&quot;, points_src, &quot;points_dest&quot;, points_dest)</span>

            <span class="n">matrix</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">PiecewiseAffineTransform</span><span class="p">()</span>
            <span class="n">matrix</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">points_src</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">points_dest</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">matrix</span>

<div class="viewcode-block" id="PiecewiseAffine.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.PiecewiseAffine.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_cols</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">absolute_scale</span><span class="p">]</span></div></div>

<div class="viewcode-block" id="PerspectiveTransform"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.PerspectiveTransform">[docs]</a><span class="k">class</span> <span class="nc">PerspectiveTransform</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter that performs a random four point perspective transform.</span>

<span class="sd">    Each of the four points is placed on the image using a random distance from</span>
<span class="sd">    its respective corner. The distance is sampled from a normal distribution.</span>
<span class="sd">    As a result, most transformations don&#39;t change very much, while some</span>
<span class="sd">    &quot;focus&quot; on polygons far inside the image.</span>

<span class="sd">    The results of this augmenter have some similarity with Crop.</span>

<span class="sd">    Code partially from http://www.pyimagesearch.com/2014/08/25/4-point-opencv-getperspective-transform-example/ .</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scale : float or tuple of two floats or StochasticParameter, optional(default=0)</span>
<span class="sd">        Standard deviation of the normal distributions. These are used to sample</span>
<span class="sd">        the random distances of the subimage&#39;s corners from the full image&#39;s</span>
<span class="sd">        corners. The sampled values reflect percentage values (with respect</span>
<span class="sd">        to image height/width). Recommended values are in the range 0.0 to 0.1.</span>
<span class="sd">            * If a single float, then that value will always be used as the</span>
<span class="sd">              scale.</span>
<span class="sd">            * If a tuple (a, b) of floats, then a random value will be picked</span>
<span class="sd">              from the interval (a, b) (per image).</span>
<span class="sd">            * If a list of values, a random one of the values will be picked</span>
<span class="sd">              per image.</span>
<span class="sd">            * If a StochasticParameter, then that parameter will be queried to</span>
<span class="sd">              draw one value per image.</span>

<span class="sd">    keep_size : bool, optional(default=True)</span>
<span class="sd">        Whether to resize image&#39;s back to their original size after applying</span>
<span class="sd">        the perspective transform. If set to False, the resulting images</span>
<span class="sd">        may end up having different shapes and will always be a list, never</span>
<span class="sd">        an array.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.PerspectiveTransform(scale=(0.01, 0.10))</span>

<span class="sd">    Applies perspective transformations using a random scale between 0.01 and</span>
<span class="sd">    0.1 per image, where the scale is roughly a measure of how far the</span>
<span class="sd">    perspective transform&#39;s corner points may be distanced from the original</span>
<span class="sd">    image&#39;s corner points.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keep_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PerspectiveTransform</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple with 2 entries for argument &#39;scale&#39;, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scale</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">scale</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected number, tuple of number, list of number or StochasticParameter for argument &#39;scale&#39;. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">scale</span><span class="p">),))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">jitter</span> <span class="o">=</span> <span class="n">Normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span> <span class="o">=</span> <span class="n">keep_size</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="n">matrices</span><span class="p">,</span> <span class="n">max_heights</span><span class="p">,</span> <span class="n">max_widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_matrices</span><span class="p">(</span>
            <span class="p">[</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">image</span> <span class="ow">in</span> <span class="n">images</span><span class="p">],</span>
            <span class="n">random_state</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">max_height</span><span class="p">,</span> <span class="n">max_width</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">max_heights</span><span class="p">,</span> <span class="n">max_widths</span><span class="p">)):</span>
            <span class="c1"># cv2.warpPerspective only supports &lt;=4 channels</span>
            <span class="c1">#ia.do_assert(images[i].shape[2] &lt;= 4, &quot;PerspectiveTransform is currently limited to images with 4 or less channels.&quot;)</span>
            <span class="n">nb_channels</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">nb_channels</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">warped</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="n">max_width</span><span class="p">,</span> <span class="n">max_height</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">warped</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">warped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">warped</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># warp each channel on its own, re-add channel axis, then stack</span>
                <span class="c1"># the result from a list of [H, W, 1] to (H, W, C).</span>
                <span class="n">warped</span> <span class="o">=</span> <span class="p">[</span><span class="n">cv2</span><span class="o">.</span><span class="n">warpPerspective</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="n">M</span><span class="p">,</span> <span class="p">(</span><span class="n">max_width</span><span class="p">,</span> <span class="n">max_height</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_channels</span><span class="p">)]</span>
                <span class="n">warped</span> <span class="o">=</span> <span class="p">[</span><span class="n">warped_i</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="k">for</span> <span class="n">warped_i</span> <span class="ow">in</span> <span class="n">warped</span><span class="p">]</span>
                <span class="n">warped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">warped</span><span class="p">)</span>
            <span class="c1">#print(np.min(warped), np.max(warped), warped.dtype)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">:</span>
                <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">warped</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">imresize_single_image</span><span class="p">(</span><span class="n">warped</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">),</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;cubic&quot;</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">warped</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">keypoints_on_images</span>
        <span class="n">matrices</span><span class="p">,</span> <span class="n">max_heights</span><span class="p">,</span> <span class="n">max_widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_matrices</span><span class="p">(</span>
            <span class="p">[</span><span class="n">kps</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">kps</span> <span class="ow">in</span> <span class="n">keypoints_on_images</span><span class="p">],</span>
            <span class="n">random_state</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">max_height</span><span class="p">,</span> <span class="n">max_width</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">matrices</span><span class="p">,</span> <span class="n">max_heights</span><span class="p">,</span> <span class="n">max_widths</span><span class="p">)):</span>
            <span class="n">keypoints_on_image</span> <span class="o">=</span> <span class="n">keypoints_on_images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">kps_arr</span> <span class="o">=</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">get_coords_array</span><span class="p">()</span>
            <span class="c1">#nb_channels = keypoints_on_image.shape[2] if len(keypoints_on_image.shape) &gt;= 3 else None</span>

            <span class="n">warped</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">perspectiveTransform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kps_arr</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">M</span><span class="p">)</span>
            <span class="n">warped</span> <span class="o">=</span> <span class="n">warped</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">warped_kps</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">KeypointsOnImage</span><span class="o">.</span><span class="n">from_coords_array</span><span class="p">(</span>
                <span class="n">warped</span><span class="p">,</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">max_height</span><span class="p">,</span> <span class="n">max_width</span><span class="p">)</span> <span class="o">+</span> <span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">:</span>
                <span class="n">warped_kps</span> <span class="o">=</span> <span class="n">warped_kps</span><span class="o">.</span><span class="n">on</span><span class="p">(</span><span class="n">keypoints_on_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">warped_kps</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_create_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="n">matrices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_heights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_widths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">copy_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">nb_images</span><span class="p">,))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jitter</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">points</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># top left</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># h = 1.0 - jitter</span>

            <span class="c1"># top right</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># w = 1.0 - jitter</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="c1"># h = 1.0 - jitter</span>

            <span class="c1"># bottom right</span>
            <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># h = 1.0 - jitter</span>

            <span class="c1"># bottom left</span>
            <span class="c1"># nothing</span>

            <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">w</span>
            <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span>

            <span class="c1"># obtain a consistent order of the points and unpack them</span>
            <span class="c1"># individually</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="p">(</span><span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">br</span><span class="p">,</span> <span class="n">bl</span><span class="p">)</span> <span class="o">=</span> <span class="n">points</span>

            <span class="c1"># compute the width of the new image, which will be the</span>
            <span class="c1"># maximum distance between bottom-right and bottom-left</span>
            <span class="c1"># x-coordiates or the top-right and top-left x-coordinates</span>
            <span class="n">widthA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">br</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">br</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">widthB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">tr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">tl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">maxWidth</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">widthA</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">widthB</span><span class="p">))</span>

            <span class="c1"># compute the height of the new image, which will be the</span>
            <span class="c1"># maximum distance between the top-right and bottom-right</span>
            <span class="c1"># y-coordinates or the top-left and bottom-left y-coordinates</span>
            <span class="n">heightA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">tr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">br</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">tr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">br</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">heightB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">tl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">tl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bl</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">maxHeight</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">heightA</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">heightB</span><span class="p">))</span>

            <span class="c1"># now that we have the dimensions of the new image, construct</span>
            <span class="c1"># the set of destination points to obtain a &quot;birds eye view&quot;,</span>
            <span class="c1"># (i.e. top-down view) of the image, again specifying points</span>
            <span class="c1"># in the top-left, top-right, bottom-right, and bottom-left</span>
            <span class="c1"># order</span>
            <span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">maxWidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="n">maxWidth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxHeight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">maxHeight</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

            <span class="c1"># compute the perspective transform matrix and then apply it</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">getPerspectiveTransform</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
            <span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
            <span class="n">max_heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxHeight</span><span class="p">)</span>
            <span class="n">max_widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">maxWidth</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">matrices</span><span class="p">,</span> <span class="n">max_heights</span><span class="p">,</span> <span class="n">max_widths</span>

    <span class="k">def</span> <span class="nf">_order_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">):</span>
        <span class="c1"># initialzie a list of coordinates that will be ordered</span>
        <span class="c1"># such that the first entry in the list is the top-left,</span>
        <span class="c1"># the second entry is the top-right, the third is the</span>
        <span class="c1"># bottom-right, and the fourth is the bottom-left</span>
        <span class="n">pts_ordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>

        <span class="c1"># the top-left point will have the smallest sum, whereas</span>
        <span class="c1"># the bottom-right point will have the largest sum</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pts_ordered</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
        <span class="n">pts_ordered</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>

        <span class="c1"># now, compute the difference between the points, the</span>
        <span class="c1"># top-right point will have the smallest difference,</span>
        <span class="c1"># whereas the bottom-left will have the largest difference</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pts_ordered</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">diff</span><span class="p">)]</span>
        <span class="n">pts_ordered</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">diff</span><span class="p">)]</span>

        <span class="c1"># return the ordered coordinates</span>
        <span class="k">return</span> <span class="n">pts_ordered</span>

<div class="viewcode-block" id="PerspectiveTransform.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.PerspectiveTransform.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">jitter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_size</span><span class="p">]</span></div></div>

<span class="c1"># code partially from</span>
<span class="c1"># https://gist.github.com/chsasank/4d8f68caf01f041a6453e67fb30f8f5a</span>
<div class="viewcode-block" id="ElasticTransformation"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.ElasticTransformation">[docs]</a><span class="k">class</span> <span class="nc">ElasticTransformation</span><span class="p">(</span><span class="n">Augmenter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augmenter to transform images by moving pixels locally around using</span>
<span class="sd">    displacement fields.</span>

<span class="sd">    See</span>
<span class="sd">        Simard, Steinkraus and Platt</span>
<span class="sd">        Best Practices for Convolutional Neural Networks applied to Visual</span>
<span class="sd">        Document Analysis</span>
<span class="sd">        in Proc. of the International Conference on Document Analysis and</span>
<span class="sd">        Recognition, 2003</span>
<span class="sd">    for a detailed explanation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alpha : float or tuple of two floats or StochasticParameter, optional(default=0)</span>
<span class="sd">        Strength of the distortion field. Higher values mean more &quot;movement&quot; of</span>
<span class="sd">        pixels.</span>
<span class="sd">            * If float, then that value will be used for all images.</span>
<span class="sd">            * If tuple (a, b), then a random value from range a &lt;= x &lt;= b will be</span>
<span class="sd">              sampled per image.</span>
<span class="sd">            * If a list, then for each image a random value will be sampled</span>
<span class="sd">              from that list.</span>
<span class="sd">            * If StochasticParameter, then that parameter will be used to sample</span>
<span class="sd">              a value per image.</span>

<span class="sd">    sigma : float or tuple of two floats or StochasticParameter, optional(default=0)</span>
<span class="sd">        Standard deviation of the gaussian kernel used to smooth the distortion</span>
<span class="sd">        fields.</span>
<span class="sd">            * If float, then that value will be used for all images.</span>
<span class="sd">            * If tuple (a, b), then a random value from range a &lt;= x &lt;= b will be</span>
<span class="sd">              sampled per image.</span>
<span class="sd">            * If a list, then for each image a random value will be sampled</span>
<span class="sd">              from that list.</span>
<span class="sd">            * If StochasticParameter, then that parameter will be used to sample</span>
<span class="sd">              a value per image.</span>

<span class="sd">    order : int or iterable of int or ia.ALL or StochasticParameter, optional(default=1)</span>
<span class="sd">        Interpolation order to use. Same meaning as in</span>
<span class="sd">        `scipy.ndimage.map_coordinates` and may take any integer value</span>
<span class="sd">        in the range 0 to 5, where orders close to 0 are faster.</span>
<span class="sd">            * If a single int, then that order will be used for all images.</span>
<span class="sd">            * If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b</span>
<span class="sd">              is picked per image.</span>
<span class="sd">            * If a list, then for each image a random value will be sampled</span>
<span class="sd">              from that list.</span>
<span class="sd">            * If ia.ALL, then equivalant to list [0, 1, 2, 3, 4, 5].</span>
<span class="sd">            * If StochasticParameter, then that parameter is queried per image</span>
<span class="sd">              to sample the order value to use.</span>

<span class="sd">    cval : number or tuple of two number or ia.ALL or StochasticParameter, optional(default=0)</span>
<span class="sd">        The constant intensity value used to fill in new pixels.</span>
<span class="sd">        This value is only used if `mode` is set to &quot;constant&quot;.</span>
<span class="sd">        For standard uint8 images (value range 0-255), this value may also</span>
<span class="sd">        come from the range 0-255. It may be a float value, even for</span>
<span class="sd">        integer image dtypes.</span>
<span class="sd">            * If this is a single int or float, then that value will be used</span>
<span class="sd">              (e.g. 0 results in black pixels).</span>
<span class="sd">            * If a tuple (a, b), then a random value from the range a &lt;= x &lt;= b</span>
<span class="sd">              is picked per image.</span>
<span class="sd">            * If a list, then a random value will be picked from that list per</span>
<span class="sd">              image.</span>
<span class="sd">            * If ia.ALL, a value from the discrete range [0 .. 255] will be</span>
<span class="sd">              sampled per image.</span>
<span class="sd">            * If a StochasticParameter, a new value will be sampled from the</span>
<span class="sd">              parameter per image.</span>

<span class="sd">    mode : string or list of string or ia.ALL or StochasticParameter, optional(default=&quot;constant&quot;)</span>
<span class="sd">        Parameter that defines the handling of newly created pixels.</span>
<span class="sd">        May take the same values as in `scipy.ndimage.map_coordinates`,</span>
<span class="sd">        i.e. &quot;constant&quot;, &quot;nearest&quot;, &quot;reflect&quot; or &quot;wrap&quot;.</span>
<span class="sd">        The datatype of the parameter may</span>
<span class="sd">        be:</span>
<span class="sd">            * If a single string, then that mode will be used for all images.</span>
<span class="sd">            * If a list of strings, then per image a random mode will be picked</span>
<span class="sd">              from that list.</span>
<span class="sd">            * If ia.ALL, then a random mode from all possible modes will be</span>
<span class="sd">              picked.</span>
<span class="sd">            * If StochasticParameter, then the mode will be sampled from that</span>
<span class="sd">              parameter per image, i.e. it must return only the above mentioned</span>
<span class="sd">              strings.</span>

<span class="sd">    name : string, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    deterministic : bool, optional(default=False)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    random_state : int or np.random.RandomState or None, optional(default=None)</span>
<span class="sd">        See `Augmenter.__init__()`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; aug = iaa.ElasticTransformation(alpha=0.5, sigma=0.25)</span>

<span class="sd">    apply elastic transformations with a strength/alpha of 0.5 and</span>
<span class="sd">    smoothness of 0.25 to all images.</span>


<span class="sd">    &gt;&gt;&gt; aug = iaa.ElasticTransformation(alpha=(0.25, 3.0), sigma=0.25)</span>

<span class="sd">    apply elastic transformations with a strength/alpha that comes</span>
<span class="sd">    from the range 0.25 &lt;= x &lt;= 3.0 (randomly picked per image) and</span>
<span class="sd">    smoothness of 0.25.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span>
                 <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ElasticTransformation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">deterministic</span><span class="o">=</span><span class="n">deterministic</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">alpha</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;Expected alpha to have range [0, inf), got value </span><span class="si">%.4f</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">alpha</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">alpha_i</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">alpha_i</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">alpha_i</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">alpha_i</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected number, tuple of number, list of number or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">alpha</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="n">sigma</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;Expected sigma to have range [0, inf), got value </span><span class="si">%.4f</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sigma</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sigma</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">sigma_i</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">sigma_i</span> <span class="ow">in</span> <span class="n">sigma</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">Uniform</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">sigma_i</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">sigma_i</span> <span class="ow">in</span> <span class="n">sigma</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected number, tuple of number, list of number or StochasticParameter. Got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sigma</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;Expected order&#39;s integer value to be in range 0 &lt;= x &lt;= 5, got </span><span class="si">%d</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">order</span><span class="p">,))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">order_i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="k">for</span> <span class="n">order_i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="n">order</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">order</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_single_integer</span><span class="p">(</span><span class="n">order_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">order_i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),</span> <span class="s2">&quot;Expected order list to only contain integers, got types </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">([</span><span class="nb">type</span><span class="p">(</span><span class="n">order_i</span><span class="p">)</span> <span class="k">for</span> <span class="n">order_i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">order_i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="k">for</span> <span class="n">order_i</span> <span class="ow">in</span> <span class="n">order</span><span class="p">]),</span> <span class="s2">&quot;Expected all of order&#39;s integer values to be in range 0 &lt;= x &lt;= 5, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected order to be imgaug.ALL, int, tuple of int, list of int or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">order</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">cval</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_single_number</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cval</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Expected tuple with 2 entries, got </span><span class="si">%d</span><span class="s2"> entries.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cval</span><span class="p">),))</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cval_i</span> <span class="o">&lt;=</span> <span class="mi">255</span> <span class="k">for</span> <span class="n">cval_i</span> <span class="ow">in</span> <span class="n">cval</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">DiscreteUniform</span><span class="p">(</span><span class="n">cval</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cval</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">cval</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">cval_i</span> <span class="o">&lt;=</span> <span class="mi">255</span> <span class="k">for</span> <span class="n">cval_i</span> <span class="ow">in</span> <span class="n">cval</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">cval</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cval</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cval</span> <span class="o">=</span> <span class="n">cval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected cval to be imgaug.ALL, number, tuple of number, list of number or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">cval</span><span class="p">),))</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="n">ia</span><span class="o">.</span><span class="n">ALL</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">([</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="s2">&quot;wrap&quot;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Deterministic</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ia</span><span class="o">.</span><span class="n">is_iterable</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
            <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">ia</span><span class="o">.</span><span class="n">is_string</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">Choice</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">StochasticParameter</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Expected mode to be imgaug.ALL, a string, a list of strings or StochasticParameter, got </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mode</span><span class="p">),))</span>

    <span class="k">def</span> <span class="nf">_augment_images</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">images</span>
        <span class="n">nb_images</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span>
        <span class="n">seeds</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">copy_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="n">nb_images</span><span class="o">+</span><span class="mi">1</span><span class="p">,))</span>
        <span class="n">alphas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">10000</span><span class="p">))</span>
        <span class="n">sigmas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">10100</span><span class="p">))</span>
        <span class="n">orders</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">10200</span><span class="p">))</span>
        <span class="n">cvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">10300</span><span class="p">))</span>
        <span class="n">modes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">draw_samples</span><span class="p">((</span><span class="n">nb_images</span><span class="p">,),</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">10400</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">nb_images</span><span class="p">):</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">image_first_channel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">indices_x</span><span class="p">,</span> <span class="n">indices_y</span> <span class="o">=</span> <span class="n">ElasticTransformation</span><span class="o">.</span><span class="n">generate_indices</span><span class="p">(</span><span class="n">image_first_channel</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alphas</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigmas</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">random_state</span><span class="o">=</span><span class="n">ia</span><span class="o">.</span><span class="n">new_random_state</span><span class="p">(</span><span class="n">seeds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ElasticTransformation</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span>
                <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">indices_x</span><span class="p">,</span>
                <span class="n">indices_y</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">orders</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">cval</span><span class="o">=</span><span class="n">cvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">modes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    def _augment_keypoints(self, keypoints_on_images, random_state, parents, hooks):</span>
<span class="sd">        # TODO do keypoints even have to be augmented for elastic transformations?</span>
<span class="sd">        # TODO this transforms keypoints to images, augments the images, then transforms</span>
<span class="sd">        # back to keypoints - inefficient and keypoints that get outside of the images</span>
<span class="sd">        # cannot be recovered</span>
<span class="sd">        result = []</span>
<span class="sd">        nb_images = len(keypoints_on_images)</span>
<span class="sd">        seeds = ia.copy_random_state(random_state).randint(0, 10**6, (nb_images,))</span>
<span class="sd">        alphas = self.alpha.draw_samples((nb_images,), random_state=ia.copy_random_state(random_state))</span>
<span class="sd">        sigmas = self.sigma.draw_samples((nb_images,), random_state=ia.copy_random_state(random_state))</span>
<span class="sd">        for i, keypoints_on_image in enumerate(keypoints_on_images):</span>
<span class="sd">            indices_x, indices_y = ElasticTransformation.generate_indices(keypoints_on_image.shape[0:2], alpha=alphas[i], sigma=sigmas[i], random_state=ia.new_random_state(seeds[i]))</span>
<span class="sd">            keypoint_image = keypoints_on_image.to_keypoint_image()</span>
<span class="sd">            keypoint_image_aug = ElasticTransformation.map_coordinates(keypoint_image, indices_x, indices_y)</span>
<span class="sd">            keypoints_aug = ia.KeypointsOnImage.from_keypoint_image(keypoint_image_aug)</span>
<span class="sd">            result.append(keypoints_aug)</span>
<span class="sd">        return result</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># no transformation of keypoints for this currently,</span>
    <span class="c1"># it seems like this is the more appropriate choice overall for this augmentation</span>
    <span class="c1"># technique</span>
    <span class="k">def</span> <span class="nf">_augment_keypoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keypoints_on_images</span><span class="p">,</span> <span class="n">random_state</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">hooks</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">keypoints_on_images</span>

<div class="viewcode-block" id="ElasticTransformation.get_parameters"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.ElasticTransformation.get_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cval</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">]</span></div>

<div class="viewcode-block" id="ElasticTransformation.generate_indices"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.ElasticTransformation.generate_indices">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">generate_indices</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">((</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">((</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">dx</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">dy</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="ElasticTransformation.map_coordinates"><a class="viewcode-back" href="../../../source/imgaug.html#imgaug.augmenters.geometric.ElasticTransformation.map_coordinates">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">indices_x</span><span class="p">,</span> <span class="n">indices_y</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">):</span>
        <span class="n">ia</span><span class="o">.</span><span class="n">do_assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">sm</span><span class="o">.</span><span class="n">xrange</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
            <span class="n">remapped_flat</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">map_coordinates</span><span class="p">(</span>
                <span class="n">image</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span>
                <span class="p">(</span><span class="n">indices_x</span><span class="p">,</span> <span class="n">indices_y</span><span class="p">),</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                <span class="n">cval</span><span class="o">=</span><span class="n">cval</span><span class="p">,</span>
                <span class="n">mode</span><span class="o">=</span><span class="n">mode</span>
            <span class="p">)</span>
            <span class="n">remapped</span> <span class="o">=</span> <span class="n">remapped_flat</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>
            <span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">remapped</span>
        <span class="k">return</span> <span class="n">result</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Alexander Jung.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.2.6',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  <script type="text/javascript">
      jQuery(function () {
          
          SphinxRtdTheme.Navigation.enableSticky();
          
      });
  </script> 

</body>
</html>